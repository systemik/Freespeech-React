{"ast":null,"code":"'use strict';\n\nconst MessageAttachment = require('./MessageAttachment');\n\nconst MessageEmbed = require('./MessageEmbed');\n\nconst {\n  RangeError\n} = require('../errors');\n\nconst {\n  browser\n} = require('../util/Constants');\n\nconst DataResolver = require('../util/DataResolver');\n\nconst MessageFlags = require('../util/MessageFlags');\n\nconst Util = require('../util/Util');\n/**\n * Represents a message to be sent to the API.\n */\n\n\nclass APIMessage {\n  /**\n   * @param {MessageTarget} target - The target for this message to be sent to\n   * @param {MessageOptions|WebhookMessageOptions} options - Options passed in from send\n   */\n  constructor(target, options) {\n    /**\n     * The target for this message to be sent to\n     * @type {MessageTarget}\n     */\n    this.target = target;\n    /**\n     * Options passed in from send\n     * @type {MessageOptions|WebhookMessageOptions}\n     */\n\n    this.options = options;\n    /**\n     * Data sendable to the API\n     * @type {?Object}\n     */\n\n    this.data = null;\n    /**\n     * Files sendable to the API\n     * @type {?Object[]}\n     */\n\n    this.files = null;\n  }\n  /**\n   * Whether or not the target is a webhook\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get isWebhook() {\n    const Webhook = require('./Webhook');\n\n    const WebhookClient = require('../client/WebhookClient');\n\n    return this.target instanceof Webhook || this.target instanceof WebhookClient;\n  }\n  /**\n   * Whether or not the target is a user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get isUser() {\n    const User = require('./User');\n\n    const GuildMember = require('./GuildMember');\n\n    return this.target instanceof User || this.target instanceof GuildMember;\n  }\n  /**\n   * Whether or not the target is a message\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get isMessage() {\n    const Message = require('./Message');\n\n    return this.target instanceof Message;\n  }\n  /**\n   * Makes the content of this message.\n   * @returns {?(string|string[])}\n   */\n\n\n  makeContent() {\n    const GuildMember = require('./GuildMember');\n\n    let content;\n\n    if (this.options.content === null) {\n      content = '';\n    } else if (typeof this.options.content !== 'undefined') {\n      content = Util.resolveString(this.options.content);\n    }\n\n    if (typeof content !== 'string') return content;\n    const disableMentions = typeof this.options.disableMentions === 'undefined' ? this.target.client.options.disableMentions : this.options.disableMentions;\n\n    if (disableMentions === 'all') {\n      content = Util.removeMentions(content);\n    } else if (disableMentions === 'everyone') {\n      content = content.replace(/@([^<>@ ]*)/gmsu, (match, target) => {\n        if (target.match(/^[&!]?\\d+$/)) {\n          return `@${target}`;\n        } else {\n          return `@\\u200b${target}`;\n        }\n      });\n    }\n\n    const isSplit = typeof this.options.split !== 'undefined' && this.options.split !== false;\n    const isCode = typeof this.options.code !== 'undefined' && this.options.code !== false;\n    const splitOptions = isSplit ? { ...this.options.split\n    } : undefined;\n    let mentionPart = '';\n\n    if (this.options.reply && !this.isUser && this.target.type !== 'dm') {\n      const id = this.target.client.users.resolveID(this.options.reply);\n      mentionPart = `<@${this.options.reply instanceof GuildMember && this.options.reply.nickname ? '!' : ''}${id}>, `;\n\n      if (isSplit) {\n        splitOptions.prepend = `${mentionPart}${splitOptions.prepend || ''}`;\n      }\n    }\n\n    if (content || mentionPart) {\n      if (isCode) {\n        const codeName = typeof this.options.code === 'string' ? this.options.code : '';\n        content = `${mentionPart}\\`\\`\\`${codeName}\\n${Util.cleanCodeBlockContent(content)}\\n\\`\\`\\``;\n\n        if (isSplit) {\n          splitOptions.prepend = `${splitOptions.prepend || ''}\\`\\`\\`${codeName}\\n`;\n          splitOptions.append = `\\n\\`\\`\\`${splitOptions.append || ''}`;\n        }\n      } else if (mentionPart) {\n        content = `${mentionPart}${content}`;\n      }\n\n      if (isSplit) {\n        content = Util.splitMessage(content, splitOptions);\n      }\n    }\n\n    return content;\n  }\n  /**\n   * Resolves data.\n   * @returns {APIMessage}\n   */\n\n\n  resolveData() {\n    if (this.data) return this;\n    const content = this.makeContent();\n    const tts = Boolean(this.options.tts);\n    let nonce;\n\n    if (typeof this.options.nonce !== 'undefined') {\n      nonce = parseInt(this.options.nonce);\n      if (isNaN(nonce) || nonce < 0) throw new RangeError('MESSAGE_NONCE_TYPE');\n    }\n\n    const embedLikes = [];\n\n    if (this.isWebhook) {\n      if (this.options.embeds) {\n        embedLikes.push(...this.options.embeds);\n      }\n    } else if (this.options.embed) {\n      embedLikes.push(this.options.embed);\n    }\n\n    const embeds = embedLikes.map(e => new MessageEmbed(e).toJSON());\n    let username;\n    let avatarURL;\n\n    if (this.isWebhook) {\n      username = this.options.username || this.target.name;\n      if (this.options.avatarURL) avatarURL = this.options.avatarURL;\n    }\n\n    let flags;\n\n    if (this.isMessage) {\n      // eslint-disable-next-line eqeqeq\n      flags = this.options.flags != null ? new MessageFlags(this.options.flags).bitfield : this.target.flags.bitfield;\n    }\n\n    let allowedMentions = typeof this.options.allowedMentions === 'undefined' ? this.target.client.options.allowedMentions : this.options.allowedMentions;\n\n    if (this.options.reply) {\n      const id = this.target.client.users.resolveID(this.options.reply);\n\n      if (allowedMentions) {\n        // Clone the object as not to alter the ClientOptions object\n        allowedMentions = Util.cloneObject(allowedMentions);\n        const parsed = allowedMentions.parse && allowedMentions.parse.includes('users'); // Check if the mention won't be parsed, and isn't supplied in `users`\n\n        if (!parsed && !(allowedMentions.users && allowedMentions.users.includes(id))) {\n          if (!allowedMentions.users) allowedMentions.users = [];\n          allowedMentions.users.push(id);\n        }\n      } else {\n        allowedMentions = {\n          users: [id]\n        };\n      }\n    }\n\n    this.data = {\n      content,\n      tts,\n      nonce,\n      embed: this.options.embed === null ? null : embeds[0],\n      embeds,\n      username,\n      avatar_url: avatarURL,\n      allowed_mentions: typeof content === 'undefined' ? undefined : allowedMentions,\n      flags\n    };\n    return this;\n  }\n  /**\n   * Resolves files.\n   * @returns {Promise<APIMessage>}\n   */\n\n\n  async resolveFiles() {\n    if (this.files) return this;\n    const embedLikes = [];\n\n    if (this.isWebhook) {\n      if (this.options.embeds) {\n        embedLikes.push(...this.options.embeds);\n      }\n    } else if (this.options.embed) {\n      embedLikes.push(this.options.embed);\n    }\n\n    const fileLikes = [];\n\n    if (this.options.files) {\n      fileLikes.push(...this.options.files);\n    }\n\n    for (const embed of embedLikes) {\n      if (embed.files) {\n        fileLikes.push(...embed.files);\n      }\n    }\n\n    this.files = await Promise.all(fileLikes.map(f => this.constructor.resolveFile(f)));\n    return this;\n  }\n  /**\n   * Converts this APIMessage into an array of APIMessages for each split content\n   * @returns {APIMessage[]}\n   */\n\n\n  split() {\n    if (!this.data) this.resolveData();\n    if (!Array.isArray(this.data.content)) return [this];\n    const apiMessages = [];\n\n    for (let i = 0; i < this.data.content.length; i++) {\n      let data;\n      let opt;\n\n      if (i === this.data.content.length - 1) {\n        data = { ...this.data,\n          content: this.data.content[i]\n        };\n        opt = { ...this.options,\n          content: this.data.content[i]\n        };\n      } else {\n        data = {\n          content: this.data.content[i],\n          tts: this.data.tts,\n          allowed_mentions: this.options.allowedMentions\n        };\n        opt = {\n          content: this.data.content[i],\n          tts: this.data.tts,\n          allowedMentions: this.options.allowedMentions\n        };\n      }\n\n      const apiMessage = new APIMessage(this.target, opt);\n      apiMessage.data = data;\n      apiMessages.push(apiMessage);\n    }\n\n    return apiMessages;\n  }\n  /**\n   * Resolves a single file into an object sendable to the API.\n   * @param {BufferResolvable|Stream|FileOptions|MessageAttachment} fileLike Something that could be resolved to a file\n   * @returns {Object}\n   */\n\n\n  static async resolveFile(fileLike) {\n    let attachment;\n    let name;\n\n    const findName = thing => {\n      if (typeof thing === 'string') {\n        return Util.basename(thing);\n      }\n\n      if (thing.path) {\n        return Util.basename(thing.path);\n      }\n\n      return 'file.jpg';\n    };\n\n    const ownAttachment = typeof fileLike === 'string' || fileLike instanceof (browser ? ArrayBuffer : Buffer) || typeof fileLike.pipe === 'function';\n\n    if (ownAttachment) {\n      attachment = fileLike;\n      name = findName(attachment);\n    } else {\n      attachment = fileLike.attachment;\n      name = fileLike.name || findName(attachment);\n    }\n\n    const resource = await DataResolver.resolveFile(attachment);\n    return {\n      attachment,\n      name,\n      file: resource\n    };\n  }\n  /**\n   * Partitions embeds and attachments.\n   * @param {Array<MessageEmbed|MessageAttachment>} items Items to partition\n   * @returns {Array<MessageEmbed[], MessageAttachment[]>}\n   */\n\n\n  static partitionMessageAdditions(items) {\n    const embeds = [];\n    const files = [];\n\n    for (const item of items) {\n      if (item instanceof MessageEmbed) {\n        embeds.push(item);\n      } else if (item instanceof MessageAttachment) {\n        files.push(item);\n      }\n    }\n\n    return [embeds, files];\n  }\n  /**\n   * Transforms the user-level arguments into a final options object. Passing a transformed options object alone into\n   * this method will keep it the same, allowing for the reuse of the final options object.\n   * @param {StringResolvable} [content] Content to send\n   * @param {MessageOptions|WebhookMessageOptions|MessageAdditions} [options={}] Options to use\n   * @param {MessageOptions|WebhookMessageOptions} [extra={}] Extra options to add onto transformed options\n   * @param {boolean} [isWebhook=false] Whether or not to use WebhookMessageOptions as the result\n   * @returns {MessageOptions|WebhookMessageOptions}\n   */\n\n\n  static transformOptions(content, options) {\n    let extra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let isWebhook = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    if (!options && typeof content === 'object' && !Array.isArray(content)) {\n      options = content;\n      content = undefined;\n    }\n\n    if (!options) {\n      options = {};\n    } else if (options instanceof MessageEmbed) {\n      return isWebhook ? {\n        content,\n        embeds: [options],\n        ...extra\n      } : {\n        content,\n        embed: options,\n        ...extra\n      };\n    } else if (options instanceof MessageAttachment) {\n      return {\n        content,\n        files: [options],\n        ...extra\n      };\n    }\n\n    if (Array.isArray(options)) {\n      const [embeds, files] = this.partitionMessageAdditions(options);\n      return isWebhook ? {\n        content,\n        embeds,\n        files,\n        ...extra\n      } : {\n        content,\n        embed: embeds[0],\n        files,\n        ...extra\n      };\n    } else if (Array.isArray(content)) {\n      const [embeds, files] = this.partitionMessageAdditions(content);\n\n      if (embeds.length || files.length) {\n        return isWebhook ? {\n          embeds,\n          files,\n          ...extra\n        } : {\n          embed: embeds[0],\n          files,\n          ...extra\n        };\n      }\n    }\n\n    return {\n      content,\n      ...options,\n      ...extra\n    };\n  }\n  /**\n   * Creates an `APIMessage` from user-level arguments.\n   * @param {MessageTarget} target Target to send to\n   * @param {StringResolvable} [content] Content to send\n   * @param {MessageOptions|WebhookMessageOptions|MessageAdditions} [options={}] Options to use\n   * @param {MessageOptions|WebhookMessageOptions} [extra={}] - Extra options to add onto transformed options\n   * @returns {MessageOptions|WebhookMessageOptions}\n   */\n\n\n  static create(target, content, options) {\n    let extra = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    const Webhook = require('./Webhook');\n\n    const WebhookClient = require('../client/WebhookClient');\n\n    const isWebhook = target instanceof Webhook || target instanceof WebhookClient;\n    const transformed = this.transformOptions(content, options, extra, isWebhook);\n    return new this(target, transformed);\n  }\n\n}\n\nmodule.exports = APIMessage;\n/**\n * A target for a message.\n * @typedef {TextChannel|DMChannel|User|GuildMember|Webhook|WebhookClient} MessageTarget\n */\n\n/**\n * Additional items that can be sent with a message.\n * @typedef {MessageEmbed|MessageAttachment|Array<MessageEmbed|MessageAttachment>} MessageAdditions\n */","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/structures/APIMessage.js"],"names":["MessageAttachment","require","MessageEmbed","RangeError","browser","DataResolver","MessageFlags","Util","APIMessage","constructor","target","options","data","files","isWebhook","Webhook","WebhookClient","isUser","User","GuildMember","isMessage","Message","makeContent","content","resolveString","disableMentions","client","removeMentions","replace","match","isSplit","split","isCode","code","splitOptions","undefined","mentionPart","reply","type","id","users","resolveID","nickname","prepend","codeName","cleanCodeBlockContent","append","splitMessage","resolveData","tts","Boolean","nonce","parseInt","isNaN","embedLikes","embeds","push","embed","map","e","toJSON","username","avatarURL","name","flags","bitfield","allowedMentions","cloneObject","parsed","parse","includes","avatar_url","allowed_mentions","resolveFiles","fileLikes","Promise","all","f","resolveFile","Array","isArray","apiMessages","i","length","opt","apiMessage","fileLike","attachment","findName","thing","basename","path","ownAttachment","ArrayBuffer","Buffer","pipe","resource","file","partitionMessageAdditions","items","item","transformOptions","extra","create","transformed","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst MessageAttachment = require('./MessageAttachment');\nconst MessageEmbed = require('./MessageEmbed');\nconst { RangeError } = require('../errors');\nconst { browser } = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst MessageFlags = require('../util/MessageFlags');\nconst Util = require('../util/Util');\n\n/**\n * Represents a message to be sent to the API.\n */\nclass APIMessage {\n  /**\n   * @param {MessageTarget} target - The target for this message to be sent to\n   * @param {MessageOptions|WebhookMessageOptions} options - Options passed in from send\n   */\n  constructor(target, options) {\n    /**\n     * The target for this message to be sent to\n     * @type {MessageTarget}\n     */\n    this.target = target;\n\n    /**\n     * Options passed in from send\n     * @type {MessageOptions|WebhookMessageOptions}\n     */\n    this.options = options;\n\n    /**\n     * Data sendable to the API\n     * @type {?Object}\n     */\n    this.data = null;\n\n    /**\n     * Files sendable to the API\n     * @type {?Object[]}\n     */\n    this.files = null;\n  }\n\n  /**\n   * Whether or not the target is a webhook\n   * @type {boolean}\n   * @readonly\n   */\n  get isWebhook() {\n    const Webhook = require('./Webhook');\n    const WebhookClient = require('../client/WebhookClient');\n    return this.target instanceof Webhook || this.target instanceof WebhookClient;\n  }\n\n  /**\n   * Whether or not the target is a user\n   * @type {boolean}\n   * @readonly\n   */\n  get isUser() {\n    const User = require('./User');\n    const GuildMember = require('./GuildMember');\n    return this.target instanceof User || this.target instanceof GuildMember;\n  }\n\n  /**\n   * Whether or not the target is a message\n   * @type {boolean}\n   * @readonly\n   */\n  get isMessage() {\n    const Message = require('./Message');\n    return this.target instanceof Message;\n  }\n\n  /**\n   * Makes the content of this message.\n   * @returns {?(string|string[])}\n   */\n  makeContent() {\n    const GuildMember = require('./GuildMember');\n\n    let content;\n    if (this.options.content === null) {\n      content = '';\n    } else if (typeof this.options.content !== 'undefined') {\n      content = Util.resolveString(this.options.content);\n    }\n\n    if (typeof content !== 'string') return content;\n\n    const disableMentions =\n      typeof this.options.disableMentions === 'undefined'\n        ? this.target.client.options.disableMentions\n        : this.options.disableMentions;\n    if (disableMentions === 'all') {\n      content = Util.removeMentions(content);\n    } else if (disableMentions === 'everyone') {\n      content = content.replace(/@([^<>@ ]*)/gmsu, (match, target) => {\n        if (target.match(/^[&!]?\\d+$/)) {\n          return `@${target}`;\n        } else {\n          return `@\\u200b${target}`;\n        }\n      });\n    }\n\n    const isSplit = typeof this.options.split !== 'undefined' && this.options.split !== false;\n    const isCode = typeof this.options.code !== 'undefined' && this.options.code !== false;\n    const splitOptions = isSplit ? { ...this.options.split } : undefined;\n\n    let mentionPart = '';\n    if (this.options.reply && !this.isUser && this.target.type !== 'dm') {\n      const id = this.target.client.users.resolveID(this.options.reply);\n      mentionPart = `<@${this.options.reply instanceof GuildMember && this.options.reply.nickname ? '!' : ''}${id}>, `;\n      if (isSplit) {\n        splitOptions.prepend = `${mentionPart}${splitOptions.prepend || ''}`;\n      }\n    }\n\n    if (content || mentionPart) {\n      if (isCode) {\n        const codeName = typeof this.options.code === 'string' ? this.options.code : '';\n        content = `${mentionPart}\\`\\`\\`${codeName}\\n${Util.cleanCodeBlockContent(content)}\\n\\`\\`\\``;\n        if (isSplit) {\n          splitOptions.prepend = `${splitOptions.prepend || ''}\\`\\`\\`${codeName}\\n`;\n          splitOptions.append = `\\n\\`\\`\\`${splitOptions.append || ''}`;\n        }\n      } else if (mentionPart) {\n        content = `${mentionPart}${content}`;\n      }\n\n      if (isSplit) {\n        content = Util.splitMessage(content, splitOptions);\n      }\n    }\n\n    return content;\n  }\n\n  /**\n   * Resolves data.\n   * @returns {APIMessage}\n   */\n  resolveData() {\n    if (this.data) return this;\n\n    const content = this.makeContent();\n    const tts = Boolean(this.options.tts);\n\n    let nonce;\n    if (typeof this.options.nonce !== 'undefined') {\n      nonce = parseInt(this.options.nonce);\n      if (isNaN(nonce) || nonce < 0) throw new RangeError('MESSAGE_NONCE_TYPE');\n    }\n\n    const embedLikes = [];\n    if (this.isWebhook) {\n      if (this.options.embeds) {\n        embedLikes.push(...this.options.embeds);\n      }\n    } else if (this.options.embed) {\n      embedLikes.push(this.options.embed);\n    }\n    const embeds = embedLikes.map(e => new MessageEmbed(e).toJSON());\n\n    let username;\n    let avatarURL;\n    if (this.isWebhook) {\n      username = this.options.username || this.target.name;\n      if (this.options.avatarURL) avatarURL = this.options.avatarURL;\n    }\n\n    let flags;\n    if (this.isMessage) {\n      // eslint-disable-next-line eqeqeq\n      flags = this.options.flags != null ? new MessageFlags(this.options.flags).bitfield : this.target.flags.bitfield;\n    }\n\n    let allowedMentions =\n      typeof this.options.allowedMentions === 'undefined'\n        ? this.target.client.options.allowedMentions\n        : this.options.allowedMentions;\n    if (this.options.reply) {\n      const id = this.target.client.users.resolveID(this.options.reply);\n      if (allowedMentions) {\n        // Clone the object as not to alter the ClientOptions object\n        allowedMentions = Util.cloneObject(allowedMentions);\n        const parsed = allowedMentions.parse && allowedMentions.parse.includes('users');\n        // Check if the mention won't be parsed, and isn't supplied in `users`\n        if (!parsed && !(allowedMentions.users && allowedMentions.users.includes(id))) {\n          if (!allowedMentions.users) allowedMentions.users = [];\n          allowedMentions.users.push(id);\n        }\n      } else {\n        allowedMentions = { users: [id] };\n      }\n    }\n\n    this.data = {\n      content,\n      tts,\n      nonce,\n      embed: this.options.embed === null ? null : embeds[0],\n      embeds,\n      username,\n      avatar_url: avatarURL,\n      allowed_mentions: typeof content === 'undefined' ? undefined : allowedMentions,\n      flags,\n    };\n    return this;\n  }\n\n  /**\n   * Resolves files.\n   * @returns {Promise<APIMessage>}\n   */\n  async resolveFiles() {\n    if (this.files) return this;\n\n    const embedLikes = [];\n    if (this.isWebhook) {\n      if (this.options.embeds) {\n        embedLikes.push(...this.options.embeds);\n      }\n    } else if (this.options.embed) {\n      embedLikes.push(this.options.embed);\n    }\n\n    const fileLikes = [];\n    if (this.options.files) {\n      fileLikes.push(...this.options.files);\n    }\n    for (const embed of embedLikes) {\n      if (embed.files) {\n        fileLikes.push(...embed.files);\n      }\n    }\n\n    this.files = await Promise.all(fileLikes.map(f => this.constructor.resolveFile(f)));\n    return this;\n  }\n\n  /**\n   * Converts this APIMessage into an array of APIMessages for each split content\n   * @returns {APIMessage[]}\n   */\n  split() {\n    if (!this.data) this.resolveData();\n\n    if (!Array.isArray(this.data.content)) return [this];\n\n    const apiMessages = [];\n\n    for (let i = 0; i < this.data.content.length; i++) {\n      let data;\n      let opt;\n\n      if (i === this.data.content.length - 1) {\n        data = { ...this.data, content: this.data.content[i] };\n        opt = { ...this.options, content: this.data.content[i] };\n      } else {\n        data = { content: this.data.content[i], tts: this.data.tts, allowed_mentions: this.options.allowedMentions };\n        opt = { content: this.data.content[i], tts: this.data.tts, allowedMentions: this.options.allowedMentions };\n      }\n\n      const apiMessage = new APIMessage(this.target, opt);\n      apiMessage.data = data;\n      apiMessages.push(apiMessage);\n    }\n\n    return apiMessages;\n  }\n\n  /**\n   * Resolves a single file into an object sendable to the API.\n   * @param {BufferResolvable|Stream|FileOptions|MessageAttachment} fileLike Something that could be resolved to a file\n   * @returns {Object}\n   */\n  static async resolveFile(fileLike) {\n    let attachment;\n    let name;\n\n    const findName = thing => {\n      if (typeof thing === 'string') {\n        return Util.basename(thing);\n      }\n\n      if (thing.path) {\n        return Util.basename(thing.path);\n      }\n\n      return 'file.jpg';\n    };\n\n    const ownAttachment =\n      typeof fileLike === 'string' ||\n      fileLike instanceof (browser ? ArrayBuffer : Buffer) ||\n      typeof fileLike.pipe === 'function';\n    if (ownAttachment) {\n      attachment = fileLike;\n      name = findName(attachment);\n    } else {\n      attachment = fileLike.attachment;\n      name = fileLike.name || findName(attachment);\n    }\n\n    const resource = await DataResolver.resolveFile(attachment);\n    return { attachment, name, file: resource };\n  }\n\n  /**\n   * Partitions embeds and attachments.\n   * @param {Array<MessageEmbed|MessageAttachment>} items Items to partition\n   * @returns {Array<MessageEmbed[], MessageAttachment[]>}\n   */\n  static partitionMessageAdditions(items) {\n    const embeds = [];\n    const files = [];\n    for (const item of items) {\n      if (item instanceof MessageEmbed) {\n        embeds.push(item);\n      } else if (item instanceof MessageAttachment) {\n        files.push(item);\n      }\n    }\n\n    return [embeds, files];\n  }\n\n  /**\n   * Transforms the user-level arguments into a final options object. Passing a transformed options object alone into\n   * this method will keep it the same, allowing for the reuse of the final options object.\n   * @param {StringResolvable} [content] Content to send\n   * @param {MessageOptions|WebhookMessageOptions|MessageAdditions} [options={}] Options to use\n   * @param {MessageOptions|WebhookMessageOptions} [extra={}] Extra options to add onto transformed options\n   * @param {boolean} [isWebhook=false] Whether or not to use WebhookMessageOptions as the result\n   * @returns {MessageOptions|WebhookMessageOptions}\n   */\n  static transformOptions(content, options, extra = {}, isWebhook = false) {\n    if (!options && typeof content === 'object' && !Array.isArray(content)) {\n      options = content;\n      content = undefined;\n    }\n\n    if (!options) {\n      options = {};\n    } else if (options instanceof MessageEmbed) {\n      return isWebhook ? { content, embeds: [options], ...extra } : { content, embed: options, ...extra };\n    } else if (options instanceof MessageAttachment) {\n      return { content, files: [options], ...extra };\n    }\n\n    if (Array.isArray(options)) {\n      const [embeds, files] = this.partitionMessageAdditions(options);\n      return isWebhook ? { content, embeds, files, ...extra } : { content, embed: embeds[0], files, ...extra };\n    } else if (Array.isArray(content)) {\n      const [embeds, files] = this.partitionMessageAdditions(content);\n      if (embeds.length || files.length) {\n        return isWebhook ? { embeds, files, ...extra } : { embed: embeds[0], files, ...extra };\n      }\n    }\n\n    return { content, ...options, ...extra };\n  }\n\n  /**\n   * Creates an `APIMessage` from user-level arguments.\n   * @param {MessageTarget} target Target to send to\n   * @param {StringResolvable} [content] Content to send\n   * @param {MessageOptions|WebhookMessageOptions|MessageAdditions} [options={}] Options to use\n   * @param {MessageOptions|WebhookMessageOptions} [extra={}] - Extra options to add onto transformed options\n   * @returns {MessageOptions|WebhookMessageOptions}\n   */\n  static create(target, content, options, extra = {}) {\n    const Webhook = require('./Webhook');\n    const WebhookClient = require('../client/WebhookClient');\n\n    const isWebhook = target instanceof Webhook || target instanceof WebhookClient;\n    const transformed = this.transformOptions(content, options, extra, isWebhook);\n    return new this(target, transformed);\n  }\n}\n\nmodule.exports = APIMessage;\n\n/**\n * A target for a message.\n * @typedef {TextChannel|DMChannel|User|GuildMember|Webhook|WebhookClient} MessageTarget\n */\n\n/**\n * Additional items that can be sent with a message.\n * @typedef {MessageEmbed|MessageAttachment|Array<MessageEmbed|MessageAttachment>} MessageAdditions\n */\n"]},"metadata":{},"sourceType":"script"}