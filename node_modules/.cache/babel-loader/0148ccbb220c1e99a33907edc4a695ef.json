{"ast":null,"code":"'use strict';\n\nconst BaseManager = require('./BaseManager');\n\nconst GuildMember = require('../structures/GuildMember');\n\nconst Message = require('../structures/Message');\n\nconst User = require('../structures/User');\n/**\n * Manages API methods for users and stores their cache.\n * @extends {BaseManager}\n */\n\n\nclass UserManager extends BaseManager {\n  constructor(client, iterable) {\n    super(client, iterable, User);\n  }\n  /**\n   * The cache of this manager\n   * @type {Collection<Snowflake, User>}\n   * @name UserManager#cache\n   */\n\n  /**\n   * Data that resolves to give a User object. This can be:\n   * * A User object\n   * * A Snowflake\n   * * A Message object (resolves to the message author)\n   * * A GuildMember object\n   * @typedef {User|Snowflake|Message|GuildMember} UserResolvable\n   */\n\n  /**\n   * Resolves a UserResolvable to a User object.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {?User}\n   */\n\n\n  resolve(user) {\n    if (user instanceof GuildMember) return user.user;\n    if (user instanceof Message) return user.author;\n    return super.resolve(user);\n  }\n  /**\n   * Resolves a UserResolvable to a user ID string.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {?Snowflake}\n   */\n\n\n  resolveID(user) {\n    if (user instanceof GuildMember) return user.user.id;\n    if (user instanceof Message) return user.author.id;\n    return super.resolveID(user);\n  }\n  /**\n   * Obtains a user from Discord, or the user cache if it's already available.\n   * @param {Snowflake} id ID of the user\n   * @param {boolean} [cache=true] Whether to cache the new user object if it isn't already\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<User>}\n   */\n\n\n  async fetch(id) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.api.users(id).get();\n    return this.add(data, cache);\n  }\n\n}\n\nmodule.exports = UserManager;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/managers/UserManager.js"],"names":["BaseManager","require","GuildMember","Message","User","UserManager","constructor","client","iterable","resolve","user","author","resolveID","id","fetch","cache","force","existing","get","partial","data","api","users","add","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,WAAW,GAAGC,OAAO,CAAC,eAAD,CAA3B;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,2BAAD,CAA3B;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,uBAAD,CAAvB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,oBAAD,CAApB;AAEA;AACA;AACA;AACA;;;AACA,MAAMI,WAAN,SAA0BL,WAA1B,CAAsC;AACpCM,EAAAA,WAAW,CAACC,MAAD,EAASC,QAAT,EAAmB;AAC5B,UAAMD,MAAN,EAAcC,QAAd,EAAwBJ,IAAxB;AACD;AAED;AACF;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;;;AACEK,EAAAA,OAAO,CAACC,IAAD,EAAO;AACZ,QAAIA,IAAI,YAAYR,WAApB,EAAiC,OAAOQ,IAAI,CAACA,IAAZ;AACjC,QAAIA,IAAI,YAAYP,OAApB,EAA6B,OAAOO,IAAI,CAACC,MAAZ;AAC7B,WAAO,MAAMF,OAAN,CAAcC,IAAd,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEE,EAAAA,SAAS,CAACF,IAAD,EAAO;AACd,QAAIA,IAAI,YAAYR,WAApB,EAAiC,OAAOQ,IAAI,CAACA,IAAL,CAAUG,EAAjB;AACjC,QAAIH,IAAI,YAAYP,OAApB,EAA6B,OAAOO,IAAI,CAACC,MAAL,CAAYE,EAAnB;AAC7B,WAAO,MAAMD,SAAN,CAAgBF,IAAhB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACa,QAALI,KAAK,CAACD,EAAD,EAAkC;AAAA,QAA7BE,KAA6B,uEAArB,IAAqB;AAAA,QAAfC,KAAe,uEAAP,KAAO;;AAC3C,QAAI,CAACA,KAAL,EAAY;AACV,YAAMC,QAAQ,GAAG,KAAKF,KAAL,CAAWG,GAAX,CAAeL,EAAf,CAAjB;AACA,UAAII,QAAQ,IAAI,CAACA,QAAQ,CAACE,OAA1B,EAAmC,OAAOF,QAAP;AACpC;;AAED,UAAMG,IAAI,GAAG,MAAM,KAAKb,MAAL,CAAYc,GAAZ,CAAgBC,KAAhB,CAAsBT,EAAtB,EAA0BK,GAA1B,EAAnB;AACA,WAAO,KAAKK,GAAL,CAASH,IAAT,EAAeL,KAAf,CAAP;AACD;;AAzDmC;;AA4DtCS,MAAM,CAACC,OAAP,GAAiBpB,WAAjB","sourcesContent":["'use strict';\n\nconst BaseManager = require('./BaseManager');\nconst GuildMember = require('../structures/GuildMember');\nconst Message = require('../structures/Message');\nconst User = require('../structures/User');\n\n/**\n * Manages API methods for users and stores their cache.\n * @extends {BaseManager}\n */\nclass UserManager extends BaseManager {\n  constructor(client, iterable) {\n    super(client, iterable, User);\n  }\n\n  /**\n   * The cache of this manager\n   * @type {Collection<Snowflake, User>}\n   * @name UserManager#cache\n   */\n\n  /**\n   * Data that resolves to give a User object. This can be:\n   * * A User object\n   * * A Snowflake\n   * * A Message object (resolves to the message author)\n   * * A GuildMember object\n   * @typedef {User|Snowflake|Message|GuildMember} UserResolvable\n   */\n\n  /**\n   * Resolves a UserResolvable to a User object.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {?User}\n   */\n  resolve(user) {\n    if (user instanceof GuildMember) return user.user;\n    if (user instanceof Message) return user.author;\n    return super.resolve(user);\n  }\n\n  /**\n   * Resolves a UserResolvable to a user ID string.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {?Snowflake}\n   */\n  resolveID(user) {\n    if (user instanceof GuildMember) return user.user.id;\n    if (user instanceof Message) return user.author.id;\n    return super.resolveID(user);\n  }\n\n  /**\n   * Obtains a user from Discord, or the user cache if it's already available.\n   * @param {Snowflake} id ID of the user\n   * @param {boolean} [cache=true] Whether to cache the new user object if it isn't already\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<User>}\n   */\n  async fetch(id, cache = true, force = false) {\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.api.users(id).get();\n    return this.add(data, cache);\n  }\n}\n\nmodule.exports = UserManager;\n"]},"metadata":{},"sourceType":"script"}