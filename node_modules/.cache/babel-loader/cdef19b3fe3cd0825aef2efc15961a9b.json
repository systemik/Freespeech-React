{"ast":null,"code":"'use strict';\n\nconst Collector = require('./interfaces/Collector');\n\nconst {\n  Events\n} = require('../util/Constants');\n/**\n * @typedef {CollectorOptions} MessageCollectorOptions\n * @property {number} max The maximum amount of messages to collect\n * @property {number} maxProcessed The maximum amount of messages to process\n */\n\n/**\n * Collects messages on a channel.\n * Will automatically stop if the channel (`'channelDelete'`) or guild (`'guildDelete'`) are deleted.\n * @extends {Collector}\n */\n\n\nclass MessageCollector extends Collector {\n  /**\n   * @param {TextChannel|DMChannel} channel The channel\n   * @param {CollectorFilter} filter The filter to be applied to this collector\n   * @param {MessageCollectorOptions} options The options to be applied to this collector\n   * @emits MessageCollector#message\n   */\n  constructor(channel, filter) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(channel.client, filter, options);\n    /**\n     * The channel\n     * @type {TextBasedChannel}\n     */\n\n    this.channel = channel;\n    /**\n     * Total number of messages that were received in the channel during message collection\n     * @type {number}\n     */\n\n    this.received = 0;\n\n    const bulkDeleteListener = messages => {\n      for (const message of messages.values()) this.handleDispose(message);\n    };\n\n    this._handleChannelDeletion = this._handleChannelDeletion.bind(this);\n    this._handleGuildDeletion = this._handleGuildDeletion.bind(this);\n    this.client.incrementMaxListeners();\n    this.client.on(Events.MESSAGE_CREATE, this.handleCollect);\n    this.client.on(Events.MESSAGE_DELETE, this.handleDispose);\n    this.client.on(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);\n    this.client.on(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n    this.client.on(Events.GUILD_DELETE, this._handleGuildDeletion);\n    this.once('end', () => {\n      this.client.removeListener(Events.MESSAGE_CREATE, this.handleCollect);\n      this.client.removeListener(Events.MESSAGE_DELETE, this.handleDispose);\n      this.client.removeListener(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);\n      this.client.removeListener(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n      this.client.removeListener(Events.GUILD_DELETE, this._handleGuildDeletion);\n      this.client.decrementMaxListeners();\n    });\n  }\n  /**\n   * Handles a message for possible collection.\n   * @param {Message} message The message that could be collected\n   * @returns {?Snowflake}\n   * @private\n   */\n\n\n  collect(message) {\n    /**\n     * Emitted whenever a message is collected.\n     * @event MessageCollector#collect\n     * @param {Message} message The message that was collected\n     */\n    if (message.channel.id !== this.channel.id) return null;\n    this.received++;\n    return message.id;\n  }\n  /**\n   * Handles a message for possible disposal.\n   * @param {Message} message The message that could be disposed of\n   * @returns {?Snowflake}\n   */\n\n\n  dispose(message) {\n    /**\n     * Emitted whenever a message is disposed of.\n     * @event MessageCollector#dispose\n     * @param {Message} message The message that was disposed of\n     */\n    return message.channel.id === this.channel.id ? message.id : null;\n  }\n  /**\n   * Checks after un/collection to see if the collector is done.\n   * @returns {?string}\n   * @private\n   */\n\n\n  endReason() {\n    if (this.options.max && this.collected.size >= this.options.max) return 'limit';\n    if (this.options.maxProcessed && this.received === this.options.maxProcessed) return 'processedLimit';\n    return null;\n  }\n  /**\n   * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.\n   * @private\n   * @param {GuildChannel} channel The channel that was deleted\n   * @returns {void}\n   */\n\n\n  _handleChannelDeletion(channel) {\n    if (channel.id === this.channel.id) {\n      this.stop('channelDelete');\n    }\n  }\n  /**\n   * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.\n   * @private\n   * @param {Guild} guild The guild that was deleted\n   * @returns {void}\n   */\n\n\n  _handleGuildDeletion(guild) {\n    if (this.channel.guild && guild.id === this.channel.guild.id) {\n      this.stop('guildDelete');\n    }\n  }\n\n}\n\nmodule.exports = MessageCollector;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/structures/MessageCollector.js"],"names":["Collector","require","Events","MessageCollector","constructor","channel","filter","options","client","received","bulkDeleteListener","messages","message","values","handleDispose","_handleChannelDeletion","bind","_handleGuildDeletion","incrementMaxListeners","on","MESSAGE_CREATE","handleCollect","MESSAGE_DELETE","MESSAGE_BULK_DELETE","CHANNEL_DELETE","GUILD_DELETE","once","removeListener","decrementMaxListeners","collect","id","dispose","endReason","max","collected","size","maxProcessed","stop","guild","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Collector = require('./interfaces/Collector');\nconst { Events } = require('../util/Constants');\n\n/**\n * @typedef {CollectorOptions} MessageCollectorOptions\n * @property {number} max The maximum amount of messages to collect\n * @property {number} maxProcessed The maximum amount of messages to process\n */\n\n/**\n * Collects messages on a channel.\n * Will automatically stop if the channel (`'channelDelete'`) or guild (`'guildDelete'`) are deleted.\n * @extends {Collector}\n */\nclass MessageCollector extends Collector {\n  /**\n   * @param {TextChannel|DMChannel} channel The channel\n   * @param {CollectorFilter} filter The filter to be applied to this collector\n   * @param {MessageCollectorOptions} options The options to be applied to this collector\n   * @emits MessageCollector#message\n   */\n  constructor(channel, filter, options = {}) {\n    super(channel.client, filter, options);\n\n    /**\n     * The channel\n     * @type {TextBasedChannel}\n     */\n    this.channel = channel;\n\n    /**\n     * Total number of messages that were received in the channel during message collection\n     * @type {number}\n     */\n    this.received = 0;\n\n    const bulkDeleteListener = messages => {\n      for (const message of messages.values()) this.handleDispose(message);\n    };\n    this._handleChannelDeletion = this._handleChannelDeletion.bind(this);\n    this._handleGuildDeletion = this._handleGuildDeletion.bind(this);\n\n    this.client.incrementMaxListeners();\n    this.client.on(Events.MESSAGE_CREATE, this.handleCollect);\n    this.client.on(Events.MESSAGE_DELETE, this.handleDispose);\n    this.client.on(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);\n    this.client.on(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n    this.client.on(Events.GUILD_DELETE, this._handleGuildDeletion);\n\n    this.once('end', () => {\n      this.client.removeListener(Events.MESSAGE_CREATE, this.handleCollect);\n      this.client.removeListener(Events.MESSAGE_DELETE, this.handleDispose);\n      this.client.removeListener(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);\n      this.client.removeListener(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n      this.client.removeListener(Events.GUILD_DELETE, this._handleGuildDeletion);\n      this.client.decrementMaxListeners();\n    });\n  }\n\n  /**\n   * Handles a message for possible collection.\n   * @param {Message} message The message that could be collected\n   * @returns {?Snowflake}\n   * @private\n   */\n  collect(message) {\n    /**\n     * Emitted whenever a message is collected.\n     * @event MessageCollector#collect\n     * @param {Message} message The message that was collected\n     */\n    if (message.channel.id !== this.channel.id) return null;\n    this.received++;\n    return message.id;\n  }\n\n  /**\n   * Handles a message for possible disposal.\n   * @param {Message} message The message that could be disposed of\n   * @returns {?Snowflake}\n   */\n  dispose(message) {\n    /**\n     * Emitted whenever a message is disposed of.\n     * @event MessageCollector#dispose\n     * @param {Message} message The message that was disposed of\n     */\n    return message.channel.id === this.channel.id ? message.id : null;\n  }\n\n  /**\n   * Checks after un/collection to see if the collector is done.\n   * @returns {?string}\n   * @private\n   */\n  endReason() {\n    if (this.options.max && this.collected.size >= this.options.max) return 'limit';\n    if (this.options.maxProcessed && this.received === this.options.maxProcessed) return 'processedLimit';\n    return null;\n  }\n\n  /**\n   * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.\n   * @private\n   * @param {GuildChannel} channel The channel that was deleted\n   * @returns {void}\n   */\n  _handleChannelDeletion(channel) {\n    if (channel.id === this.channel.id) {\n      this.stop('channelDelete');\n    }\n  }\n\n  /**\n   * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.\n   * @private\n   * @param {Guild} guild The guild that was deleted\n   * @returns {void}\n   */\n  _handleGuildDeletion(guild) {\n    if (this.channel.guild && guild.id === this.channel.guild.id) {\n      this.stop('guildDelete');\n    }\n  }\n}\n\nmodule.exports = MessageCollector;\n"]},"metadata":{},"sourceType":"script"}