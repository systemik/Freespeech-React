{"ast":null,"code":"'use strict';\n\nconst Channel = require('./Channel');\n\nconst Invite = require('./Invite');\n\nconst PermissionOverwrites = require('./PermissionOverwrites');\n\nconst Role = require('./Role');\n\nconst {\n  Error,\n  TypeError\n} = require('../errors');\n\nconst Collection = require('../util/Collection');\n\nconst Permissions = require('../util/Permissions');\n\nconst Util = require('../util/Util');\n/**\n * Represents a guild channel from any of the following:\n * - {@link TextChannel}\n * - {@link VoiceChannel}\n * - {@link CategoryChannel}\n * - {@link NewsChannel}\n * - {@link StoreChannel}\n * @extends {Channel}\n * @abstract\n */\n\n\nclass GuildChannel extends Channel {\n  /**\n   * @param {Guild} guild The guild the guild channel is part of\n   * @param {Object} data The data for the guild channel\n   */\n  constructor(guild, data) {\n    super(guild.client, data);\n    /**\n     * The guild the channel is in\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n  }\n\n  _patch(data) {\n    super._patch(data);\n    /**\n     * The name of the guild channel\n     * @type {string}\n     */\n\n\n    this.name = data.name;\n    /**\n     * The raw position of the channel from discord\n     * @type {number}\n     */\n\n    this.rawPosition = data.position;\n    /**\n     * The ID of the category parent of this channel\n     * @type {?Snowflake}\n     */\n\n    this.parentID = data.parent_id || null;\n    /**\n     * A map of permission overwrites in this channel for roles and users\n     * @type {Collection<Snowflake, PermissionOverwrites>}\n     */\n\n    this.permissionOverwrites = new Collection();\n\n    if (data.permission_overwrites) {\n      for (const overwrite of data.permission_overwrites) {\n        this.permissionOverwrites.set(overwrite.id, new PermissionOverwrites(this, overwrite));\n      }\n    }\n  }\n  /**\n   * The category parent of this channel\n   * @type {?CategoryChannel}\n   * @readonly\n   */\n\n\n  get parent() {\n    return this.guild.channels.cache.get(this.parentID) || null;\n  }\n  /**\n   * If the permissionOverwrites match the parent channel, null if no parent\n   * @type {?boolean}\n   * @readonly\n   */\n\n\n  get permissionsLocked() {\n    if (!this.parent) return null;\n    if (this.permissionOverwrites.size !== this.parent.permissionOverwrites.size) return false;\n    return this.permissionOverwrites.every((value, key) => {\n      const testVal = this.parent.permissionOverwrites.get(key);\n      return testVal !== undefined && testVal.deny.bitfield === value.deny.bitfield && testVal.allow.bitfield === value.allow.bitfield;\n    });\n  }\n  /**\n   * The position of the channel\n   * @type {number}\n   * @readonly\n   */\n\n\n  get position() {\n    const sorted = this.guild._sortedChannels(this);\n\n    return sorted.array().indexOf(sorted.get(this.id));\n  }\n  /**\n   * Gets the overall set of permissions for a member or role in this channel, taking into account channel overwrites.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @returns {?Readonly<Permissions>}\n   */\n\n\n  permissionsFor(memberOrRole) {\n    const member = this.guild.members.resolve(memberOrRole);\n    if (member) return this.memberPermissions(member);\n    const role = this.guild.roles.resolve(memberOrRole);\n    if (role) return this.rolePermissions(role);\n    return null;\n  }\n\n  overwritesFor(member) {\n    let verified = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let roles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (!verified) member = this.guild.members.resolve(member);\n    if (!member) return [];\n    roles = roles || member.roles.cache;\n    const roleOverwrites = [];\n    let memberOverwrites;\n    let everyoneOverwrites;\n\n    for (const overwrite of this.permissionOverwrites.values()) {\n      if (overwrite.id === this.guild.id) {\n        everyoneOverwrites = overwrite;\n      } else if (roles.has(overwrite.id)) {\n        roleOverwrites.push(overwrite);\n      } else if (overwrite.id === member.id) {\n        memberOverwrites = overwrite;\n      }\n    }\n\n    return {\n      everyone: everyoneOverwrites,\n      roles: roleOverwrites,\n      member: memberOverwrites\n    };\n  }\n  /**\n   * Gets the overall set of permissions for a member in this channel, taking into account channel overwrites.\n   * @param {GuildMember} member The member to obtain the overall permissions for\n   * @returns {Readonly<Permissions>}\n   * @private\n   */\n\n\n  memberPermissions(member) {\n    if (member.id === this.guild.ownerID) return new Permissions(Permissions.ALL).freeze();\n    const roles = member.roles.cache;\n    const permissions = new Permissions(roles.map(role => role.permissions));\n    if (permissions.has(Permissions.FLAGS.ADMINISTRATOR)) return new Permissions(Permissions.ALL).freeze();\n    const overwrites = this.overwritesFor(member, true, roles);\n    return permissions.remove(overwrites.everyone ? overwrites.everyone.deny : 0).add(overwrites.everyone ? overwrites.everyone.allow : 0).remove(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.deny) : 0).add(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.allow) : 0).remove(overwrites.member ? overwrites.member.deny : 0).add(overwrites.member ? overwrites.member.allow : 0).freeze();\n  }\n  /**\n   * Gets the overall set of permissions for a role in this channel, taking into account channel overwrites.\n   * @param {Role} role The role to obtain the overall permissions for\n   * @returns {Readonly<Permissions>}\n   * @private\n   */\n\n\n  rolePermissions(role) {\n    if (role.permissions.has(Permissions.FLAGS.ADMINISTRATOR)) return new Permissions(Permissions.ALL).freeze();\n    const everyoneOverwrites = this.permissionOverwrites.get(this.guild.id);\n    const roleOverwrites = this.permissionOverwrites.get(role.id);\n    return role.permissions.remove(everyoneOverwrites ? everyoneOverwrites.deny : 0).add(everyoneOverwrites ? everyoneOverwrites.allow : 0).remove(roleOverwrites ? roleOverwrites.deny : 0).add(roleOverwrites ? roleOverwrites.allow : 0).freeze();\n  }\n  /**\n   * Replaces the permission overwrites in this channel.\n   * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} overwrites\n   * Permission overwrites the channel gets updated with\n   * @param {string} [reason] Reason for updating the channel overwrites\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * channel.overwritePermissions([\n   *   {\n   *      id: message.author.id,\n   *      deny: ['VIEW_CHANNEL'],\n   *   },\n   * ], 'Needed to change permissions');\n   */\n\n\n  overwritePermissions(overwrites, reason) {\n    if (!Array.isArray(overwrites) && !(overwrites instanceof Collection)) {\n      return Promise.reject(new TypeError('INVALID_TYPE', 'overwrites', 'Array or Collection of Permission Overwrites', true));\n    }\n\n    return this.edit({\n      permissionOverwrites: overwrites,\n      reason\n    }).then(() => this);\n  }\n  /**\n   * Updates Overwrites for a user or role in this channel. (creates if non-existent)\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {string} [reason] Reason for creating/editing this overwrite\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Update or Create permission overwrites for a message author\n   * message.channel.updateOverwrite(message.author, {\n   *   SEND_MESSAGES: false\n   * })\n   *   .then(channel => console.log(channel.permissionOverwrites.get(message.author.id)))\n   *   .catch(console.error);\n   */\n\n\n  updateOverwrite(userOrRole, options, reason) {\n    userOrRole = this.guild.roles.resolve(userOrRole) || this.client.users.resolve(userOrRole);\n    if (!userOrRole) return Promise.reject(new TypeError('INVALID_TYPE', 'parameter', 'User nor a Role'));\n    const existing = this.permissionOverwrites.get(userOrRole.id);\n    if (existing) return existing.update(options, reason).then(() => this);\n    return this.createOverwrite(userOrRole, options, reason);\n  }\n  /**\n   * Overwrites the permissions for a user or role in this channel. (replaces if existent)\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {string} [reason] Reason for creating/editing this overwrite\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Create or Replace permissions overwrites for a message author\n   * message.channel.createOverwrite(message.author, {\n   *   SEND_MESSAGES: false\n   * })\n   *   .then(channel => console.log(channel.permissionOverwrites.get(message.author.id)))\n   *   .catch(console.error);\n   */\n\n\n  createOverwrite(userOrRole, options, reason) {\n    userOrRole = this.guild.roles.resolve(userOrRole) || this.client.users.resolve(userOrRole);\n    if (!userOrRole) return Promise.reject(new TypeError('INVALID_TYPE', 'parameter', 'User nor a Role'));\n    const type = userOrRole instanceof Role ? 'role' : 'member';\n    const {\n      allow,\n      deny\n    } = PermissionOverwrites.resolveOverwriteOptions(options);\n    return this.client.api.channels(this.id).permissions[userOrRole.id].put({\n      data: {\n        id: userOrRole.id,\n        type,\n        allow: allow.bitfield,\n        deny: deny.bitfield\n      },\n      reason\n    }).then(() => this);\n  }\n  /**\n   * Locks in the permission overwrites from the parent channel.\n   * @returns {Promise<GuildChannel>}\n   */\n\n\n  lockPermissions() {\n    if (!this.parent) return Promise.reject(new Error('GUILD_CHANNEL_ORPHAN'));\n    const permissionOverwrites = this.parent.permissionOverwrites.map(overwrite => overwrite.toJSON());\n    return this.edit({\n      permissionOverwrites\n    });\n  }\n  /**\n   * A collection of members that can see this channel, mapped by their ID\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n\n\n  get members() {\n    const members = new Collection();\n\n    for (const member of this.guild.members.cache.values()) {\n      if (this.permissionsFor(member).has('VIEW_CHANNEL', false)) {\n        members.set(member.id, member);\n      }\n    }\n\n    return members;\n  }\n  /**\n   * The data for a guild channel.\n   * @typedef {Object} ChannelData\n   * @property {string} [name] The name of the channel\n   * @property {number} [position] The position of the channel\n   * @property {string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the voice channel\n   * @property {?Snowflake} [parentID] The parent ID of the channel\n   * @property {boolean} [lockPermissions]\n   * Lock the permissions of the channel to what the parent's permissions are\n   * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]\n   * Permission overwrites for the channel\n   * @property {number} [rateLimitPerUser] The ratelimit per user for the channel in seconds\n   */\n\n  /**\n   * Edits the channel.\n   * @param {ChannelData} data The new data for the channel\n   * @param {string} [reason] Reason for editing this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit a channel\n   * channel.edit({ name: 'new-channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async edit(data, reason) {\n    if (typeof data.position !== 'undefined') {\n      await Util.setPosition(this, data.position, false, this.guild._sortedChannels(this), this.client.api.guilds(this.guild.id).channels, reason).then(updatedChannels => {\n        this.client.actions.GuildChannelsPositionUpdate.handle({\n          guild_id: this.guild.id,\n          channels: updatedChannels\n        });\n      });\n    }\n\n    let permission_overwrites;\n\n    if (data.permissionOverwrites) {\n      permission_overwrites = data.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n    }\n\n    if (data.lockPermissions) {\n      if (data.parentID) {\n        const newParent = this.guild.channels.resolve(data.parentID);\n\n        if (newParent && newParent.type === 'category') {\n          permission_overwrites = newParent.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n        }\n      } else if (this.parent) {\n        permission_overwrites = this.parent.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n      }\n    }\n\n    const newData = await this.client.api.channels(this.id).patch({\n      data: {\n        name: (data.name || this.name).trim(),\n        topic: data.topic,\n        nsfw: data.nsfw,\n        bitrate: data.bitrate || this.bitrate,\n        user_limit: typeof data.userLimit !== 'undefined' ? data.userLimit : this.userLimit,\n        parent_id: data.parentID,\n        lock_permissions: data.lockPermissions,\n        rate_limit_per_user: data.rateLimitPerUser,\n        permission_overwrites\n      },\n      reason\n    });\n\n    const clone = this._clone();\n\n    clone._patch(newData);\n\n    return clone;\n  }\n  /**\n   * Sets a new name for the guild channel.\n   * @param {string} name The new name for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's name\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel name\n   * channel.setName('not_general')\n   *   .then(newChannel => console.log(`Channel's new name is ${newChannel.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setName(name, reason) {\n    return this.edit({\n      name\n    }, reason);\n  }\n  /**\n   * Sets the category parent of this channel.\n   * @param {?CategoryChannel|Snowflake} channel Parent channel\n   * @param {Object} [options={}] Options to pass\n   * @param {boolean} [options.lockPermissions=true] Lock the permissions to what the parent's permissions are\n   * @param {string} [options.reason] Reason for modifying the parent of this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Add a parent to a channel\n   * message.channel.setParent('355908108431917066', { lockPermissions: false })\n   *   .then(channel => console.log(`New parent of ${message.channel.name}: ${channel.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setParent(channel) {\n    let {\n      lockPermissions = true,\n      reason\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.edit({\n      // eslint-disable-next-line no-prototype-builtins\n      parentID: channel !== null ? channel.hasOwnProperty('id') ? channel.id : channel : null,\n      lockPermissions\n    }, reason);\n  }\n  /**\n   * Sets a new topic for the guild channel.\n   * @param {?string} topic The new topic for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's topic\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel topic\n   * channel.setTopic('needs more rate limiting')\n   *   .then(newChannel => console.log(`Channel's new topic is ${newChannel.topic}`))\n   *   .catch(console.error);\n   */\n\n\n  setTopic(topic, reason) {\n    return this.edit({\n      topic\n    }, reason);\n  }\n  /**\n   * Sets a new position for the guild channel.\n   * @param {number} position The new position for the guild channel\n   * @param {Object} [options] Options for setting position\n   * @param {boolean} [options.relative=false] Change the position relative to its current value\n   * @param {string} [options.reason] Reason for changing the position\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel position\n   * channel.setPosition(2)\n   *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))\n   *   .catch(console.error);\n   */\n\n\n  setPosition(position) {\n    let {\n      relative,\n      reason\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Util.setPosition(this, position, relative, this.guild._sortedChannels(this), this.client.api.guilds(this.guild.id).channels, reason).then(updatedChannels => {\n      this.client.actions.GuildChannelsPositionUpdate.handle({\n        guild_id: this.guild.id,\n        channels: updatedChannels\n      });\n      return this;\n    });\n  }\n  /**\n   * Creates an invite to this guild channel.\n   * @param {Object} [options={}] Options for the invite\n   * @param {boolean} [options.temporary=false] Whether members that joined via the invite should be automatically\n   * kicked after 24 hours if they have not yet received a role\n   * @param {number} [options.maxAge=86400] How long the invite should last (in seconds, 0 for forever)\n   * @param {number} [options.maxUses=0] Maximum number of uses\n   * @param {boolean} [options.unique=false] Create a unique invite, or use an existing one with similar settings\n   * @param {string} [options.reason] Reason for creating this\n   * @returns {Promise<Invite>}\n   * @example\n   * // Create an invite to a channel\n   * channel.createInvite()\n   *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))\n   *   .catch(console.error);\n   */\n\n\n  createInvite() {\n    let {\n      temporary = false,\n      maxAge = 86400,\n      maxUses = 0,\n      unique,\n      reason\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.client.api.channels(this.id).invites.post({\n      data: {\n        temporary,\n        max_age: maxAge,\n        max_uses: maxUses,\n        unique\n      },\n      reason\n    }).then(invite => new Invite(this.client, invite));\n  }\n  /**\n   * Fetches a collection of invites to this guild channel.\n   * Resolves with a collection mapping invites by their codes.\n   * @returns {Promise<Collection<string, Invite>>}\n   */\n\n\n  async fetchInvites() {\n    const inviteItems = await this.client.api.channels(this.id).invites.get();\n    const invites = new Collection();\n\n    for (const inviteItem of inviteItems) {\n      const invite = new Invite(this.client, inviteItem);\n      invites.set(invite.code, invite);\n    }\n\n    return invites;\n  }\n  /* eslint-disable max-len */\n\n  /**\n   * Clones this channel.\n   * @param {Object} [options] The options\n   * @param {string} [options.name=this.name] Name of the new channel\n   * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [options.permissionOverwrites=this.permissionOverwrites]\n   * Permission overwrites of the new channel\n   * @param {string} [options.type=this.type] Type of the new channel\n   * @param {string} [options.topic=this.topic] Topic of the new channel (only text)\n   * @param {boolean} [options.nsfw=this.nsfw] Whether the new channel is nsfw (only text)\n   * @param {number} [options.bitrate=this.bitrate] Bitrate of the new channel in bits (only voice)\n   * @param {number} [options.userLimit=this.userLimit] Maximum amount of users allowed in the new channel (only voice)\n   * @param {number} [options.rateLimitPerUser=this.rateLimitPerUser] Ratelimit per user for the new channel (only text)\n   * @param {ChannelResolvable} [options.parent=this.parent] Parent of the new channel\n   * @param {string} [options.reason] Reason for cloning this channel\n   * @returns {Promise<GuildChannel>}\n   */\n\n\n  clone() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    Util.mergeDefault({\n      name: this.name,\n      permissionOverwrites: this.permissionOverwrites,\n      topic: this.topic,\n      type: this.type,\n      nsfw: this.nsfw,\n      parent: this.parent,\n      bitrate: this.bitrate,\n      userLimit: this.userLimit,\n      rateLimitPerUser: this.rateLimitPerUser,\n      reason: null\n    }, options);\n    return this.guild.channels.create(options.name, options);\n  }\n  /* eslint-enable max-len */\n\n  /**\n   * Checks if this channel has the same type, topic, position, name, overwrites and ID as another channel.\n   * In most cases, a simple `channel.id === channel2.id` will do, and is much faster too.\n   * @param {GuildChannel} channel Channel to compare with\n   * @returns {boolean}\n   */\n\n\n  equals(channel) {\n    let equal = channel && this.id === channel.id && this.type === channel.type && this.topic === channel.topic && this.position === channel.position && this.name === channel.name;\n\n    if (equal) {\n      if (this.permissionOverwrites && channel.permissionOverwrites) {\n        equal = this.permissionOverwrites.equals(channel.permissionOverwrites);\n      } else {\n        equal = !this.permissionOverwrites && !channel.permissionOverwrites;\n      }\n    }\n\n    return equal;\n  }\n  /**\n   * Whether the channel is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get deletable() {\n    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS, false);\n  }\n  /**\n   * Whether the channel is manageable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get manageable() {\n    if (this.client.user.id === this.guild.ownerID) return true;\n\n    if (this.type === 'voice') {\n      if (!this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false)) {\n        return false;\n      }\n    } else if (!this.viewable) {\n      return false;\n    }\n\n    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS, false);\n  }\n  /**\n   * Whether the channel is viewable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get viewable() {\n    if (this.client.user.id === this.guild.ownerID) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    return permissions.has(Permissions.FLAGS.VIEW_CHANNEL, false);\n  }\n  /**\n   * Deletes this channel.\n   * @param {string} [reason] Reason for deleting this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Delete the channel\n   * channel.delete('making room for new channels')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  delete(reason) {\n    return this.client.api.channels(this.id).delete({\n      reason\n    }).then(() => this);\n  }\n\n}\n\nmodule.exports = GuildChannel;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/structures/GuildChannel.js"],"names":["Channel","require","Invite","PermissionOverwrites","Role","Error","TypeError","Collection","Permissions","Util","GuildChannel","constructor","guild","data","client","_patch","name","rawPosition","position","parentID","parent_id","permissionOverwrites","permission_overwrites","overwrite","set","id","parent","channels","cache","get","permissionsLocked","size","every","value","key","testVal","undefined","deny","bitfield","allow","sorted","_sortedChannels","array","indexOf","permissionsFor","memberOrRole","member","members","resolve","memberPermissions","role","roles","rolePermissions","overwritesFor","verified","roleOverwrites","memberOverwrites","everyoneOverwrites","values","has","push","everyone","ownerID","ALL","freeze","permissions","map","FLAGS","ADMINISTRATOR","overwrites","remove","add","length","overwritePermissions","reason","Array","isArray","Promise","reject","edit","then","updateOverwrite","userOrRole","options","users","existing","update","createOverwrite","type","resolveOverwriteOptions","api","put","lockPermissions","toJSON","setPosition","guilds","updatedChannels","actions","GuildChannelsPositionUpdate","handle","guild_id","o","newParent","newData","patch","trim","topic","nsfw","bitrate","user_limit","userLimit","lock_permissions","rate_limit_per_user","rateLimitPerUser","clone","_clone","setName","setParent","channel","hasOwnProperty","setTopic","relative","createInvite","temporary","maxAge","maxUses","unique","invites","post","max_age","max_uses","invite","fetchInvites","inviteItems","inviteItem","code","mergeDefault","create","equals","equal","deletable","user","MANAGE_CHANNELS","manageable","CONNECT","viewable","VIEW_CHANNEL","delete","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Channel = require('./Channel');\nconst Invite = require('./Invite');\nconst PermissionOverwrites = require('./PermissionOverwrites');\nconst Role = require('./Role');\nconst { Error, TypeError } = require('../errors');\nconst Collection = require('../util/Collection');\nconst Permissions = require('../util/Permissions');\nconst Util = require('../util/Util');\n\n/**\n * Represents a guild channel from any of the following:\n * - {@link TextChannel}\n * - {@link VoiceChannel}\n * - {@link CategoryChannel}\n * - {@link NewsChannel}\n * - {@link StoreChannel}\n * @extends {Channel}\n * @abstract\n */\nclass GuildChannel extends Channel {\n  /**\n   * @param {Guild} guild The guild the guild channel is part of\n   * @param {Object} data The data for the guild channel\n   */\n  constructor(guild, data) {\n    super(guild.client, data);\n\n    /**\n     * The guild the channel is in\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    /**\n     * The name of the guild channel\n     * @type {string}\n     */\n    this.name = data.name;\n\n    /**\n     * The raw position of the channel from discord\n     * @type {number}\n     */\n    this.rawPosition = data.position;\n\n    /**\n     * The ID of the category parent of this channel\n     * @type {?Snowflake}\n     */\n    this.parentID = data.parent_id || null;\n\n    /**\n     * A map of permission overwrites in this channel for roles and users\n     * @type {Collection<Snowflake, PermissionOverwrites>}\n     */\n    this.permissionOverwrites = new Collection();\n    if (data.permission_overwrites) {\n      for (const overwrite of data.permission_overwrites) {\n        this.permissionOverwrites.set(overwrite.id, new PermissionOverwrites(this, overwrite));\n      }\n    }\n  }\n\n  /**\n   * The category parent of this channel\n   * @type {?CategoryChannel}\n   * @readonly\n   */\n  get parent() {\n    return this.guild.channels.cache.get(this.parentID) || null;\n  }\n\n  /**\n   * If the permissionOverwrites match the parent channel, null if no parent\n   * @type {?boolean}\n   * @readonly\n   */\n  get permissionsLocked() {\n    if (!this.parent) return null;\n    if (this.permissionOverwrites.size !== this.parent.permissionOverwrites.size) return false;\n    return this.permissionOverwrites.every((value, key) => {\n      const testVal = this.parent.permissionOverwrites.get(key);\n      return (\n        testVal !== undefined &&\n        testVal.deny.bitfield === value.deny.bitfield &&\n        testVal.allow.bitfield === value.allow.bitfield\n      );\n    });\n  }\n\n  /**\n   * The position of the channel\n   * @type {number}\n   * @readonly\n   */\n  get position() {\n    const sorted = this.guild._sortedChannels(this);\n    return sorted.array().indexOf(sorted.get(this.id));\n  }\n\n  /**\n   * Gets the overall set of permissions for a member or role in this channel, taking into account channel overwrites.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @returns {?Readonly<Permissions>}\n   */\n  permissionsFor(memberOrRole) {\n    const member = this.guild.members.resolve(memberOrRole);\n    if (member) return this.memberPermissions(member);\n    const role = this.guild.roles.resolve(memberOrRole);\n    if (role) return this.rolePermissions(role);\n    return null;\n  }\n\n  overwritesFor(member, verified = false, roles = null) {\n    if (!verified) member = this.guild.members.resolve(member);\n    if (!member) return [];\n\n    roles = roles || member.roles.cache;\n    const roleOverwrites = [];\n    let memberOverwrites;\n    let everyoneOverwrites;\n\n    for (const overwrite of this.permissionOverwrites.values()) {\n      if (overwrite.id === this.guild.id) {\n        everyoneOverwrites = overwrite;\n      } else if (roles.has(overwrite.id)) {\n        roleOverwrites.push(overwrite);\n      } else if (overwrite.id === member.id) {\n        memberOverwrites = overwrite;\n      }\n    }\n\n    return {\n      everyone: everyoneOverwrites,\n      roles: roleOverwrites,\n      member: memberOverwrites,\n    };\n  }\n\n  /**\n   * Gets the overall set of permissions for a member in this channel, taking into account channel overwrites.\n   * @param {GuildMember} member The member to obtain the overall permissions for\n   * @returns {Readonly<Permissions>}\n   * @private\n   */\n  memberPermissions(member) {\n    if (member.id === this.guild.ownerID) return new Permissions(Permissions.ALL).freeze();\n\n    const roles = member.roles.cache;\n    const permissions = new Permissions(roles.map(role => role.permissions));\n\n    if (permissions.has(Permissions.FLAGS.ADMINISTRATOR)) return new Permissions(Permissions.ALL).freeze();\n\n    const overwrites = this.overwritesFor(member, true, roles);\n\n    return permissions\n      .remove(overwrites.everyone ? overwrites.everyone.deny : 0)\n      .add(overwrites.everyone ? overwrites.everyone.allow : 0)\n      .remove(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.deny) : 0)\n      .add(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.allow) : 0)\n      .remove(overwrites.member ? overwrites.member.deny : 0)\n      .add(overwrites.member ? overwrites.member.allow : 0)\n      .freeze();\n  }\n\n  /**\n   * Gets the overall set of permissions for a role in this channel, taking into account channel overwrites.\n   * @param {Role} role The role to obtain the overall permissions for\n   * @returns {Readonly<Permissions>}\n   * @private\n   */\n  rolePermissions(role) {\n    if (role.permissions.has(Permissions.FLAGS.ADMINISTRATOR)) return new Permissions(Permissions.ALL).freeze();\n\n    const everyoneOverwrites = this.permissionOverwrites.get(this.guild.id);\n    const roleOverwrites = this.permissionOverwrites.get(role.id);\n\n    return role.permissions\n      .remove(everyoneOverwrites ? everyoneOverwrites.deny : 0)\n      .add(everyoneOverwrites ? everyoneOverwrites.allow : 0)\n      .remove(roleOverwrites ? roleOverwrites.deny : 0)\n      .add(roleOverwrites ? roleOverwrites.allow : 0)\n      .freeze();\n  }\n\n  /**\n   * Replaces the permission overwrites in this channel.\n   * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} overwrites\n   * Permission overwrites the channel gets updated with\n   * @param {string} [reason] Reason for updating the channel overwrites\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * channel.overwritePermissions([\n   *   {\n   *      id: message.author.id,\n   *      deny: ['VIEW_CHANNEL'],\n   *   },\n   * ], 'Needed to change permissions');\n   */\n  overwritePermissions(overwrites, reason) {\n    if (!Array.isArray(overwrites) && !(overwrites instanceof Collection)) {\n      return Promise.reject(\n        new TypeError('INVALID_TYPE', 'overwrites', 'Array or Collection of Permission Overwrites', true),\n      );\n    }\n    return this.edit({ permissionOverwrites: overwrites, reason }).then(() => this);\n  }\n\n  /**\n   * Updates Overwrites for a user or role in this channel. (creates if non-existent)\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {string} [reason] Reason for creating/editing this overwrite\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Update or Create permission overwrites for a message author\n   * message.channel.updateOverwrite(message.author, {\n   *   SEND_MESSAGES: false\n   * })\n   *   .then(channel => console.log(channel.permissionOverwrites.get(message.author.id)))\n   *   .catch(console.error);\n   */\n  updateOverwrite(userOrRole, options, reason) {\n    userOrRole = this.guild.roles.resolve(userOrRole) || this.client.users.resolve(userOrRole);\n    if (!userOrRole) return Promise.reject(new TypeError('INVALID_TYPE', 'parameter', 'User nor a Role'));\n\n    const existing = this.permissionOverwrites.get(userOrRole.id);\n    if (existing) return existing.update(options, reason).then(() => this);\n    return this.createOverwrite(userOrRole, options, reason);\n  }\n\n  /**\n   * Overwrites the permissions for a user or role in this channel. (replaces if existent)\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {string} [reason] Reason for creating/editing this overwrite\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Create or Replace permissions overwrites for a message author\n   * message.channel.createOverwrite(message.author, {\n   *   SEND_MESSAGES: false\n   * })\n   *   .then(channel => console.log(channel.permissionOverwrites.get(message.author.id)))\n   *   .catch(console.error);\n   */\n  createOverwrite(userOrRole, options, reason) {\n    userOrRole = this.guild.roles.resolve(userOrRole) || this.client.users.resolve(userOrRole);\n    if (!userOrRole) return Promise.reject(new TypeError('INVALID_TYPE', 'parameter', 'User nor a Role'));\n\n    const type = userOrRole instanceof Role ? 'role' : 'member';\n    const { allow, deny } = PermissionOverwrites.resolveOverwriteOptions(options);\n\n    return this.client.api\n      .channels(this.id)\n      .permissions[userOrRole.id].put({\n        data: { id: userOrRole.id, type, allow: allow.bitfield, deny: deny.bitfield },\n        reason,\n      })\n      .then(() => this);\n  }\n\n  /**\n   * Locks in the permission overwrites from the parent channel.\n   * @returns {Promise<GuildChannel>}\n   */\n  lockPermissions() {\n    if (!this.parent) return Promise.reject(new Error('GUILD_CHANNEL_ORPHAN'));\n    const permissionOverwrites = this.parent.permissionOverwrites.map(overwrite => overwrite.toJSON());\n    return this.edit({ permissionOverwrites });\n  }\n\n  /**\n   * A collection of members that can see this channel, mapped by their ID\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    const members = new Collection();\n    for (const member of this.guild.members.cache.values()) {\n      if (this.permissionsFor(member).has('VIEW_CHANNEL', false)) {\n        members.set(member.id, member);\n      }\n    }\n    return members;\n  }\n\n  /**\n   * The data for a guild channel.\n   * @typedef {Object} ChannelData\n   * @property {string} [name] The name of the channel\n   * @property {number} [position] The position of the channel\n   * @property {string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the voice channel\n   * @property {?Snowflake} [parentID] The parent ID of the channel\n   * @property {boolean} [lockPermissions]\n   * Lock the permissions of the channel to what the parent's permissions are\n   * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]\n   * Permission overwrites for the channel\n   * @property {number} [rateLimitPerUser] The ratelimit per user for the channel in seconds\n   */\n\n  /**\n   * Edits the channel.\n   * @param {ChannelData} data The new data for the channel\n   * @param {string} [reason] Reason for editing this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit a channel\n   * channel.edit({ name: 'new-channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async edit(data, reason) {\n    if (typeof data.position !== 'undefined') {\n      await Util.setPosition(\n        this,\n        data.position,\n        false,\n        this.guild._sortedChannels(this),\n        this.client.api.guilds(this.guild.id).channels,\n        reason,\n      ).then(updatedChannels => {\n        this.client.actions.GuildChannelsPositionUpdate.handle({\n          guild_id: this.guild.id,\n          channels: updatedChannels,\n        });\n      });\n    }\n\n    let permission_overwrites;\n\n    if (data.permissionOverwrites) {\n      permission_overwrites = data.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n    }\n\n    if (data.lockPermissions) {\n      if (data.parentID) {\n        const newParent = this.guild.channels.resolve(data.parentID);\n        if (newParent && newParent.type === 'category') {\n          permission_overwrites = newParent.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n        }\n      } else if (this.parent) {\n        permission_overwrites = this.parent.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n      }\n    }\n\n    const newData = await this.client.api.channels(this.id).patch({\n      data: {\n        name: (data.name || this.name).trim(),\n        topic: data.topic,\n        nsfw: data.nsfw,\n        bitrate: data.bitrate || this.bitrate,\n        user_limit: typeof data.userLimit !== 'undefined' ? data.userLimit : this.userLimit,\n        parent_id: data.parentID,\n        lock_permissions: data.lockPermissions,\n        rate_limit_per_user: data.rateLimitPerUser,\n        permission_overwrites,\n      },\n      reason,\n    });\n\n    const clone = this._clone();\n    clone._patch(newData);\n    return clone;\n  }\n\n  /**\n   * Sets a new name for the guild channel.\n   * @param {string} name The new name for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's name\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel name\n   * channel.setName('not_general')\n   *   .then(newChannel => console.log(`Channel's new name is ${newChannel.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({ name }, reason);\n  }\n\n  /**\n   * Sets the category parent of this channel.\n   * @param {?CategoryChannel|Snowflake} channel Parent channel\n   * @param {Object} [options={}] Options to pass\n   * @param {boolean} [options.lockPermissions=true] Lock the permissions to what the parent's permissions are\n   * @param {string} [options.reason] Reason for modifying the parent of this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Add a parent to a channel\n   * message.channel.setParent('355908108431917066', { lockPermissions: false })\n   *   .then(channel => console.log(`New parent of ${message.channel.name}: ${channel.name}`))\n   *   .catch(console.error);\n   */\n  setParent(channel, { lockPermissions = true, reason } = {}) {\n    return this.edit(\n      {\n        // eslint-disable-next-line no-prototype-builtins\n        parentID: channel !== null ? (channel.hasOwnProperty('id') ? channel.id : channel) : null,\n        lockPermissions,\n      },\n      reason,\n    );\n  }\n\n  /**\n   * Sets a new topic for the guild channel.\n   * @param {?string} topic The new topic for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's topic\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel topic\n   * channel.setTopic('needs more rate limiting')\n   *   .then(newChannel => console.log(`Channel's new topic is ${newChannel.topic}`))\n   *   .catch(console.error);\n   */\n  setTopic(topic, reason) {\n    return this.edit({ topic }, reason);\n  }\n\n  /**\n   * Sets a new position for the guild channel.\n   * @param {number} position The new position for the guild channel\n   * @param {Object} [options] Options for setting position\n   * @param {boolean} [options.relative=false] Change the position relative to its current value\n   * @param {string} [options.reason] Reason for changing the position\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel position\n   * channel.setPosition(2)\n   *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))\n   *   .catch(console.error);\n   */\n  setPosition(position, { relative, reason } = {}) {\n    return Util.setPosition(\n      this,\n      position,\n      relative,\n      this.guild._sortedChannels(this),\n      this.client.api.guilds(this.guild.id).channels,\n      reason,\n    ).then(updatedChannels => {\n      this.client.actions.GuildChannelsPositionUpdate.handle({\n        guild_id: this.guild.id,\n        channels: updatedChannels,\n      });\n      return this;\n    });\n  }\n\n  /**\n   * Creates an invite to this guild channel.\n   * @param {Object} [options={}] Options for the invite\n   * @param {boolean} [options.temporary=false] Whether members that joined via the invite should be automatically\n   * kicked after 24 hours if they have not yet received a role\n   * @param {number} [options.maxAge=86400] How long the invite should last (in seconds, 0 for forever)\n   * @param {number} [options.maxUses=0] Maximum number of uses\n   * @param {boolean} [options.unique=false] Create a unique invite, or use an existing one with similar settings\n   * @param {string} [options.reason] Reason for creating this\n   * @returns {Promise<Invite>}\n   * @example\n   * // Create an invite to a channel\n   * channel.createInvite()\n   *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))\n   *   .catch(console.error);\n   */\n  createInvite({ temporary = false, maxAge = 86400, maxUses = 0, unique, reason } = {}) {\n    return this.client.api\n      .channels(this.id)\n      .invites.post({\n        data: {\n          temporary,\n          max_age: maxAge,\n          max_uses: maxUses,\n          unique,\n        },\n        reason,\n      })\n      .then(invite => new Invite(this.client, invite));\n  }\n\n  /**\n   * Fetches a collection of invites to this guild channel.\n   * Resolves with a collection mapping invites by their codes.\n   * @returns {Promise<Collection<string, Invite>>}\n   */\n  async fetchInvites() {\n    const inviteItems = await this.client.api.channels(this.id).invites.get();\n    const invites = new Collection();\n    for (const inviteItem of inviteItems) {\n      const invite = new Invite(this.client, inviteItem);\n      invites.set(invite.code, invite);\n    }\n    return invites;\n  }\n\n  /* eslint-disable max-len */\n  /**\n   * Clones this channel.\n   * @param {Object} [options] The options\n   * @param {string} [options.name=this.name] Name of the new channel\n   * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [options.permissionOverwrites=this.permissionOverwrites]\n   * Permission overwrites of the new channel\n   * @param {string} [options.type=this.type] Type of the new channel\n   * @param {string} [options.topic=this.topic] Topic of the new channel (only text)\n   * @param {boolean} [options.nsfw=this.nsfw] Whether the new channel is nsfw (only text)\n   * @param {number} [options.bitrate=this.bitrate] Bitrate of the new channel in bits (only voice)\n   * @param {number} [options.userLimit=this.userLimit] Maximum amount of users allowed in the new channel (only voice)\n   * @param {number} [options.rateLimitPerUser=this.rateLimitPerUser] Ratelimit per user for the new channel (only text)\n   * @param {ChannelResolvable} [options.parent=this.parent] Parent of the new channel\n   * @param {string} [options.reason] Reason for cloning this channel\n   * @returns {Promise<GuildChannel>}\n   */\n  clone(options = {}) {\n    Util.mergeDefault(\n      {\n        name: this.name,\n        permissionOverwrites: this.permissionOverwrites,\n        topic: this.topic,\n        type: this.type,\n        nsfw: this.nsfw,\n        parent: this.parent,\n        bitrate: this.bitrate,\n        userLimit: this.userLimit,\n        rateLimitPerUser: this.rateLimitPerUser,\n        reason: null,\n      },\n      options,\n    );\n    return this.guild.channels.create(options.name, options);\n  }\n  /* eslint-enable max-len */\n\n  /**\n   * Checks if this channel has the same type, topic, position, name, overwrites and ID as another channel.\n   * In most cases, a simple `channel.id === channel2.id` will do, and is much faster too.\n   * @param {GuildChannel} channel Channel to compare with\n   * @returns {boolean}\n   */\n  equals(channel) {\n    let equal =\n      channel &&\n      this.id === channel.id &&\n      this.type === channel.type &&\n      this.topic === channel.topic &&\n      this.position === channel.position &&\n      this.name === channel.name;\n\n    if (equal) {\n      if (this.permissionOverwrites && channel.permissionOverwrites) {\n        equal = this.permissionOverwrites.equals(channel.permissionOverwrites);\n      } else {\n        equal = !this.permissionOverwrites && !channel.permissionOverwrites;\n      }\n    }\n\n    return equal;\n  }\n\n  /**\n   * Whether the channel is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS, false);\n  }\n\n  /**\n   * Whether the channel is manageable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get manageable() {\n    if (this.client.user.id === this.guild.ownerID) return true;\n    if (this.type === 'voice') {\n      if (!this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false)) {\n        return false;\n      }\n    } else if (!this.viewable) {\n      return false;\n    }\n    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS, false);\n  }\n\n  /**\n   * Whether the channel is viewable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get viewable() {\n    if (this.client.user.id === this.guild.ownerID) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    return permissions.has(Permissions.FLAGS.VIEW_CHANNEL, false);\n  }\n\n  /**\n   * Deletes this channel.\n   * @param {string} [reason] Reason for deleting this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Delete the channel\n   * channel.delete('making room for new channels')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  delete(reason) {\n    return this.client.api\n      .channels(this.id)\n      .delete({ reason })\n      .then(() => this);\n  }\n}\n\nmodule.exports = GuildChannel;\n"]},"metadata":{},"sourceType":"script"}