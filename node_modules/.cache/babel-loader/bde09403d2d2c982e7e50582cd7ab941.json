{"ast":null,"code":"'use strict';\n\nconst Base = require('./Base');\n\nconst Role = require('./Role');\n\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\n\nconst {\n  Error\n} = require('../errors');\n\nconst GuildMemberRoleManager = require('../managers/GuildMemberRoleManager');\n\nconst Permissions = require('../util/Permissions');\n\nlet Structures;\n/**\n * Represents a member of a guild on Discord.\n * @implements {TextBasedChannel}\n * @extends {Base}\n */\n\nclass GuildMember extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the guild member\n   * @param {Guild} guild The guild the member is part of\n   */\n  constructor(client, data, guild) {\n    super(client);\n    /**\n     * The guild that this member is part of\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n    /**\n     * The timestamp the member joined the guild at\n     * @type {?number}\n     */\n\n    this.joinedTimestamp = null;\n    /**\n     * The ID of the last message sent by the member in their guild, if one was sent\n     * @type {?Snowflake}\n     */\n\n    this.lastMessageID = null;\n    /**\n     * The ID of the channel for the last message sent by the member in their guild, if one was sent\n     * @type {?Snowflake}\n     */\n\n    this.lastMessageChannelID = null;\n    /**\n     * The timestamp of when the member used their Nitro boost on the guild, if it was used\n     * @type {?number}\n     */\n\n    this.premiumSinceTimestamp = null;\n    /**\n     * Whether the member has been removed from the guild\n     * @type {boolean}\n     */\n\n    this.deleted = false;\n    /**\n     * The nickname of this member, if they have one\n     * @type {?string}\n     */\n\n    this.nickname = null;\n    this._roles = [];\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    if ('user' in data) {\n      /**\n       * The user that this guild member instance represents\n       * @type {User}\n       */\n      this.user = this.client.users.add(data.user, true);\n    }\n\n    if ('nick' in data) this.nickname = data.nick;\n    if ('joined_at' in data) this.joinedTimestamp = new Date(data.joined_at).getTime();\n    if ('premium_since' in data) this.premiumSinceTimestamp = new Date(data.premium_since).getTime();\n    if ('roles' in data) this._roles = data.roles;\n  }\n\n  _clone() {\n    const clone = super._clone();\n\n    clone._roles = this._roles.slice();\n    return clone;\n  }\n  /**\n   * Whether this GuildMember is a partial\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get partial() {\n    return !this.joinedTimestamp;\n  }\n  /**\n   * A manager for the roles belonging to this member\n   * @type {GuildMemberRoleManager}\n   * @readonly\n   */\n\n\n  get roles() {\n    return new GuildMemberRoleManager(this);\n  }\n  /**\n   * The Message object of the last message sent by the member in their guild, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n\n\n  get lastMessage() {\n    const channel = this.guild.channels.cache.get(this.lastMessageChannelID);\n    return channel && channel.messages.cache.get(this.lastMessageID) || null;\n  }\n  /**\n   * The voice state of this member\n   * @type {VoiceState}\n   * @readonly\n   */\n\n\n  get voice() {\n    if (!Structures) Structures = require('../util/Structures');\n    const VoiceState = Structures.get('VoiceState');\n    return this.guild.voiceStates.cache.get(this.id) || new VoiceState(this.guild, {\n      user_id: this.id\n    });\n  }\n  /**\n   * The time this member joined the guild\n   * @type {?Date}\n   * @readonly\n   */\n\n\n  get joinedAt() {\n    return this.joinedTimestamp ? new Date(this.joinedTimestamp) : null;\n  }\n  /**\n   * The time of when the member used their Nitro boost on the guild, if it was used\n   * @type {?Date}\n   * @readonly\n   */\n\n\n  get premiumSince() {\n    return this.premiumSinceTimestamp ? new Date(this.premiumSinceTimestamp) : null;\n  }\n  /**\n   * The presence of this guild member\n   * @type {Presence}\n   * @readonly\n   */\n\n\n  get presence() {\n    if (!Structures) Structures = require('../util/Structures');\n    const Presence = Structures.get('Presence');\n    return this.guild.presences.cache.get(this.id) || new Presence(this.client, {\n      user: {\n        id: this.id\n      },\n      guild: this.guild\n    });\n  }\n  /**\n   * The displayed color of this member in base 10\n   * @type {number}\n   * @readonly\n   */\n\n\n  get displayColor() {\n    const role = this.roles.color;\n    return role && role.color || 0;\n  }\n  /**\n   * The displayed color of this member in hexadecimal\n   * @type {string}\n   * @readonly\n   */\n\n\n  get displayHexColor() {\n    const role = this.roles.color;\n    return role && role.hexColor || '#000000';\n  }\n  /**\n   * The ID of this member\n   * @type {Snowflake}\n   * @readonly\n   */\n\n\n  get id() {\n    return this.user.id;\n  }\n  /**\n   * The nickname of this member, or their username if they don't have one\n   * @type {?string}\n   * @readonly\n   */\n\n\n  get displayName() {\n    return this.nickname || this.user.username;\n  }\n  /**\n   * The overall set of permissions for this member, taking only roles into account\n   * @type {Readonly<Permissions>}\n   * @readonly\n   */\n\n\n  get permissions() {\n    if (this.user.id === this.guild.ownerID) return new Permissions(Permissions.ALL).freeze();\n    return new Permissions(this.roles.cache.map(role => role.permissions)).freeze();\n  }\n  /**\n   * Whether the client user is above this user in the hierarchy, according to role position and guild ownership.\n   * This is a prerequisite for many moderative actions.\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get manageable() {\n    if (this.user.id === this.guild.ownerID) return false;\n    if (this.user.id === this.client.user.id) return false;\n    if (this.client.user.id === this.guild.ownerID) return true;\n    if (!this.guild.me) throw new Error('GUILD_UNCACHED_ME');\n    return this.guild.me.roles.highest.comparePositionTo(this.roles.highest) > 0;\n  }\n  /**\n   * Whether this member is kickable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get kickable() {\n    return this.manageable && this.guild.me.permissions.has(Permissions.FLAGS.KICK_MEMBERS);\n  }\n  /**\n   * Whether this member is bannable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get bannable() {\n    return this.manageable && this.guild.me.permissions.has(Permissions.FLAGS.BAN_MEMBERS);\n  }\n  /**\n   * Returns `channel.permissionsFor(guildMember)`. Returns permissions for a member in a guild channel,\n   * taking into account roles and permission overwrites.\n   * @param {ChannelResolvable} channel The guild channel to use as context\n   * @returns {Readonly<Permissions>}\n   */\n\n\n  permissionsIn(channel) {\n    channel = this.guild.channels.resolve(channel);\n    if (!channel) throw new Error('GUILD_CHANNEL_RESOLVE');\n    return channel.memberPermissions(this);\n  }\n  /**\n   * Checks if any of this member's roles have a permission.\n   * @param {PermissionResolvable} permission Permission(s) to check for\n   * @param {Object} [options] Options\n   * @param {boolean} [options.checkAdmin=true] Whether to allow the administrator permission to override\n   * @param {boolean} [options.checkOwner=true] Whether to allow being the guild's owner to override\n   * @returns {boolean}\n   */\n\n\n  hasPermission(permission) {\n    let {\n      checkAdmin = true,\n      checkOwner = true\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (checkOwner && this.user.id === this.guild.ownerID) return true;\n    const permissions = new Permissions(this.roles.cache.map(role => role.permissions));\n    return permissions.has(permission, checkAdmin);\n  }\n  /**\n   * The data for editing a guild member.\n   * @typedef {Object} GuildMemberEditData\n   * @property {string} [nick] The nickname to set for the member\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles or role IDs to apply\n   * @property {boolean} [mute] Whether or not the member should be muted\n   * @property {boolean} [deaf] Whether or not the member should be deafened\n   * @property {ChannelResolvable|null} [channel] Channel to move member to (if they are connected to voice), or `null`\n   * if you want to kick them from voice\n   */\n\n  /**\n   * Edits this member.\n   * @param {GuildMemberEditData} data The data to edit the member with\n   * @param {string} [reason] Reason for editing this user\n   * @returns {Promise<GuildMember>}\n   */\n\n\n  async edit(data, reason) {\n    if (data.channel) {\n      data.channel = this.guild.channels.resolve(data.channel);\n\n      if (!data.channel || data.channel.type !== 'voice') {\n        throw new Error('GUILD_VOICE_CHANNEL_RESOLVE');\n      }\n\n      data.channel_id = data.channel.id;\n      data.channel = undefined;\n    } else if (data.channel === null) {\n      data.channel_id = null;\n      data.channel = undefined;\n    }\n\n    if (data.roles) data.roles = data.roles.map(role => role instanceof Role ? role.id : role);\n    let endpoint = this.client.api.guilds(this.guild.id);\n\n    if (this.user.id === this.client.user.id) {\n      const keys = Object.keys(data);\n      if (keys.length === 1 && keys[0] === 'nick') endpoint = endpoint.members('@me').nick;else endpoint = endpoint.members(this.id);\n    } else {\n      endpoint = endpoint.members(this.id);\n    }\n\n    await endpoint.patch({\n      data,\n      reason\n    });\n\n    const clone = this._clone();\n\n    data.user = this.user;\n\n    clone._patch(data);\n\n    return clone;\n  }\n  /**\n   * Sets the nickname for this member.\n   * @param {string} nick The nickname for the guild member\n   * @param {string} [reason] Reason for setting the nickname\n   * @returns {Promise<GuildMember>}\n   */\n\n\n  setNickname(nick, reason) {\n    return this.edit({\n      nick\n    }, reason);\n  }\n  /**\n   * Creates a DM channel between the client and this member.\n   * @returns {Promise<DMChannel>}\n   */\n\n\n  createDM() {\n    return this.user.createDM();\n  }\n  /**\n   * Deletes any DMs with this member.\n   * @returns {Promise<DMChannel>}\n   */\n\n\n  deleteDM() {\n    return this.user.deleteDM();\n  }\n  /**\n   * Kicks this member from the guild.\n   * @param {string} [reason] Reason for kicking user\n   * @returns {Promise<GuildMember>}\n   */\n\n\n  kick(reason) {\n    return this.client.api.guilds(this.guild.id).members(this.user.id).delete({\n      reason\n    }).then(() => this);\n  }\n  /**\n   * Bans this guild member.\n   * @param {Object} [options] Options for the ban\n   * @param {number} [options.days=0] Number of days of messages to delete, must be between 0 and 7\n   * @param {string} [options.reason] Reason for banning\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // ban a guild member\n   * guildMember.ban({ days: 7, reason: 'They deserved it' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  ban(options) {\n    return this.guild.members.ban(this, options);\n  }\n  /**\n   * Fetches this GuildMember.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<GuildMember>}\n   */\n\n\n  fetch() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this.guild.members.fetch({\n      user: this.id,\n      cache: true,\n      force\n    });\n  }\n  /**\n   * When concatenated with a string, this automatically returns the user's mention instead of the GuildMember object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789012345678>!\n   * console.log(`Hello from ${member}!`);\n   */\n\n\n  toString() {\n    return `<@${this.nickname ? '!' : ''}${this.user.id}>`;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      guild: 'guildID',\n      user: 'userID',\n      displayName: true,\n      speaking: false,\n      lastMessage: false,\n      lastMessageID: false,\n      roles: true\n    });\n  } // These are here only for documentation purposes - they are implemented by TextBasedChannel\n\n  /* eslint-disable no-empty-function */\n\n\n  send() {}\n\n}\n\nTextBasedChannel.applyToClass(GuildMember);\nmodule.exports = GuildMember;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/structures/GuildMember.js"],"names":["Base","require","Role","TextBasedChannel","Error","GuildMemberRoleManager","Permissions","Structures","GuildMember","constructor","client","data","guild","joinedTimestamp","lastMessageID","lastMessageChannelID","premiumSinceTimestamp","deleted","nickname","_roles","_patch","user","users","add","nick","Date","joined_at","getTime","premium_since","roles","_clone","clone","slice","partial","lastMessage","channel","channels","cache","get","messages","voice","VoiceState","voiceStates","id","user_id","joinedAt","premiumSince","presence","Presence","presences","displayColor","role","color","displayHexColor","hexColor","displayName","username","permissions","ownerID","ALL","freeze","map","manageable","me","highest","comparePositionTo","kickable","has","FLAGS","KICK_MEMBERS","bannable","BAN_MEMBERS","permissionsIn","resolve","memberPermissions","hasPermission","permission","checkAdmin","checkOwner","edit","reason","type","channel_id","undefined","endpoint","api","guilds","keys","Object","length","members","patch","setNickname","createDM","deleteDM","kick","delete","then","ban","options","fetch","force","toString","toJSON","speaking","send","applyToClass","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Base = require('./Base');\nconst Role = require('./Role');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst { Error } = require('../errors');\nconst GuildMemberRoleManager = require('../managers/GuildMemberRoleManager');\nconst Permissions = require('../util/Permissions');\nlet Structures;\n\n/**\n * Represents a member of a guild on Discord.\n * @implements {TextBasedChannel}\n * @extends {Base}\n */\nclass GuildMember extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the guild member\n   * @param {Guild} guild The guild the member is part of\n   */\n  constructor(client, data, guild) {\n    super(client);\n\n    /**\n     * The guild that this member is part of\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    /**\n     * The timestamp the member joined the guild at\n     * @type {?number}\n     */\n    this.joinedTimestamp = null;\n\n    /**\n     * The ID of the last message sent by the member in their guild, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageID = null;\n\n    /**\n     * The ID of the channel for the last message sent by the member in their guild, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageChannelID = null;\n\n    /**\n     * The timestamp of when the member used their Nitro boost on the guild, if it was used\n     * @type {?number}\n     */\n    this.premiumSinceTimestamp = null;\n\n    /**\n     * Whether the member has been removed from the guild\n     * @type {boolean}\n     */\n    this.deleted = false;\n\n    /**\n     * The nickname of this member, if they have one\n     * @type {?string}\n     */\n    this.nickname = null;\n\n    this._roles = [];\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    if ('user' in data) {\n      /**\n       * The user that this guild member instance represents\n       * @type {User}\n       */\n      this.user = this.client.users.add(data.user, true);\n    }\n\n    if ('nick' in data) this.nickname = data.nick;\n    if ('joined_at' in data) this.joinedTimestamp = new Date(data.joined_at).getTime();\n    if ('premium_since' in data) this.premiumSinceTimestamp = new Date(data.premium_since).getTime();\n    if ('roles' in data) this._roles = data.roles;\n  }\n\n  _clone() {\n    const clone = super._clone();\n    clone._roles = this._roles.slice();\n    return clone;\n  }\n\n  /**\n   * Whether this GuildMember is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return !this.joinedTimestamp;\n  }\n\n  /**\n   * A manager for the roles belonging to this member\n   * @type {GuildMemberRoleManager}\n   * @readonly\n   */\n  get roles() {\n    return new GuildMemberRoleManager(this);\n  }\n\n  /**\n   * The Message object of the last message sent by the member in their guild, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n  get lastMessage() {\n    const channel = this.guild.channels.cache.get(this.lastMessageChannelID);\n    return (channel && channel.messages.cache.get(this.lastMessageID)) || null;\n  }\n\n  /**\n   * The voice state of this member\n   * @type {VoiceState}\n   * @readonly\n   */\n  get voice() {\n    if (!Structures) Structures = require('../util/Structures');\n    const VoiceState = Structures.get('VoiceState');\n    return this.guild.voiceStates.cache.get(this.id) || new VoiceState(this.guild, { user_id: this.id });\n  }\n\n  /**\n   * The time this member joined the guild\n   * @type {?Date}\n   * @readonly\n   */\n  get joinedAt() {\n    return this.joinedTimestamp ? new Date(this.joinedTimestamp) : null;\n  }\n\n  /**\n   * The time of when the member used their Nitro boost on the guild, if it was used\n   * @type {?Date}\n   * @readonly\n   */\n  get premiumSince() {\n    return this.premiumSinceTimestamp ? new Date(this.premiumSinceTimestamp) : null;\n  }\n\n  /**\n   * The presence of this guild member\n   * @type {Presence}\n   * @readonly\n   */\n  get presence() {\n    if (!Structures) Structures = require('../util/Structures');\n    const Presence = Structures.get('Presence');\n    return (\n      this.guild.presences.cache.get(this.id) ||\n      new Presence(this.client, {\n        user: {\n          id: this.id,\n        },\n        guild: this.guild,\n      })\n    );\n  }\n\n  /**\n   * The displayed color of this member in base 10\n   * @type {number}\n   * @readonly\n   */\n  get displayColor() {\n    const role = this.roles.color;\n    return (role && role.color) || 0;\n  }\n\n  /**\n   * The displayed color of this member in hexadecimal\n   * @type {string}\n   * @readonly\n   */\n  get displayHexColor() {\n    const role = this.roles.color;\n    return (role && role.hexColor) || '#000000';\n  }\n\n  /**\n   * The ID of this member\n   * @type {Snowflake}\n   * @readonly\n   */\n  get id() {\n    return this.user.id;\n  }\n\n  /**\n   * The nickname of this member, or their username if they don't have one\n   * @type {?string}\n   * @readonly\n   */\n  get displayName() {\n    return this.nickname || this.user.username;\n  }\n\n  /**\n   * The overall set of permissions for this member, taking only roles into account\n   * @type {Readonly<Permissions>}\n   * @readonly\n   */\n  get permissions() {\n    if (this.user.id === this.guild.ownerID) return new Permissions(Permissions.ALL).freeze();\n    return new Permissions(this.roles.cache.map(role => role.permissions)).freeze();\n  }\n\n  /**\n   * Whether the client user is above this user in the hierarchy, according to role position and guild ownership.\n   * This is a prerequisite for many moderative actions.\n   * @type {boolean}\n   * @readonly\n   */\n  get manageable() {\n    if (this.user.id === this.guild.ownerID) return false;\n    if (this.user.id === this.client.user.id) return false;\n    if (this.client.user.id === this.guild.ownerID) return true;\n    if (!this.guild.me) throw new Error('GUILD_UNCACHED_ME');\n    return this.guild.me.roles.highest.comparePositionTo(this.roles.highest) > 0;\n  }\n\n  /**\n   * Whether this member is kickable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get kickable() {\n    return this.manageable && this.guild.me.permissions.has(Permissions.FLAGS.KICK_MEMBERS);\n  }\n\n  /**\n   * Whether this member is bannable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get bannable() {\n    return this.manageable && this.guild.me.permissions.has(Permissions.FLAGS.BAN_MEMBERS);\n  }\n\n  /**\n   * Returns `channel.permissionsFor(guildMember)`. Returns permissions for a member in a guild channel,\n   * taking into account roles and permission overwrites.\n   * @param {ChannelResolvable} channel The guild channel to use as context\n   * @returns {Readonly<Permissions>}\n   */\n  permissionsIn(channel) {\n    channel = this.guild.channels.resolve(channel);\n    if (!channel) throw new Error('GUILD_CHANNEL_RESOLVE');\n    return channel.memberPermissions(this);\n  }\n\n  /**\n   * Checks if any of this member's roles have a permission.\n   * @param {PermissionResolvable} permission Permission(s) to check for\n   * @param {Object} [options] Options\n   * @param {boolean} [options.checkAdmin=true] Whether to allow the administrator permission to override\n   * @param {boolean} [options.checkOwner=true] Whether to allow being the guild's owner to override\n   * @returns {boolean}\n   */\n  hasPermission(permission, { checkAdmin = true, checkOwner = true } = {}) {\n    if (checkOwner && this.user.id === this.guild.ownerID) return true;\n    const permissions = new Permissions(this.roles.cache.map(role => role.permissions));\n    return permissions.has(permission, checkAdmin);\n  }\n\n  /**\n   * The data for editing a guild member.\n   * @typedef {Object} GuildMemberEditData\n   * @property {string} [nick] The nickname to set for the member\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles or role IDs to apply\n   * @property {boolean} [mute] Whether or not the member should be muted\n   * @property {boolean} [deaf] Whether or not the member should be deafened\n   * @property {ChannelResolvable|null} [channel] Channel to move member to (if they are connected to voice), or `null`\n   * if you want to kick them from voice\n   */\n\n  /**\n   * Edits this member.\n   * @param {GuildMemberEditData} data The data to edit the member with\n   * @param {string} [reason] Reason for editing this user\n   * @returns {Promise<GuildMember>}\n   */\n  async edit(data, reason) {\n    if (data.channel) {\n      data.channel = this.guild.channels.resolve(data.channel);\n      if (!data.channel || data.channel.type !== 'voice') {\n        throw new Error('GUILD_VOICE_CHANNEL_RESOLVE');\n      }\n      data.channel_id = data.channel.id;\n      data.channel = undefined;\n    } else if (data.channel === null) {\n      data.channel_id = null;\n      data.channel = undefined;\n    }\n    if (data.roles) data.roles = data.roles.map(role => (role instanceof Role ? role.id : role));\n    let endpoint = this.client.api.guilds(this.guild.id);\n    if (this.user.id === this.client.user.id) {\n      const keys = Object.keys(data);\n      if (keys.length === 1 && keys[0] === 'nick') endpoint = endpoint.members('@me').nick;\n      else endpoint = endpoint.members(this.id);\n    } else {\n      endpoint = endpoint.members(this.id);\n    }\n    await endpoint.patch({ data, reason });\n\n    const clone = this._clone();\n    data.user = this.user;\n    clone._patch(data);\n    return clone;\n  }\n\n  /**\n   * Sets the nickname for this member.\n   * @param {string} nick The nickname for the guild member\n   * @param {string} [reason] Reason for setting the nickname\n   * @returns {Promise<GuildMember>}\n   */\n  setNickname(nick, reason) {\n    return this.edit({ nick }, reason);\n  }\n\n  /**\n   * Creates a DM channel between the client and this member.\n   * @returns {Promise<DMChannel>}\n   */\n  createDM() {\n    return this.user.createDM();\n  }\n\n  /**\n   * Deletes any DMs with this member.\n   * @returns {Promise<DMChannel>}\n   */\n  deleteDM() {\n    return this.user.deleteDM();\n  }\n\n  /**\n   * Kicks this member from the guild.\n   * @param {string} [reason] Reason for kicking user\n   * @returns {Promise<GuildMember>}\n   */\n  kick(reason) {\n    return this.client.api\n      .guilds(this.guild.id)\n      .members(this.user.id)\n      .delete({ reason })\n      .then(() => this);\n  }\n\n  /**\n   * Bans this guild member.\n   * @param {Object} [options] Options for the ban\n   * @param {number} [options.days=0] Number of days of messages to delete, must be between 0 and 7\n   * @param {string} [options.reason] Reason for banning\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // ban a guild member\n   * guildMember.ban({ days: 7, reason: 'They deserved it' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  ban(options) {\n    return this.guild.members.ban(this, options);\n  }\n\n  /**\n   * Fetches this GuildMember.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<GuildMember>}\n   */\n  fetch(force = false) {\n    return this.guild.members.fetch({ user: this.id, cache: true, force });\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the user's mention instead of the GuildMember object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789012345678>!\n   * console.log(`Hello from ${member}!`);\n   */\n  toString() {\n    return `<@${this.nickname ? '!' : ''}${this.user.id}>`;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      guild: 'guildID',\n      user: 'userID',\n      displayName: true,\n      speaking: false,\n      lastMessage: false,\n      lastMessageID: false,\n      roles: true,\n    });\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  send() {}\n}\n\nTextBasedChannel.applyToClass(GuildMember);\n\nmodule.exports = GuildMember;\n"]},"metadata":{},"sourceType":"script"}