{"ast":null,"code":"'use strict';\n\nconst Base = require('./Base');\n\nconst {\n  Error,\n  TypeError\n} = require('../errors');\n\nconst {\n  browser\n} = require('../util/Constants');\n/**\n * Represents the voice state for a Guild Member.\n */\n\n\nclass VoiceState extends Base {\n  /**\n   * @param {Guild} guild The guild the voice state is part of\n   * @param {Object} data The data for the voice state\n   */\n  constructor(guild, data) {\n    super(guild.client);\n    /**\n     * The guild of this voice state\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n    /**\n     * The ID of the member of this voice state\n     * @type {Snowflake}\n     */\n\n    this.id = data.user_id;\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * Whether this member is deafened server-wide\n     * @type {?boolean}\n     */\n    this.serverDeaf = 'deaf' in data ? data.deaf : null;\n    /**\n     * Whether this member is muted server-wide\n     * @type {?boolean}\n     */\n\n    this.serverMute = 'mute' in data ? data.mute : null;\n    /**\n     * Whether this member is self-deafened\n     * @type {?boolean}\n     */\n\n    this.selfDeaf = 'self_deaf' in data ? data.self_deaf : null;\n    /**\n     * Whether this member is self-muted\n     * @type {?boolean}\n     */\n\n    this.selfMute = 'self_mute' in data ? data.self_mute : null;\n    /**\n     * Whether this member's camera is enabled\n     * @type {?boolean}\n     */\n\n    this.selfVideo = 'self_video' in data ? data.self_video : null;\n    /**\n     * The session ID of this member's connection\n     * @type {?string}\n     */\n\n    this.sessionID = 'session_id' in data ? data.session_id : null;\n    /**\n     * Whether this member is streaming using \"Go Live\"\n     * @type {boolean}\n     */\n\n    this.streaming = data.self_stream || false;\n    /**\n     * The ID of the voice channel that this member is in\n     * @type {?Snowflake}\n     */\n\n    this.channelID = data.channel_id || null;\n    return this;\n  }\n  /**\n   * The member that this voice state belongs to\n   * @type {?GuildMember}\n   * @readonly\n   */\n\n\n  get member() {\n    return this.guild.members.cache.get(this.id) || null;\n  }\n  /**\n   * The channel that the member is connected to\n   * @type {?VoiceChannel}\n   * @readonly\n   */\n\n\n  get channel() {\n    return this.guild.channels.cache.get(this.channelID) || null;\n  }\n  /**\n   * If this is a voice state of the client user, then this will refer to the active VoiceConnection for this guild\n   * @type {?VoiceConnection}\n   * @readonly\n   */\n\n\n  get connection() {\n    if (browser || this.id !== this.client.user.id) return null;\n    return this.client.voice.connections.get(this.guild.id) || null;\n  }\n  /**\n   * Whether this member is either self-deafened or server-deafened\n   * @type {?boolean}\n   * @readonly\n   */\n\n\n  get deaf() {\n    return this.serverDeaf || this.selfDeaf;\n  }\n  /**\n   * Whether this member is either self-muted or server-muted\n   * @type {?boolean}\n   * @readonly\n   */\n\n\n  get mute() {\n    return this.serverMute || this.selfMute;\n  }\n  /**\n   * Whether this member is currently speaking. A boolean if the information is available (aka\n   * the bot is connected to any voice channel in the guild), otherwise this is null\n   * @type {?boolean}\n   * @readonly\n   */\n\n\n  get speaking() {\n    return this.channel && this.channel.connection ? Boolean(this.channel.connection._speaking.get(this.id)) : null;\n  }\n  /**\n   * Mutes/unmutes the member of this voice state.\n   * @param {boolean} mute Whether or not the member should be muted\n   * @param {string} [reason] Reason for muting or unmuting\n   * @returns {Promise<GuildMember>}\n   */\n\n\n  setMute(mute, reason) {\n    return this.member ? this.member.edit({\n      mute\n    }, reason) : Promise.reject(new Error('VOICE_STATE_UNCACHED_MEMBER'));\n  }\n  /**\n   * Deafens/undeafens the member of this voice state.\n   * @param {boolean} deaf Whether or not the member should be deafened\n   * @param {string} [reason] Reason for deafening or undeafening\n   * @returns {Promise<GuildMember>}\n   */\n\n\n  setDeaf(deaf, reason) {\n    return this.member ? this.member.edit({\n      deaf\n    }, reason) : Promise.reject(new Error('VOICE_STATE_UNCACHED_MEMBER'));\n  }\n  /**\n   * Kicks the member from the voice channel.\n   * @param {string} [reason] Reason for kicking member from the channel\n   * @returns {Promise<GuildMember>}\n   */\n\n\n  kick(reason) {\n    return this.setChannel(null, reason);\n  }\n  /**\n   * Moves the member to a different channel, or disconnects them from the one they're in.\n   * @param {ChannelResolvable|null} [channel] Channel to move the member to, or `null` if you want to disconnect them\n   * from voice.\n   * @param {string} [reason] Reason for moving member to another channel or disconnecting\n   * @returns {Promise<GuildMember>}\n   */\n\n\n  setChannel(channel, reason) {\n    return this.member ? this.member.edit({\n      channel\n    }, reason) : Promise.reject(new Error('VOICE_STATE_UNCACHED_MEMBER'));\n  }\n  /**\n   * Self-mutes/unmutes the bot for this voice state.\n   * @param {boolean} mute Whether or not the bot should be self-muted\n   * @returns {Promise<boolean>} true if the voice state was successfully updated, otherwise false\n   */\n\n\n  async setSelfMute(mute) {\n    if (this.id !== this.client.user.id) throw new Error('VOICE_STATE_NOT_OWN');\n    if (typeof mute !== 'boolean') throw new TypeError('VOICE_STATE_INVALID_TYPE', 'mute');\n    if (!this.connection) return false;\n    this.selfMute = mute;\n    await this.connection.sendVoiceStateUpdate();\n    return true;\n  }\n  /**\n   * Self-deafens/undeafens the bot for this voice state.\n   * @param {boolean} deaf Whether or not the bot should be self-deafened\n   * @returns {Promise<boolean>} true if the voice state was successfully updated, otherwise false\n   */\n\n\n  async setSelfDeaf(deaf) {\n    if (this.id !== this.client.user.id) return new Error('VOICE_STATE_NOT_OWN');\n    if (typeof deaf !== 'boolean') return new TypeError('VOICE_STATE_INVALID_TYPE', 'deaf');\n    if (!this.connection) return false;\n    this.selfDeaf = deaf;\n    await this.connection.sendVoiceStateUpdate();\n    return true;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      id: true,\n      serverDeaf: true,\n      serverMute: true,\n      selfDeaf: true,\n      selfMute: true,\n      sessionID: true,\n      channelID: 'channel'\n    });\n  }\n\n}\n\nmodule.exports = VoiceState;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/structures/VoiceState.js"],"names":["Base","require","Error","TypeError","browser","VoiceState","constructor","guild","data","client","id","user_id","_patch","serverDeaf","deaf","serverMute","mute","selfDeaf","self_deaf","selfMute","self_mute","selfVideo","self_video","sessionID","session_id","streaming","self_stream","channelID","channel_id","member","members","cache","get","channel","channels","connection","user","voice","connections","speaking","Boolean","_speaking","setMute","reason","edit","Promise","reject","setDeaf","kick","setChannel","setSelfMute","sendVoiceStateUpdate","setSelfDeaf","toJSON","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Base = require('./Base');\nconst { Error, TypeError } = require('../errors');\nconst { browser } = require('../util/Constants');\n\n/**\n * Represents the voice state for a Guild Member.\n */\nclass VoiceState extends Base {\n  /**\n   * @param {Guild} guild The guild the voice state is part of\n   * @param {Object} data The data for the voice state\n   */\n  constructor(guild, data) {\n    super(guild.client);\n    /**\n     * The guild of this voice state\n     * @type {Guild}\n     */\n    this.guild = guild;\n    /**\n     * The ID of the member of this voice state\n     * @type {Snowflake}\n     */\n    this.id = data.user_id;\n    this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * Whether this member is deafened server-wide\n     * @type {?boolean}\n     */\n    this.serverDeaf = 'deaf' in data ? data.deaf : null;\n    /**\n     * Whether this member is muted server-wide\n     * @type {?boolean}\n     */\n    this.serverMute = 'mute' in data ? data.mute : null;\n    /**\n     * Whether this member is self-deafened\n     * @type {?boolean}\n     */\n    this.selfDeaf = 'self_deaf' in data ? data.self_deaf : null;\n    /**\n     * Whether this member is self-muted\n     * @type {?boolean}\n     */\n    this.selfMute = 'self_mute' in data ? data.self_mute : null;\n    /**\n     * Whether this member's camera is enabled\n     * @type {?boolean}\n     */\n    this.selfVideo = 'self_video' in data ? data.self_video : null;\n    /**\n     * The session ID of this member's connection\n     * @type {?string}\n     */\n    this.sessionID = 'session_id' in data ? data.session_id : null;\n    /**\n     * Whether this member is streaming using \"Go Live\"\n     * @type {boolean}\n     */\n    this.streaming = data.self_stream || false;\n    /**\n     * The ID of the voice channel that this member is in\n     * @type {?Snowflake}\n     */\n    this.channelID = data.channel_id || null;\n    return this;\n  }\n\n  /**\n   * The member that this voice state belongs to\n   * @type {?GuildMember}\n   * @readonly\n   */\n  get member() {\n    return this.guild.members.cache.get(this.id) || null;\n  }\n\n  /**\n   * The channel that the member is connected to\n   * @type {?VoiceChannel}\n   * @readonly\n   */\n  get channel() {\n    return this.guild.channels.cache.get(this.channelID) || null;\n  }\n\n  /**\n   * If this is a voice state of the client user, then this will refer to the active VoiceConnection for this guild\n   * @type {?VoiceConnection}\n   * @readonly\n   */\n  get connection() {\n    if (browser || this.id !== this.client.user.id) return null;\n    return this.client.voice.connections.get(this.guild.id) || null;\n  }\n\n  /**\n   * Whether this member is either self-deafened or server-deafened\n   * @type {?boolean}\n   * @readonly\n   */\n  get deaf() {\n    return this.serverDeaf || this.selfDeaf;\n  }\n\n  /**\n   * Whether this member is either self-muted or server-muted\n   * @type {?boolean}\n   * @readonly\n   */\n  get mute() {\n    return this.serverMute || this.selfMute;\n  }\n\n  /**\n   * Whether this member is currently speaking. A boolean if the information is available (aka\n   * the bot is connected to any voice channel in the guild), otherwise this is null\n   * @type {?boolean}\n   * @readonly\n   */\n  get speaking() {\n    return this.channel && this.channel.connection ? Boolean(this.channel.connection._speaking.get(this.id)) : null;\n  }\n\n  /**\n   * Mutes/unmutes the member of this voice state.\n   * @param {boolean} mute Whether or not the member should be muted\n   * @param {string} [reason] Reason for muting or unmuting\n   * @returns {Promise<GuildMember>}\n   */\n  setMute(mute, reason) {\n    return this.member ? this.member.edit({ mute }, reason) : Promise.reject(new Error('VOICE_STATE_UNCACHED_MEMBER'));\n  }\n\n  /**\n   * Deafens/undeafens the member of this voice state.\n   * @param {boolean} deaf Whether or not the member should be deafened\n   * @param {string} [reason] Reason for deafening or undeafening\n   * @returns {Promise<GuildMember>}\n   */\n  setDeaf(deaf, reason) {\n    return this.member ? this.member.edit({ deaf }, reason) : Promise.reject(new Error('VOICE_STATE_UNCACHED_MEMBER'));\n  }\n\n  /**\n   * Kicks the member from the voice channel.\n   * @param {string} [reason] Reason for kicking member from the channel\n   * @returns {Promise<GuildMember>}\n   */\n  kick(reason) {\n    return this.setChannel(null, reason);\n  }\n\n  /**\n   * Moves the member to a different channel, or disconnects them from the one they're in.\n   * @param {ChannelResolvable|null} [channel] Channel to move the member to, or `null` if you want to disconnect them\n   * from voice.\n   * @param {string} [reason] Reason for moving member to another channel or disconnecting\n   * @returns {Promise<GuildMember>}\n   */\n  setChannel(channel, reason) {\n    return this.member\n      ? this.member.edit({ channel }, reason)\n      : Promise.reject(new Error('VOICE_STATE_UNCACHED_MEMBER'));\n  }\n\n  /**\n   * Self-mutes/unmutes the bot for this voice state.\n   * @param {boolean} mute Whether or not the bot should be self-muted\n   * @returns {Promise<boolean>} true if the voice state was successfully updated, otherwise false\n   */\n  async setSelfMute(mute) {\n    if (this.id !== this.client.user.id) throw new Error('VOICE_STATE_NOT_OWN');\n    if (typeof mute !== 'boolean') throw new TypeError('VOICE_STATE_INVALID_TYPE', 'mute');\n    if (!this.connection) return false;\n    this.selfMute = mute;\n    await this.connection.sendVoiceStateUpdate();\n    return true;\n  }\n\n  /**\n   * Self-deafens/undeafens the bot for this voice state.\n   * @param {boolean} deaf Whether or not the bot should be self-deafened\n   * @returns {Promise<boolean>} true if the voice state was successfully updated, otherwise false\n   */\n  async setSelfDeaf(deaf) {\n    if (this.id !== this.client.user.id) return new Error('VOICE_STATE_NOT_OWN');\n    if (typeof deaf !== 'boolean') return new TypeError('VOICE_STATE_INVALID_TYPE', 'deaf');\n    if (!this.connection) return false;\n    this.selfDeaf = deaf;\n    await this.connection.sendVoiceStateUpdate();\n    return true;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      id: true,\n      serverDeaf: true,\n      serverMute: true,\n      selfDeaf: true,\n      selfMute: true,\n      sessionID: true,\n      channelID: 'channel',\n    });\n  }\n}\n\nmodule.exports = VoiceState;\n"]},"metadata":{},"sourceType":"script"}