{"ast":null,"code":"'use strict';\n\nconst {\n  deprecate\n} = require('util');\n\nconst Base = require('./Base');\n\nconst GuildAuditLogs = require('./GuildAuditLogs');\n\nconst GuildPreview = require('./GuildPreview');\n\nconst GuildTemplate = require('./GuildTemplate');\n\nconst Integration = require('./Integration');\n\nconst Invite = require('./Invite');\n\nconst VoiceRegion = require('./VoiceRegion');\n\nconst Webhook = require('./Webhook');\n\nconst {\n  Error,\n  TypeError\n} = require('../errors');\n\nconst GuildChannelManager = require('../managers/GuildChannelManager');\n\nconst GuildEmojiManager = require('../managers/GuildEmojiManager');\n\nconst GuildMemberManager = require('../managers/GuildMemberManager');\n\nconst PresenceManager = require('../managers/PresenceManager');\n\nconst RoleManager = require('../managers/RoleManager');\n\nconst VoiceStateManager = require('../managers/VoiceStateManager');\n\nconst Collection = require('../util/Collection');\n\nconst {\n  browser,\n  ChannelTypes,\n  DefaultMessageNotifications,\n  PartialTypes,\n  VerificationLevels,\n  ExplicitContentFilterLevels\n} = require('../util/Constants');\n\nconst DataResolver = require('../util/DataResolver');\n\nconst Snowflake = require('../util/Snowflake');\n\nconst SystemChannelFlags = require('../util/SystemChannelFlags');\n\nconst Util = require('../util/Util');\n/**\n * Represents a guild (or a server) on Discord.\n * <info>It's recommended to see if a guild is available before performing operations or reading data from it. You can\n * check this with `guild.available`.</info>\n * @extends {Base}\n */\n\n\nclass Guild extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the guild\n   */\n  constructor(client, data) {\n    super(client);\n    /**\n     * A manager of the members belonging to this guild\n     * @type {GuildMemberManager}\n     */\n\n    this.members = new GuildMemberManager(this);\n    /**\n     * A manager of the channels belonging to this guild\n     * @type {GuildChannelManager}\n     */\n\n    this.channels = new GuildChannelManager(this);\n    /**\n     * A manager of the roles belonging to this guild\n     * @type {RoleManager}\n     */\n\n    this.roles = new RoleManager(this);\n    /**\n     * A manager of the presences belonging to this guild\n     * @type {PresenceManager}\n     */\n\n    this.presences = new PresenceManager(this.client);\n    /**\n     * A manager of the voice states of this guild\n     * @type {VoiceStateManager}\n     */\n\n    this.voiceStates = new VoiceStateManager(this);\n    /**\n     * Whether the bot has been removed from the guild\n     * @type {boolean}\n     */\n\n    this.deleted = false;\n    if (!data) return;\n\n    if (data.unavailable) {\n      /**\n       * Whether the guild is available to access. If it is not available, it indicates a server outage\n       * @type {boolean}\n       */\n      this.available = false;\n      /**\n       * The Unique ID of the guild, useful for comparisons\n       * @type {Snowflake}\n       */\n\n      this.id = data.id;\n    } else {\n      this._patch(data);\n\n      if (!data.channels) this.available = false;\n    }\n    /**\n     * The id of the shard this Guild belongs to.\n     * @type {number}\n     */\n\n\n    this.shardID = data.shardID;\n  }\n  /**\n   * The Shard this Guild belongs to.\n   * @type {WebSocketShard}\n   * @readonly\n   */\n\n\n  get shard() {\n    return this.client.ws.shards.get(this.shardID);\n  }\n  /**\n   * Sets up the guild.\n   * @param {*} data The raw data of the guild\n   * @private\n   */\n\n\n  _patch(data) {\n    /**\n     * The name of the guild\n     * @type {string}\n     */\n    this.name = data.name;\n    /**\n     * The hash of the guild icon\n     * @type {?string}\n     */\n\n    this.icon = data.icon;\n    /**\n     * The hash of the guild invite splash image\n     * @type {?string}\n     */\n\n    this.splash = data.splash;\n    /**\n     * The hash of the guild discovery splash image\n     * @type {?string}\n     */\n\n    this.discoverySplash = data.discovery_splash;\n    /**\n     * The region the guild is located in\n     * @type {string}\n     */\n\n    this.region = data.region;\n    /**\n     * The full amount of members in this guild\n     * @type {number}\n     */\n\n    this.memberCount = data.member_count || this.memberCount;\n    /**\n     * Whether the guild is \"large\" (has more than large_threshold members, 50 by default)\n     * @type {boolean}\n     */\n\n    this.large = Boolean('large' in data ? data.large : this.large);\n    /**\n     * An array of enabled guild features, here are the possible values:\n     * * ANIMATED_ICON\n     * * BANNER\n     * * COMMERCE\n     * * COMMUNITY\n     * * DISCOVERABLE\n     * * FEATURABLE\n     * * INVITE_SPLASH\n     * * NEWS\n     * * PARTNERED\n     * * RELAY_ENABLED\n     * * VANITY_URL\n     * * VERIFIED\n     * * VIP_REGIONS\n     * * WELCOME_SCREEN_ENABLED\n     * @typedef {string} Features\n     */\n\n    /**\n     * An array of guild features partnered guilds have enabled\n     * @type {Features[]}\n     */\n\n    this.features = data.features;\n    /**\n     * The ID of the application that created this guild (if applicable)\n     * @type {?Snowflake}\n     */\n\n    this.applicationID = data.application_id;\n    /**\n     * The time in seconds before a user is counted as \"away from keyboard\"\n     * @type {?number}\n     */\n\n    this.afkTimeout = data.afk_timeout;\n    /**\n     * The ID of the voice channel where AFK members are moved\n     * @type {?Snowflake}\n     */\n\n    this.afkChannelID = data.afk_channel_id;\n    /**\n     * The ID of the system channel\n     * @type {?Snowflake}\n     */\n\n    this.systemChannelID = data.system_channel_id;\n    /**\n     * Whether embedded images are enabled on this guild\n     * @type {boolean}\n     * @deprecated\n     */\n\n    this.embedEnabled = data.embed_enabled;\n    /**\n     * The type of premium tier:\n     * * 0: NONE\n     * * 1: TIER_1\n     * * 2: TIER_2\n     * * 3: TIER_3\n     * @typedef {number} PremiumTier\n     */\n\n    /**\n     * The premium tier on this guild\n     * @type {PremiumTier}\n     */\n\n    this.premiumTier = data.premium_tier;\n\n    if (typeof data.premium_subscription_count !== 'undefined') {\n      /**\n       * The total number of boosts for this server\n       * @type {?number}\n       */\n      this.premiumSubscriptionCount = data.premium_subscription_count;\n    }\n\n    if (typeof data.widget_enabled !== 'undefined') {\n      /**\n       * Whether widget images are enabled on this guild\n       * @type {?boolean}\n       */\n      this.widgetEnabled = data.widget_enabled;\n    }\n\n    if (typeof data.widget_channel_id !== 'undefined') {\n      /**\n       * The widget channel ID, if enabled\n       * @type {?string}\n       */\n      this.widgetChannelID = data.widget_channel_id;\n    }\n\n    if (typeof data.embed_channel_id !== 'undefined') {\n      /**\n       * The embed channel ID, if enabled\n       * @type {?string}\n       * @deprecated\n       */\n      this.embedChannelID = data.embed_channel_id;\n    }\n    /**\n     * The verification level of the guild\n     * @type {VerificationLevel}\n     */\n\n\n    this.verificationLevel = VerificationLevels[data.verification_level];\n    /**\n     * The explicit content filter level of the guild\n     * @type {ExplicitContentFilterLevel}\n     */\n\n    this.explicitContentFilter = ExplicitContentFilterLevels[data.explicit_content_filter];\n    /**\n     * The required MFA level for the guild\n     * @type {number}\n     */\n\n    this.mfaLevel = data.mfa_level;\n    /**\n     * The timestamp the client user joined the guild at\n     * @type {number}\n     */\n\n    this.joinedTimestamp = data.joined_at ? new Date(data.joined_at).getTime() : this.joinedTimestamp;\n    /**\n     * The value set for the guild's default message notifications\n     * @type {DefaultMessageNotifications|number}\n     */\n\n    this.defaultMessageNotifications = DefaultMessageNotifications[data.default_message_notifications] || data.default_message_notifications;\n    /**\n     * The value set for the guild's system channel flags\n     * @type {Readonly<SystemChannelFlags>}\n     */\n\n    this.systemChannelFlags = new SystemChannelFlags(data.system_channel_flags).freeze();\n\n    if (typeof data.max_members !== 'undefined') {\n      /**\n       * The maximum amount of members the guild can have\n       * @type {?number}\n       */\n      this.maximumMembers = data.max_members;\n    } else if (typeof this.maximumMembers === 'undefined') {\n      this.maximumMembers = null;\n    }\n\n    if (typeof data.max_presences !== 'undefined') {\n      /**\n       * The maximum amount of presences the guild can have\n       * <info>You will need to fetch the guild using {@link Guild#fetch} if you want to receive this parameter</info>\n       * @type {?number}\n       */\n      this.maximumPresences = data.max_presences || 25000;\n    } else if (typeof this.maximumPresences === 'undefined') {\n      this.maximumPresences = null;\n    }\n\n    if (typeof data.approximate_member_count !== 'undefined') {\n      /**\n       * The approximate amount of members the guild has\n       * <info>You will need to fetch the guild using {@link Guild#fetch} if you want to receive this parameter</info>\n       * @type {?number}\n       */\n      this.approximateMemberCount = data.approximate_member_count;\n    } else if (typeof this.approximateMemberCount === 'undefined') {\n      this.approximateMemberCount = null;\n    }\n\n    if (typeof data.approximate_presence_count !== 'undefined') {\n      /**\n       * The approximate amount of presences the guild has\n       * <info>You will need to fetch the guild using {@link Guild#fetch} if you want to receive this parameter</info>\n       * @type {?number}\n       */\n      this.approximatePresenceCount = data.approximate_presence_count;\n    } else if (typeof this.approximatePresenceCount === 'undefined') {\n      this.approximatePresenceCount = null;\n    }\n    /**\n     * The vanity invite code of the guild, if any\n     * @type {?string}\n     */\n\n\n    this.vanityURLCode = data.vanity_url_code;\n    /* eslint-disable max-len */\n\n    /**\n     * The use count of the vanity URL code of the guild, if any\n     * <info>You will need to fetch this parameter using {@link Guild#fetchVanityData} if you want to receive it</info>\n     * @type {?number}\n     */\n\n    this.vanityURLUses = null;\n    /* eslint-enable max-len */\n\n    /**\n     * The description of the guild, if any\n     * @type {?string}\n     */\n\n    this.description = data.description;\n    /**\n     * The hash of the guild banner\n     * @type {?string}\n     */\n\n    this.banner = data.banner;\n    this.id = data.id;\n    this.available = !data.unavailable;\n    this.features = data.features || this.features || [];\n    /**\n     * The ID of the rules channel for the guild\n     * @type {?Snowflake}\n     */\n\n    this.rulesChannelID = data.rules_channel_id;\n    /**\n     * The ID of the community updates channel for the guild\n     * @type {?Snowflake}\n     */\n\n    this.publicUpdatesChannelID = data.public_updates_channel_id;\n    /**\n     * The preferred locale of the guild, defaults to `en-US`\n     * @type {string}\n     */\n\n    this.preferredLocale = data.preferred_locale;\n\n    if (data.channels) {\n      this.channels.cache.clear();\n\n      for (const rawChannel of data.channels) {\n        this.client.channels.add(rawChannel, this);\n      }\n    }\n\n    if (data.roles) {\n      this.roles.cache.clear();\n\n      for (const role of data.roles) this.roles.add(role);\n    }\n\n    if (data.members) {\n      this.members.cache.clear();\n\n      for (const guildUser of data.members) this.members.add(guildUser);\n    }\n\n    if (data.owner_id) {\n      /**\n       * The user ID of this guild's owner\n       * @type {Snowflake}\n       */\n      this.ownerID = data.owner_id;\n    }\n\n    if (data.presences) {\n      for (const presence of data.presences) {\n        this.presences.add(Object.assign(presence, {\n          guild: this\n        }));\n      }\n    }\n\n    if (data.voice_states) {\n      this.voiceStates.cache.clear();\n\n      for (const voiceState of data.voice_states) {\n        this.voiceStates.add(voiceState);\n      }\n    }\n\n    if (!this.emojis) {\n      /**\n       * A manager of the emojis belonging to this guild\n       * @type {GuildEmojiManager}\n       */\n      this.emojis = new GuildEmojiManager(this);\n      if (data.emojis) for (const emoji of data.emojis) this.emojis.add(emoji);\n    } else if (data.emojis) {\n      this.client.actions.GuildEmojisUpdate.handle({\n        guild_id: this.id,\n        emojis: data.emojis\n      });\n    }\n  }\n  /**\n   * The URL to this guild's banner.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n\n\n  bannerURL() {\n    let {\n      format,\n      size\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.banner) return null;\n    return this.client.rest.cdn.Banner(this.id, this.banner, format, size);\n  }\n  /**\n   * The timestamp the guild was created at\n   * @type {number}\n   * @readonly\n   */\n\n\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n  /**\n   * The time the guild was created at\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * The time the client user joined the guild\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get joinedAt() {\n    return new Date(this.joinedTimestamp);\n  }\n  /**\n   * If this guild is partnered\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get partnered() {\n    return this.features.includes('PARTNERED');\n  }\n  /**\n   * If this guild is verified\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get verified() {\n    return this.features.includes('VERIFIED');\n  }\n  /**\n   * The URL to this guild's icon.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n\n\n  iconURL() {\n    let {\n      format,\n      size,\n      dynamic\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.icon) return null;\n    return this.client.rest.cdn.Icon(this.id, this.icon, format, size, dynamic);\n  }\n  /**\n   * The acronym that shows up in place of a guild icon.\n   * @type {string}\n   * @readonly\n   */\n\n\n  get nameAcronym() {\n    return this.name.replace(/'s /g, ' ').replace(/\\w+/g, e => e[0]).replace(/\\s/g, '');\n  }\n  /**\n   * The URL to this guild's invite splash image.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n\n\n  splashURL() {\n    let {\n      format,\n      size\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.splash) return null;\n    return this.client.rest.cdn.Splash(this.id, this.splash, format, size);\n  }\n  /**\n   * The URL to this guild's discovery splash image.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n\n\n  discoverySplashURL() {\n    let {\n      format,\n      size\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.discoverySplash) return null;\n    return this.client.rest.cdn.DiscoverySplash(this.id, this.discoverySplash, format, size);\n  }\n  /**\n   * The owner of the guild\n   * @type {?GuildMember}\n   * @readonly\n   */\n\n\n  get owner() {\n    return this.members.cache.get(this.ownerID) || (this.client.options.partials.includes(PartialTypes.GUILD_MEMBER) ? this.members.add({\n      user: {\n        id: this.ownerID\n      }\n    }, true) : null);\n  }\n  /**\n   * AFK voice channel for this guild\n   * @type {?VoiceChannel}\n   * @readonly\n   */\n\n\n  get afkChannel() {\n    return this.client.channels.cache.get(this.afkChannelID) || null;\n  }\n  /**\n   * System channel for this guild\n   * @type {?TextChannel}\n   * @readonly\n   */\n\n\n  get systemChannel() {\n    return this.client.channels.cache.get(this.systemChannelID) || null;\n  }\n  /**\n   * Widget channel for this guild\n   * @type {?TextChannel}\n   * @readonly\n   */\n\n\n  get widgetChannel() {\n    return this.client.channels.cache.get(this.widgetChannelID) || null;\n  }\n  /**\n   * Embed channel for this guild\n   * @type {?TextChannel}\n   * @readonly\n   * @deprecated\n   */\n\n\n  get embedChannel() {\n    return this.client.channels.cache.get(this.embedChannelID) || null;\n  }\n  /**\n   * Rules channel for this guild\n   * @type {?TextChannel}\n   * @readonly\n   */\n\n\n  get rulesChannel() {\n    return this.client.channels.cache.get(this.rulesChannelID) || null;\n  }\n  /**\n   * Public updates channel for this guild\n   * @type {?TextChannel}\n   * @readonly\n   */\n\n\n  get publicUpdatesChannel() {\n    return this.client.channels.cache.get(this.publicUpdatesChannelID) || null;\n  }\n  /**\n   * The client user as a GuildMember of this guild\n   * @type {?GuildMember}\n   * @readonly\n   */\n\n\n  get me() {\n    return this.members.cache.get(this.client.user.id) || (this.client.options.partials.includes(PartialTypes.GUILD_MEMBER) ? this.members.add({\n      user: {\n        id: this.client.user.id\n      }\n    }, true) : null);\n  }\n  /**\n   * The voice state for the client user of this guild, if any\n   * @type {?VoiceState}\n   * @readonly\n   */\n\n\n  get voice() {\n    return this.voiceStates.cache.get(this.client.user.id);\n  }\n  /**\n   * Returns the GuildMember form of a User object, if the user is present in the guild.\n   * @param {UserResolvable} user The user that you want to obtain the GuildMember of\n   * @returns {?GuildMember}\n   * @example\n   * // Get the guild member of a user\n   * const member = guild.member(message.author);\n   */\n\n\n  member(user) {\n    return this.members.resolve(user);\n  }\n  /**\n   * Fetches this guild.\n   * @returns {Promise<Guild>}\n   */\n\n\n  fetch() {\n    return this.client.api.guilds(this.id).get({\n      query: {\n        with_counts: true\n      }\n    }).then(data => {\n      this._patch(data);\n\n      return this;\n    });\n  }\n  /**\n   * An object containing information about a guild member's ban.\n   * @typedef {Object} BanInfo\n   * @property {User} user User that was banned\n   * @property {?string} reason Reason the user was banned\n   */\n\n  /**\n   * Fetches information on a banned user from this guild.\n   * @param {UserResolvable} user The User to fetch the ban info of\n   * @returns {Promise<BanInfo>}\n   */\n\n\n  fetchBan(user) {\n    const id = this.client.users.resolveID(user);\n    if (!id) throw new Error('FETCH_BAN_RESOLVE_ID');\n    return this.client.api.guilds(this.id).bans(id).get().then(ban => ({\n      reason: ban.reason,\n      user: this.client.users.add(ban.user)\n    }));\n  }\n  /**\n   * Fetches a collection of banned users in this guild.\n   * @returns {Promise<Collection<Snowflake, BanInfo>>}\n   */\n\n\n  fetchBans() {\n    return this.client.api.guilds(this.id).bans.get().then(bans => bans.reduce((collection, ban) => {\n      collection.set(ban.user.id, {\n        reason: ban.reason,\n        user: this.client.users.add(ban.user)\n      });\n      return collection;\n    }, new Collection()));\n  }\n  /**\n   * Fetches a collection of integrations to this guild.\n   * Resolves with a collection mapping integrations by their ids.\n   * @param {Object} [options] Options for fetching integrations\n   * @param {boolean} [options.includeApplications] Whether to include bot and Oauth2 webhook integrations\n   * @returns {Promise<Collection<string, Integration>>}\n   * @example\n   * // Fetch integrations\n   * guild.fetchIntegrations()\n   *   .then(integrations => console.log(`Fetched ${integrations.size} integrations`))\n   *   .catch(console.error);\n   */\n\n\n  fetchIntegrations() {\n    let {\n      includeApplications = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.client.api.guilds(this.id).integrations.get({\n      query: {\n        include_applications: includeApplications\n      }\n    }).then(data => data.reduce((collection, integration) => collection.set(integration.id, new Integration(this.client, integration, this)), new Collection()));\n  }\n  /**\n   * Fetches a collection of templates from this guild.\n   * Resolves with a collection mapping templates by their codes.\n   * @returns {Promise<Collection<string, GuildTemplate>>}\n   */\n\n\n  fetchTemplates() {\n    return this.client.api.guilds(this.id).templates.get().then(templates => templates.reduce((col, data) => col.set(data.code, new GuildTemplate(this.client, data)), new Collection()));\n  }\n  /**\n   * The data for creating an integration.\n   * @typedef {Object} IntegrationData\n   * @property {string} id The integration id\n   * @property {string} type The integration type\n   */\n\n  /**\n   * Creates an integration by attaching an integration object\n   * @param {IntegrationData} data The data for the integration\n   * @param {string} reason Reason for creating the integration\n   * @returns {Promise<Guild>}\n   */\n\n\n  createIntegration(data, reason) {\n    return this.client.api.guilds(this.id).integrations.post({\n      data,\n      reason\n    }).then(() => this);\n  }\n  /**\n   * Creates a template for the guild.\n   * @param {string} name The name for the template\n   * @param {string} [description] The description for the template\n   * @returns {Promise<GuildTemplate>}\n   */\n\n\n  createTemplate(name, description) {\n    return this.client.api.guilds(this.id).templates.post({\n      data: {\n        name,\n        description\n      }\n    }).then(data => new GuildTemplate(this.client, data));\n  }\n  /**\n   * Fetches a collection of invites to this guild.\n   * Resolves with a collection mapping invites by their codes.\n   * @returns {Promise<Collection<string, Invite>>}\n   * @example\n   * // Fetch invites\n   * guild.fetchInvites()\n   *   .then(invites => console.log(`Fetched ${invites.size} invites`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch invite creator by their id\n   * guild.fetchInvites()\n   *  .then(invites => console.log(invites.find(invite => invite.inviter.id === '84484653687267328')))\n   *  .catch(console.error);\n   */\n\n\n  fetchInvites() {\n    return this.client.api.guilds(this.id).invites.get().then(inviteItems => {\n      const invites = new Collection();\n\n      for (const inviteItem of inviteItems) {\n        const invite = new Invite(this.client, inviteItem);\n        invites.set(invite.code, invite);\n      }\n\n      return invites;\n    });\n  }\n  /**\n   * Obtains a guild preview for this guild from Discord.\n   * @returns {Promise<GuildPreview>}\n   */\n\n\n  fetchPreview() {\n    return this.client.api.guilds(this.id).preview.get().then(data => new GuildPreview(this.client, data));\n  }\n  /**\n   * Fetches the vanity url invite code to this guild.\n   * Resolves with a string matching the vanity url invite code, not the full url.\n   * @returns {Promise<string>}\n   * @deprecated\n   * @example\n   * // Fetch invites\n   * guild.fetchVanityCode()\n   *   .then(code => {\n   *     console.log(`Vanity URL: https://discord.gg/${code}`);\n   *   })\n   *   .catch(console.error);\n   */\n\n\n  fetchVanityCode() {\n    return this.fetchVanityData().then(vanity => vanity.code);\n  }\n  /**\n   * An object containing information about a guild's vanity invite.\n   * @typedef {Object} Vanity\n   * @property {?string} code Vanity invite code\n   * @property {?number} uses How many times this invite has been used\n   */\n\n  /**\n   * Fetches the vanity url invite object to this guild.\n   * Resolves with an object containing the vanity url invite code and the use count\n   * @returns {Promise<Vanity>}\n   * @example\n   * // Fetch invite data\n   * guild.fetchVanityData()\n   *   .then(res => {\n   *     console.log(`Vanity URL: https://discord.gg/${res.code} with ${res.uses} uses`);\n   *   })\n   *   .catch(console.error);\n   */\n\n\n  async fetchVanityData() {\n    if (!this.features.includes('VANITY_URL')) {\n      throw new Error('VANITY_URL');\n    }\n\n    const data = await this.client.api.guilds(this.id, 'vanity-url').get();\n    this.vanityURLUses = data.uses;\n    return data;\n  }\n  /**\n   * Fetches all webhooks for the guild.\n   * @returns {Promise<Collection<Snowflake, Webhook>>}\n   * @example\n   * // Fetch webhooks\n   * guild.fetchWebhooks()\n   *   .then(webhooks => console.log(`Fetched ${webhooks.size} webhooks`))\n   *   .catch(console.error);\n   */\n\n\n  fetchWebhooks() {\n    return this.client.api.guilds(this.id).webhooks.get().then(data => {\n      const hooks = new Collection();\n\n      for (const hook of data) hooks.set(hook.id, new Webhook(this.client, hook));\n\n      return hooks;\n    });\n  }\n  /**\n   * Fetches available voice regions.\n   * @returns {Promise<Collection<string, VoiceRegion>>}\n   */\n\n\n  fetchVoiceRegions() {\n    return this.client.api.guilds(this.id).regions.get().then(res => {\n      const regions = new Collection();\n\n      for (const region of res) regions.set(region.id, new VoiceRegion(region));\n\n      return regions;\n    });\n  }\n  /**\n   * Data for the Guild Widget object\n   * @typedef {Object} GuildWidget\n   * @property {boolean} enabled Whether the widget is enabled\n   * @property {?GuildChannel} channel The widget channel\n   */\n\n  /**\n   * The Guild Widget object\n   * @typedef {Object} GuildWidgetData\n   * @property {boolean} enabled Whether the widget is enabled\n   * @property {?GuildChannelResolvable} channel The widget channel\n   */\n\n  /**\n   * Fetches the guild embed.\n   * @returns {Promise<GuildWidget>}\n   * @deprecated\n   * @example\n   * // Fetches the guild embed\n   * guild.fetchEmbed()\n   *   .then(embed => console.log(`The embed is ${embed.enabled ? 'enabled' : 'disabled'}`))\n   *   .catch(console.error);\n   */\n\n\n  fetchEmbed() {\n    return this.fetchWidget();\n  }\n  /**\n   * Fetches the guild widget.\n   * @returns {Promise<GuildWidget>}\n   * @example\n   * // Fetches the guild widget\n   * guild.fetchWidget()\n   *   .then(widget => console.log(`The widget is ${widget.enabled ? 'enabled' : 'disabled'}`))\n   *   .catch(console.error);\n   */\n\n\n  async fetchWidget() {\n    const data = await this.client.api.guilds(this.id).widget.get();\n    this.widgetEnabled = this.embedEnabled = data.enabled;\n    this.widgetChannelID = this.embedChannelID = data.channel_id;\n    return {\n      enabled: data.enabled,\n      channel: data.channel_id ? this.channels.cache.get(data.channel_id) : null\n    };\n  }\n  /**\n   * Fetches audit logs for this guild.\n   * @param {Object} [options={}] Options for fetching audit logs\n   * @param {Snowflake|GuildAuditLogsEntry} [options.before] Limit to entries from before specified entry\n   * @param {number} [options.limit] Limit number of entries\n   * @param {UserResolvable} [options.user] Only show entries involving this user\n   * @param {AuditLogAction|number} [options.type] Only show entries involving this action type\n   * @returns {Promise<GuildAuditLogs>}\n   * @example\n   * // Output audit log entries\n   * guild.fetchAuditLogs()\n   *   .then(audit => console.log(audit.entries.first()))\n   *   .catch(console.error);\n   */\n\n\n  fetchAuditLogs() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (options.before && options.before instanceof GuildAuditLogs.Entry) options.before = options.before.id;\n    if (typeof options.type === 'string') options.type = GuildAuditLogs.Actions[options.type];\n    return this.client.api.guilds(this.id)['audit-logs'].get({\n      query: {\n        before: options.before,\n        limit: options.limit,\n        user_id: this.client.users.resolveID(options.user),\n        action_type: options.type\n      }\n    }).then(data => GuildAuditLogs.build(this, data));\n  }\n  /**\n   * Adds a user to the guild using OAuth2. Requires the `CREATE_INSTANT_INVITE` permission.\n   * @param {UserResolvable} user User to add to the guild\n   * @param {Object} options Options for the addition\n   * @param {string} options.accessToken An OAuth2 access token for the user with the `guilds.join` scope granted to the\n   * bot's application\n   * @param {string} [options.nick] Nickname to give the member (requires `MANAGE_NICKNAMES`)\n   * @param {Collection<Snowflake, Role>|RoleResolvable[]} [options.roles] Roles to add to the member\n   * (requires `MANAGE_ROLES`)\n   * @param {boolean} [options.mute] Whether the member should be muted (requires `MUTE_MEMBERS`)\n   * @param {boolean} [options.deaf] Whether the member should be deafened (requires `DEAFEN_MEMBERS`)\n   * @returns {Promise<GuildMember>}\n   */\n\n\n  async addMember(user, options) {\n    user = this.client.users.resolveID(user);\n    if (!user) throw new TypeError('INVALID_TYPE', 'user', 'UserResolvable');\n    if (this.members.cache.has(user)) return this.members.cache.get(user);\n    options.access_token = options.accessToken;\n\n    if (options.roles) {\n      const roles = [];\n\n      for (let role of options.roles instanceof Collection ? options.roles.values() : options.roles) {\n        role = this.roles.resolve(role);\n\n        if (!role) {\n          throw new TypeError('INVALID_TYPE', 'options.roles', 'Array or Collection of Roles or Snowflakes', true);\n        }\n\n        roles.push(role.id);\n      }\n\n      options.roles = roles;\n    }\n\n    const data = await this.client.api.guilds(this.id).members(user).put({\n      data: options\n    }); // Data is an empty buffer if the member is already part of the guild.\n\n    return data instanceof (browser ? ArrayBuffer : Buffer) ? this.members.fetch(user) : this.members.add(data);\n  }\n  /**\n   * The data for editing a guild.\n   * @typedef {Object} GuildEditData\n   * @property {string} [name] The name of the guild\n   * @property {string} [region] The region of the guild\n   * @property {VerificationLevel|number} [verificationLevel] The verification level of the guild\n   * @property {ExplicitContentFilterLevel|number} [explicitContentFilter] The level of the explicit content filter\n   * @property {ChannelResolvable} [afkChannel] The AFK channel of the guild\n   * @property {ChannelResolvable} [systemChannel] The system channel of the guild\n   * @property {number} [afkTimeout] The AFK timeout of the guild\n   * @property {Base64Resolvable} [icon] The icon of the guild\n   * @property {GuildMemberResolvable} [owner] The owner of the guild\n   * @property {Base64Resolvable} [splash] The invite splash image of the guild\n   * @property {Base64Resolvable} [discoverySplash] The discovery splash image of the guild\n   * @property {Base64Resolvable} [banner] The banner of the guild\n   * @property {DefaultMessageNotifications|number} [defaultMessageNotifications] The default message notifications\n   * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The system channel flags of the guild\n   * @property {ChannelResolvable} [rulesChannel] The rules channel of the guild\n   * @property {ChannelResolvable} [publicUpdatesChannel] The community updates channel of the guild\n   * @property {string} [preferredLocale] The preferred locale of the guild\n   */\n\n  /**\n   * Updates the guild with new information - e.g. a new name.\n   * @param {GuildEditData} data The data to update the guild with\n   * @param {string} [reason] Reason for editing this guild\n   * @returns {Promise<Guild>}\n   * @example\n   * // Set the guild name and region\n   * guild.edit({\n   *   name: 'Discord Guild',\n   *   region: 'london',\n   * })\n   *   .then(updated => console.log(`New guild name ${updated} in region ${updated.region}`))\n   *   .catch(console.error);\n   */\n\n\n  edit(data, reason) {\n    const _data = {};\n    if (data.name) _data.name = data.name;\n    if (data.region) _data.region = data.region;\n\n    if (typeof data.verificationLevel !== 'undefined') {\n      _data.verification_level = typeof data.verificationLevel === 'number' ? Number(data.verificationLevel) : VerificationLevels.indexOf(data.verificationLevel);\n    }\n\n    if (typeof data.afkChannel !== 'undefined') {\n      _data.afk_channel_id = this.client.channels.resolveID(data.afkChannel);\n    }\n\n    if (typeof data.systemChannel !== 'undefined') {\n      _data.system_channel_id = this.client.channels.resolveID(data.systemChannel);\n    }\n\n    if (data.afkTimeout) _data.afk_timeout = Number(data.afkTimeout);\n    if (typeof data.icon !== 'undefined') _data.icon = data.icon;\n    if (data.owner) _data.owner_id = this.client.users.resolveID(data.owner);\n    if (data.splash) _data.splash = data.splash;\n    if (data.discoverySplash) _data.discovery_splash = data.discoverySplash;\n    if (data.banner) _data.banner = data.banner;\n\n    if (typeof data.explicitContentFilter !== 'undefined') {\n      _data.explicit_content_filter = typeof data.explicitContentFilter === 'number' ? data.explicitContentFilter : ExplicitContentFilterLevels.indexOf(data.explicitContentFilter);\n    }\n\n    if (typeof data.defaultMessageNotifications !== 'undefined') {\n      _data.default_message_notifications = typeof data.defaultMessageNotifications === 'string' ? DefaultMessageNotifications.indexOf(data.defaultMessageNotifications) : data.defaultMessageNotifications;\n    }\n\n    if (typeof data.systemChannelFlags !== 'undefined') {\n      _data.system_channel_flags = SystemChannelFlags.resolve(data.systemChannelFlags);\n    }\n\n    if (typeof data.rulesChannel !== 'undefined') {\n      _data.rules_channel_id = this.client.channels.resolveID(data.rulesChannel);\n    }\n\n    if (typeof data.publicUpdatesChannel !== 'undefined') {\n      _data.public_updates_channel_id = this.client.channels.resolveID(data.publicUpdatesChannel);\n    }\n\n    if (data.preferredLocale) _data.preferred_locale = data.preferredLocale;\n    return this.client.api.guilds(this.id).patch({\n      data: _data,\n      reason\n    }).then(newData => this.client.actions.GuildUpdate.handle(newData).updated);\n  }\n  /**\n   * Edits the level of the explicit content filter.\n   * @param {ExplicitContentFilterLevel|number} explicitContentFilter The new level of the explicit content filter\n   * @param {string} [reason] Reason for changing the level of the guild's explicit content filter\n   * @returns {Promise<Guild>}\n   */\n\n\n  setExplicitContentFilter(explicitContentFilter, reason) {\n    return this.edit({\n      explicitContentFilter\n    }, reason);\n  }\n  /* eslint-disable max-len */\n\n  /**\n   * Edits the setting of the default message notifications of the guild.\n   * @param {DefaultMessageNotifications|number} defaultMessageNotifications The new setting for the default message notifications\n   * @param {string} [reason] Reason for changing the setting of the default message notifications\n   * @returns {Promise<Guild>}\n   */\n\n\n  setDefaultMessageNotifications(defaultMessageNotifications, reason) {\n    return this.edit({\n      defaultMessageNotifications\n    }, reason);\n  }\n  /* eslint-enable max-len */\n\n  /**\n   * Edits the flags of the default message notifications of the guild.\n   * @param {SystemChannelFlagsResolvable} systemChannelFlags The new flags for the default message notifications\n   * @param {string} [reason] Reason for changing the flags of the default message notifications\n   * @returns {Promise<Guild>}\n   */\n\n\n  setSystemChannelFlags(systemChannelFlags, reason) {\n    return this.edit({\n      systemChannelFlags\n    }, reason);\n  }\n  /**\n   * Edits the name of the guild.\n   * @param {string} name The new name of the guild\n   * @param {string} [reason] Reason for changing the guild's name\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild name\n   * guild.setName('Discord Guild')\n   *  .then(updated => console.log(`Updated guild name to ${updated.name}`))\n   *  .catch(console.error);\n   */\n\n\n  setName(name, reason) {\n    return this.edit({\n      name\n    }, reason);\n  }\n  /**\n   * Edits the region of the guild.\n   * @param {string} region The new region of the guild\n   * @param {string} [reason] Reason for changing the guild's region\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild region\n   * guild.setRegion('london')\n   *  .then(updated => console.log(`Updated guild region to ${updated.region}`))\n   *  .catch(console.error);\n   */\n\n\n  setRegion(region, reason) {\n    return this.edit({\n      region\n    }, reason);\n  }\n  /**\n   * Edits the verification level of the guild.\n   * @param {VerificationLevel|number} verificationLevel The new verification level of the guild\n   * @param {string} [reason] Reason for changing the guild's verification level\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild verification level\n   * guild.setVerificationLevel(1)\n   *  .then(updated => console.log(`Updated guild verification level to ${guild.verificationLevel}`))\n   *  .catch(console.error);\n   */\n\n\n  setVerificationLevel(verificationLevel, reason) {\n    return this.edit({\n      verificationLevel\n    }, reason);\n  }\n  /**\n   * Edits the AFK channel of the guild.\n   * @param {ChannelResolvable} afkChannel The new AFK channel\n   * @param {string} [reason] Reason for changing the guild's AFK channel\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild AFK channel\n   * guild.setAFKChannel(channel)\n   *  .then(updated => console.log(`Updated guild AFK channel to ${guild.afkChannel.name}`))\n   *  .catch(console.error);\n   */\n\n\n  setAFKChannel(afkChannel, reason) {\n    return this.edit({\n      afkChannel\n    }, reason);\n  }\n  /**\n   * Edits the system channel of the guild.\n   * @param {ChannelResolvable} systemChannel The new system channel\n   * @param {string} [reason] Reason for changing the guild's system channel\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild system channel\n   * guild.setSystemChannel(channel)\n   *  .then(updated => console.log(`Updated guild system channel to ${guild.systemChannel.name}`))\n   *  .catch(console.error);\n   */\n\n\n  setSystemChannel(systemChannel, reason) {\n    return this.edit({\n      systemChannel\n    }, reason);\n  }\n  /**\n   * Edits the AFK timeout of the guild.\n   * @param {number} afkTimeout The time in seconds that a user must be idle to be considered AFK\n   * @param {string} [reason] Reason for changing the guild's AFK timeout\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild AFK channel\n   * guild.setAFKTimeout(60)\n   *  .then(updated => console.log(`Updated guild AFK timeout to ${guild.afkTimeout}`))\n   *  .catch(console.error);\n   */\n\n\n  setAFKTimeout(afkTimeout, reason) {\n    return this.edit({\n      afkTimeout\n    }, reason);\n  }\n  /**\n   * Sets a new guild icon.\n   * @param {Base64Resolvable|BufferResolvable} icon The new icon of the guild\n   * @param {string} [reason] Reason for changing the guild's icon\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild icon\n   * guild.setIcon('./icon.png')\n   *  .then(updated => console.log('Updated the guild icon'))\n   *  .catch(console.error);\n   */\n\n\n  async setIcon(icon, reason) {\n    return this.edit({\n      icon: await DataResolver.resolveImage(icon),\n      reason\n    });\n  }\n  /**\n   * Sets a new owner of the guild.\n   * @param {GuildMemberResolvable} owner The new owner of the guild\n   * @param {string} [reason] Reason for setting the new owner\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild owner\n   * guild.setOwner(guild.members.cache.first())\n   *  .then(updated => console.log(`Updated the guild owner to ${updated.owner.displayName}`))\n   *  .catch(console.error);\n   */\n\n\n  setOwner(owner, reason) {\n    return this.edit({\n      owner\n    }, reason);\n  }\n  /**\n   * Sets a new guild invite splash image.\n   * @param {Base64Resolvable|BufferResolvable} splash The new invite splash image of the guild\n   * @param {string} [reason] Reason for changing the guild's invite splash image\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild splash\n   * guild.setSplash('./splash.png')\n   *  .then(updated => console.log('Updated the guild splash'))\n   *  .catch(console.error);\n   */\n\n\n  async setSplash(splash, reason) {\n    return this.edit({\n      splash: await DataResolver.resolveImage(splash),\n      reason\n    });\n  }\n  /**\n   * Sets a new guild discovery splash image.\n   * @param {Base64Resolvable|BufferResolvable} discoverySplash The new discovery splash image of the guild\n   * @param {string} [reason] Reason for changing the guild's discovery splash image\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild discovery splash\n   * guild.setDiscoverySplash('./discoverysplash.png')\n   *   .then(updated => console.log('Updated the guild discovery splash'))\n   *   .catch(console.error);\n   */\n\n\n  async setDiscoverySplash(discoverySplash, reason) {\n    return this.edit({\n      discoverySplash: await DataResolver.resolveImage(discoverySplash),\n      reason\n    });\n  }\n  /**\n   * Sets a new guild banner.\n   * @param {Base64Resolvable|BufferResolvable} banner The new banner of the guild\n   * @param {string} [reason] Reason for changing the guild's banner\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.setBanner('./banner.png')\n   *  .then(updated => console.log('Updated the guild banner'))\n   *  .catch(console.error);\n   */\n\n\n  async setBanner(banner, reason) {\n    return this.edit({\n      banner: await DataResolver.resolveImage(banner),\n      reason\n    });\n  }\n  /**\n   * Edits the rules channel of the guild.\n   * @param {ChannelResolvable} rulesChannel The new rules channel\n   * @param {string} [reason] Reason for changing the guild's rules channel\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild rules channel\n   * guild.setRulesChannel(channel)\n   *  .then(updated => console.log(`Updated guild rules channel to ${guild.rulesChannel.name}`))\n   *  .catch(console.error);\n   */\n\n\n  setRulesChannel(rulesChannel, reason) {\n    return this.edit({\n      rulesChannel\n    }, reason);\n  }\n  /**\n   * Edits the community updates channel of the guild.\n   * @param {ChannelResolvable} publicUpdatesChannel The new community updates channel\n   * @param {string} [reason] Reason for changing the guild's community updates channel\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild community updates channel\n   * guild.setPublicUpdatesChannel(channel)\n   *  .then(updated => console.log(`Updated guild community updates channel to ${guild.publicUpdatesChannel.name}`))\n   *  .catch(console.error);\n   */\n\n\n  setPublicUpdatesChannel(publicUpdatesChannel, reason) {\n    return this.edit({\n      publicUpdatesChannel\n    }, reason);\n  }\n  /**\n   * Edits the preferred locale of the guild.\n   * @param {string} preferredLocale The new preferred locale of the guild\n   * @param {string} [reason] Reason for changing the guild's preferred locale\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild preferred locale\n   * guild.setPreferredLocale('en-US')\n   *  .then(updated => console.log(`Updated guild preferred locale to ${guild.preferredLocale}`))\n   *  .catch(console.error);\n   */\n\n\n  setPreferredLocale(preferredLocale, reason) {\n    return this.edit({\n      preferredLocale\n    }, reason);\n  }\n  /**\n   * The data needed for updating a channel's position.\n   * @typedef {Object} ChannelPosition\n   * @property {ChannelResolvable} channel Channel to update\n   * @property {number} position New position for the channel\n   */\n\n  /**\n   * Batch-updates the guild's channels' positions.\n   * @param {ChannelPosition[]} channelPositions Channel positions to update\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.setChannelPositions([{ channel: channelID, position: newChannelIndex }])\n   *   .then(guild => console.log(`Updated channel positions for ${guild}`))\n   *   .catch(console.error);\n   */\n\n\n  setChannelPositions(channelPositions) {\n    const updatedChannels = channelPositions.map(r => ({\n      id: this.client.channels.resolveID(r.channel),\n      position: r.position\n    }));\n    return this.client.api.guilds(this.id).channels.patch({\n      data: updatedChannels\n    }).then(() => this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.id,\n      channels: updatedChannels\n    }).guild);\n  }\n  /**\n   * The data needed for updating a guild role's position\n   * @typedef {Object} GuildRolePosition\n   * @property {RoleResolveable} role The ID of the role\n   * @property {number} position The position to update\n   */\n\n  /**\n   * Batch-updates the guild's role positions\n   * @param {GuildRolePosition[]} rolePositions Role positions to update\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.setRolePositions([{ role: roleID, position: updatedRoleIndex }])\n   *  .then(guild => console.log(`Role permissions updated for ${guild}`))\n   *  .catch(console.error);\n   */\n\n\n  setRolePositions(rolePositions) {\n    // Make sure rolePositions are prepared for API\n    rolePositions = rolePositions.map(o => ({\n      id: this.roles.resolveID(o.role),\n      position: o.position\n    })); // Call the API to update role positions\n\n    return this.client.api.guilds(this.id).roles.patch({\n      data: rolePositions\n    }).then(() => this.client.actions.GuildRolesPositionUpdate.handle({\n      guild_id: this.id,\n      roles: rolePositions\n    }).guild);\n  }\n  /**\n   * Edits the guild's embed.\n   * @param {GuildWidgetData} embed The embed for the guild\n   * @param {string} [reason] Reason for changing the guild's embed\n   * @returns {Promise<Guild>}\n   * @deprecated\n   */\n\n\n  setEmbed(embed, reason) {\n    return this.setWidget(embed, reason);\n  }\n  /**\n   * Edits the guild's widget.\n   * @param {GuildWidgetData} widget The widget for the guild\n   * @param {string} [reason] Reason for changing the guild's widget\n   * @returns {Promise<Guild>}\n   */\n\n\n  setWidget(widget, reason) {\n    return this.client.api.guilds(this.id).widget.patch({\n      data: {\n        enabled: widget.enabled,\n        channel_id: this.channels.resolveID(widget.channel)\n      },\n      reason\n    }).then(() => this);\n  }\n  /**\n   * Leaves the guild.\n   * @returns {Promise<Guild>}\n   * @example\n   * // Leave a guild\n   * guild.leave()\n   *   .then(g => console.log(`Left the guild ${g}`))\n   *   .catch(console.error);\n   */\n\n\n  leave() {\n    if (this.ownerID === this.client.user.id) return Promise.reject(new Error('GUILD_OWNED'));\n    return this.client.api.users('@me').guilds(this.id).delete().then(() => this.client.actions.GuildDelete.handle({\n      id: this.id\n    }).guild);\n  }\n  /**\n   * Deletes the guild.\n   * @returns {Promise<Guild>}\n   * @example\n   * // Delete a guild\n   * guild.delete()\n   *   .then(g => console.log(`Deleted the guild ${g}`))\n   *   .catch(console.error);\n   */\n\n\n  delete() {\n    return this.client.api.guilds(this.id).delete().then(() => this.client.actions.GuildDelete.handle({\n      id: this.id\n    }).guild);\n  }\n  /**\n   * Whether this guild equals another guild. It compares all properties, so for most operations\n   * it is advisable to just compare `guild.id === guild2.id` as it is much faster and is often\n   * what most users need.\n   * @param {Guild} guild The guild to compare with\n   * @returns {boolean}\n   */\n\n\n  equals(guild) {\n    let equal = guild && guild instanceof this.constructor && this.id === guild.id && this.available === guild.available && this.splash === guild.splash && this.discoverySplash === guild.discoverySplash && this.region === guild.region && this.name === guild.name && this.memberCount === guild.memberCount && this.large === guild.large && this.icon === guild.icon && this.ownerID === guild.ownerID && this.verificationLevel === guild.verificationLevel && this.embedEnabled === guild.embedEnabled && (this.features === guild.features || this.features.length === guild.features.length && this.features.every((feat, i) => feat === guild.features[i]));\n\n    if (equal) {\n      if (this.embedChannel) {\n        if (!guild.embedChannel || this.embedChannel.id !== guild.embedChannel.id) equal = false;\n      } else if (guild.embedChannel) {\n        equal = false;\n      }\n    }\n\n    return equal;\n  }\n  /**\n   * When concatenated with a string, this automatically returns the guild's name instead of the Guild object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from My Guild!\n   * console.log(`Hello from ${guild}!`);\n   */\n\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    const json = super.toJSON({\n      available: false,\n      createdTimestamp: true,\n      nameAcronym: true,\n      presences: false,\n      voiceStates: false\n    });\n    json.iconURL = this.iconURL();\n    json.splashURL = this.splashURL();\n    json.discoverySplashURL = this.discoverySplashURL();\n    json.bannerURL = this.bannerURL();\n    return json;\n  }\n  /**\n   * Creates a collection of this guild's roles, sorted by their position and IDs.\n   * @returns {Collection<Role>}\n   * @private\n   */\n\n\n  _sortedRoles() {\n    return Util.discordSort(this.roles.cache);\n  }\n  /**\n   * Creates a collection of this guild's or a specific category's channels, sorted by their position and IDs.\n   * @param {GuildChannel} [channel] Category to get the channels of\n   * @returns {Collection<GuildChannel>}\n   * @private\n   */\n\n\n  _sortedChannels(channel) {\n    const category = channel.type === ChannelTypes.CATEGORY;\n    return Util.discordSort(this.channels.cache.filter(c => (['text', 'news', 'store'].includes(channel.type) ? ['text', 'news', 'store'].includes(c.type) : c.type === channel.type) && (category || c.parent === channel.parent)));\n  }\n\n}\n\nGuild.prototype.setEmbed = deprecate(Guild.prototype.setEmbed, 'Guild#setEmbed: Use setWidget instead');\nGuild.prototype.fetchEmbed = deprecate(Guild.prototype.fetchEmbed, 'Guild#fetchEmbed: Use fetchWidget instead');\nGuild.prototype.fetchVanityCode = deprecate(Guild.prototype.fetchVanityCode, 'Guild#fetchVanityCode: Use fetchVanityData() instead');\nmodule.exports = Guild;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/structures/Guild.js"],"names":["deprecate","require","Base","GuildAuditLogs","GuildPreview","GuildTemplate","Integration","Invite","VoiceRegion","Webhook","Error","TypeError","GuildChannelManager","GuildEmojiManager","GuildMemberManager","PresenceManager","RoleManager","VoiceStateManager","Collection","browser","ChannelTypes","DefaultMessageNotifications","PartialTypes","VerificationLevels","ExplicitContentFilterLevels","DataResolver","Snowflake","SystemChannelFlags","Util","Guild","constructor","client","data","members","channels","roles","presences","voiceStates","deleted","unavailable","available","id","_patch","shardID","shard","ws","shards","get","name","icon","splash","discoverySplash","discovery_splash","region","memberCount","member_count","large","Boolean","features","applicationID","application_id","afkTimeout","afk_timeout","afkChannelID","afk_channel_id","systemChannelID","system_channel_id","embedEnabled","embed_enabled","premiumTier","premium_tier","premium_subscription_count","premiumSubscriptionCount","widget_enabled","widgetEnabled","widget_channel_id","widgetChannelID","embed_channel_id","embedChannelID","verificationLevel","verification_level","explicitContentFilter","explicit_content_filter","mfaLevel","mfa_level","joinedTimestamp","joined_at","Date","getTime","defaultMessageNotifications","default_message_notifications","systemChannelFlags","system_channel_flags","freeze","max_members","maximumMembers","max_presences","maximumPresences","approximate_member_count","approximateMemberCount","approximate_presence_count","approximatePresenceCount","vanityURLCode","vanity_url_code","vanityURLUses","description","banner","rulesChannelID","rules_channel_id","publicUpdatesChannelID","public_updates_channel_id","preferredLocale","preferred_locale","cache","clear","rawChannel","add","role","guildUser","owner_id","ownerID","presence","Object","assign","guild","voice_states","voiceState","emojis","emoji","actions","GuildEmojisUpdate","handle","guild_id","bannerURL","format","size","rest","cdn","Banner","createdTimestamp","deconstruct","timestamp","createdAt","joinedAt","partnered","includes","verified","iconURL","dynamic","Icon","nameAcronym","replace","e","splashURL","Splash","discoverySplashURL","DiscoverySplash","owner","options","partials","GUILD_MEMBER","user","afkChannel","systemChannel","widgetChannel","embedChannel","rulesChannel","publicUpdatesChannel","me","voice","member","resolve","fetch","api","guilds","query","with_counts","then","fetchBan","users","resolveID","bans","ban","reason","fetchBans","reduce","collection","set","fetchIntegrations","includeApplications","integrations","include_applications","integration","fetchTemplates","templates","col","code","createIntegration","post","createTemplate","fetchInvites","invites","inviteItems","inviteItem","invite","fetchPreview","preview","fetchVanityCode","fetchVanityData","vanity","uses","fetchWebhooks","webhooks","hooks","hook","fetchVoiceRegions","regions","res","fetchEmbed","fetchWidget","widget","enabled","channel_id","channel","fetchAuditLogs","before","Entry","type","Actions","limit","user_id","action_type","build","addMember","has","access_token","accessToken","values","push","put","ArrayBuffer","Buffer","edit","_data","Number","indexOf","patch","newData","GuildUpdate","updated","setExplicitContentFilter","setDefaultMessageNotifications","setSystemChannelFlags","setName","setRegion","setVerificationLevel","setAFKChannel","setSystemChannel","setAFKTimeout","setIcon","resolveImage","setOwner","setSplash","setDiscoverySplash","setBanner","setRulesChannel","setPublicUpdatesChannel","setPreferredLocale","setChannelPositions","channelPositions","updatedChannels","map","r","position","GuildChannelsPositionUpdate","setRolePositions","rolePositions","o","GuildRolesPositionUpdate","setEmbed","embed","setWidget","leave","Promise","reject","delete","GuildDelete","equals","equal","length","every","feat","i","toString","toJSON","json","_sortedRoles","discordSort","_sortedChannels","category","CATEGORY","filter","c","parent","prototype","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst { deprecate } = require('util');\nconst Base = require('./Base');\nconst GuildAuditLogs = require('./GuildAuditLogs');\nconst GuildPreview = require('./GuildPreview');\nconst GuildTemplate = require('./GuildTemplate');\nconst Integration = require('./Integration');\nconst Invite = require('./Invite');\nconst VoiceRegion = require('./VoiceRegion');\nconst Webhook = require('./Webhook');\nconst { Error, TypeError } = require('../errors');\nconst GuildChannelManager = require('../managers/GuildChannelManager');\nconst GuildEmojiManager = require('../managers/GuildEmojiManager');\nconst GuildMemberManager = require('../managers/GuildMemberManager');\nconst PresenceManager = require('../managers/PresenceManager');\nconst RoleManager = require('../managers/RoleManager');\nconst VoiceStateManager = require('../managers/VoiceStateManager');\nconst Collection = require('../util/Collection');\nconst {\n  browser,\n  ChannelTypes,\n  DefaultMessageNotifications,\n  PartialTypes,\n  VerificationLevels,\n  ExplicitContentFilterLevels,\n} = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst Snowflake = require('../util/Snowflake');\nconst SystemChannelFlags = require('../util/SystemChannelFlags');\nconst Util = require('../util/Util');\n\n/**\n * Represents a guild (or a server) on Discord.\n * <info>It's recommended to see if a guild is available before performing operations or reading data from it. You can\n * check this with `guild.available`.</info>\n * @extends {Base}\n */\nclass Guild extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the guild\n   */\n  constructor(client, data) {\n    super(client);\n\n    /**\n     * A manager of the members belonging to this guild\n     * @type {GuildMemberManager}\n     */\n    this.members = new GuildMemberManager(this);\n\n    /**\n     * A manager of the channels belonging to this guild\n     * @type {GuildChannelManager}\n     */\n    this.channels = new GuildChannelManager(this);\n\n    /**\n     * A manager of the roles belonging to this guild\n     * @type {RoleManager}\n     */\n    this.roles = new RoleManager(this);\n\n    /**\n     * A manager of the presences belonging to this guild\n     * @type {PresenceManager}\n     */\n    this.presences = new PresenceManager(this.client);\n\n    /**\n     * A manager of the voice states of this guild\n     * @type {VoiceStateManager}\n     */\n    this.voiceStates = new VoiceStateManager(this);\n\n    /**\n     * Whether the bot has been removed from the guild\n     * @type {boolean}\n     */\n    this.deleted = false;\n\n    if (!data) return;\n    if (data.unavailable) {\n      /**\n       * Whether the guild is available to access. If it is not available, it indicates a server outage\n       * @type {boolean}\n       */\n      this.available = false;\n\n      /**\n       * The Unique ID of the guild, useful for comparisons\n       * @type {Snowflake}\n       */\n      this.id = data.id;\n    } else {\n      this._patch(data);\n      if (!data.channels) this.available = false;\n    }\n\n    /**\n     * The id of the shard this Guild belongs to.\n     * @type {number}\n     */\n    this.shardID = data.shardID;\n  }\n\n  /**\n   * The Shard this Guild belongs to.\n   * @type {WebSocketShard}\n   * @readonly\n   */\n  get shard() {\n    return this.client.ws.shards.get(this.shardID);\n  }\n\n  /**\n   * Sets up the guild.\n   * @param {*} data The raw data of the guild\n   * @private\n   */\n  _patch(data) {\n    /**\n     * The name of the guild\n     * @type {string}\n     */\n    this.name = data.name;\n\n    /**\n     * The hash of the guild icon\n     * @type {?string}\n     */\n    this.icon = data.icon;\n\n    /**\n     * The hash of the guild invite splash image\n     * @type {?string}\n     */\n    this.splash = data.splash;\n\n    /**\n     * The hash of the guild discovery splash image\n     * @type {?string}\n     */\n    this.discoverySplash = data.discovery_splash;\n\n    /**\n     * The region the guild is located in\n     * @type {string}\n     */\n    this.region = data.region;\n\n    /**\n     * The full amount of members in this guild\n     * @type {number}\n     */\n    this.memberCount = data.member_count || this.memberCount;\n\n    /**\n     * Whether the guild is \"large\" (has more than large_threshold members, 50 by default)\n     * @type {boolean}\n     */\n    this.large = Boolean('large' in data ? data.large : this.large);\n\n    /**\n     * An array of enabled guild features, here are the possible values:\n     * * ANIMATED_ICON\n     * * BANNER\n     * * COMMERCE\n     * * COMMUNITY\n     * * DISCOVERABLE\n     * * FEATURABLE\n     * * INVITE_SPLASH\n     * * NEWS\n     * * PARTNERED\n     * * RELAY_ENABLED\n     * * VANITY_URL\n     * * VERIFIED\n     * * VIP_REGIONS\n     * * WELCOME_SCREEN_ENABLED\n     * @typedef {string} Features\n     */\n\n    /**\n     * An array of guild features partnered guilds have enabled\n     * @type {Features[]}\n     */\n    this.features = data.features;\n\n    /**\n     * The ID of the application that created this guild (if applicable)\n     * @type {?Snowflake}\n     */\n    this.applicationID = data.application_id;\n\n    /**\n     * The time in seconds before a user is counted as \"away from keyboard\"\n     * @type {?number}\n     */\n    this.afkTimeout = data.afk_timeout;\n\n    /**\n     * The ID of the voice channel where AFK members are moved\n     * @type {?Snowflake}\n     */\n    this.afkChannelID = data.afk_channel_id;\n\n    /**\n     * The ID of the system channel\n     * @type {?Snowflake}\n     */\n    this.systemChannelID = data.system_channel_id;\n\n    /**\n     * Whether embedded images are enabled on this guild\n     * @type {boolean}\n     * @deprecated\n     */\n    this.embedEnabled = data.embed_enabled;\n\n    /**\n     * The type of premium tier:\n     * * 0: NONE\n     * * 1: TIER_1\n     * * 2: TIER_2\n     * * 3: TIER_3\n     * @typedef {number} PremiumTier\n     */\n\n    /**\n     * The premium tier on this guild\n     * @type {PremiumTier}\n     */\n    this.premiumTier = data.premium_tier;\n\n    if (typeof data.premium_subscription_count !== 'undefined') {\n      /**\n       * The total number of boosts for this server\n       * @type {?number}\n       */\n      this.premiumSubscriptionCount = data.premium_subscription_count;\n    }\n\n    if (typeof data.widget_enabled !== 'undefined') {\n      /**\n       * Whether widget images are enabled on this guild\n       * @type {?boolean}\n       */\n      this.widgetEnabled = data.widget_enabled;\n    }\n\n    if (typeof data.widget_channel_id !== 'undefined') {\n      /**\n       * The widget channel ID, if enabled\n       * @type {?string}\n       */\n      this.widgetChannelID = data.widget_channel_id;\n    }\n\n    if (typeof data.embed_channel_id !== 'undefined') {\n      /**\n       * The embed channel ID, if enabled\n       * @type {?string}\n       * @deprecated\n       */\n      this.embedChannelID = data.embed_channel_id;\n    }\n\n    /**\n     * The verification level of the guild\n     * @type {VerificationLevel}\n     */\n    this.verificationLevel = VerificationLevels[data.verification_level];\n\n    /**\n     * The explicit content filter level of the guild\n     * @type {ExplicitContentFilterLevel}\n     */\n    this.explicitContentFilter = ExplicitContentFilterLevels[data.explicit_content_filter];\n\n    /**\n     * The required MFA level for the guild\n     * @type {number}\n     */\n    this.mfaLevel = data.mfa_level;\n\n    /**\n     * The timestamp the client user joined the guild at\n     * @type {number}\n     */\n    this.joinedTimestamp = data.joined_at ? new Date(data.joined_at).getTime() : this.joinedTimestamp;\n\n    /**\n     * The value set for the guild's default message notifications\n     * @type {DefaultMessageNotifications|number}\n     */\n    this.defaultMessageNotifications =\n      DefaultMessageNotifications[data.default_message_notifications] || data.default_message_notifications;\n\n    /**\n     * The value set for the guild's system channel flags\n     * @type {Readonly<SystemChannelFlags>}\n     */\n    this.systemChannelFlags = new SystemChannelFlags(data.system_channel_flags).freeze();\n\n    if (typeof data.max_members !== 'undefined') {\n      /**\n       * The maximum amount of members the guild can have\n       * @type {?number}\n       */\n      this.maximumMembers = data.max_members;\n    } else if (typeof this.maximumMembers === 'undefined') {\n      this.maximumMembers = null;\n    }\n\n    if (typeof data.max_presences !== 'undefined') {\n      /**\n       * The maximum amount of presences the guild can have\n       * <info>You will need to fetch the guild using {@link Guild#fetch} if you want to receive this parameter</info>\n       * @type {?number}\n       */\n      this.maximumPresences = data.max_presences || 25000;\n    } else if (typeof this.maximumPresences === 'undefined') {\n      this.maximumPresences = null;\n    }\n\n    if (typeof data.approximate_member_count !== 'undefined') {\n      /**\n       * The approximate amount of members the guild has\n       * <info>You will need to fetch the guild using {@link Guild#fetch} if you want to receive this parameter</info>\n       * @type {?number}\n       */\n      this.approximateMemberCount = data.approximate_member_count;\n    } else if (typeof this.approximateMemberCount === 'undefined') {\n      this.approximateMemberCount = null;\n    }\n\n    if (typeof data.approximate_presence_count !== 'undefined') {\n      /**\n       * The approximate amount of presences the guild has\n       * <info>You will need to fetch the guild using {@link Guild#fetch} if you want to receive this parameter</info>\n       * @type {?number}\n       */\n      this.approximatePresenceCount = data.approximate_presence_count;\n    } else if (typeof this.approximatePresenceCount === 'undefined') {\n      this.approximatePresenceCount = null;\n    }\n\n    /**\n     * The vanity invite code of the guild, if any\n     * @type {?string}\n     */\n    this.vanityURLCode = data.vanity_url_code;\n\n    /* eslint-disable max-len */\n    /**\n     * The use count of the vanity URL code of the guild, if any\n     * <info>You will need to fetch this parameter using {@link Guild#fetchVanityData} if you want to receive it</info>\n     * @type {?number}\n     */\n    this.vanityURLUses = null;\n    /* eslint-enable max-len */\n\n    /**\n     * The description of the guild, if any\n     * @type {?string}\n     */\n    this.description = data.description;\n\n    /**\n     * The hash of the guild banner\n     * @type {?string}\n     */\n    this.banner = data.banner;\n\n    this.id = data.id;\n    this.available = !data.unavailable;\n    this.features = data.features || this.features || [];\n\n    /**\n     * The ID of the rules channel for the guild\n     * @type {?Snowflake}\n     */\n    this.rulesChannelID = data.rules_channel_id;\n\n    /**\n     * The ID of the community updates channel for the guild\n     * @type {?Snowflake}\n     */\n    this.publicUpdatesChannelID = data.public_updates_channel_id;\n\n    /**\n     * The preferred locale of the guild, defaults to `en-US`\n     * @type {string}\n     */\n    this.preferredLocale = data.preferred_locale;\n\n    if (data.channels) {\n      this.channels.cache.clear();\n      for (const rawChannel of data.channels) {\n        this.client.channels.add(rawChannel, this);\n      }\n    }\n\n    if (data.roles) {\n      this.roles.cache.clear();\n      for (const role of data.roles) this.roles.add(role);\n    }\n\n    if (data.members) {\n      this.members.cache.clear();\n      for (const guildUser of data.members) this.members.add(guildUser);\n    }\n\n    if (data.owner_id) {\n      /**\n       * The user ID of this guild's owner\n       * @type {Snowflake}\n       */\n      this.ownerID = data.owner_id;\n    }\n\n    if (data.presences) {\n      for (const presence of data.presences) {\n        this.presences.add(Object.assign(presence, { guild: this }));\n      }\n    }\n\n    if (data.voice_states) {\n      this.voiceStates.cache.clear();\n      for (const voiceState of data.voice_states) {\n        this.voiceStates.add(voiceState);\n      }\n    }\n\n    if (!this.emojis) {\n      /**\n       * A manager of the emojis belonging to this guild\n       * @type {GuildEmojiManager}\n       */\n      this.emojis = new GuildEmojiManager(this);\n      if (data.emojis) for (const emoji of data.emojis) this.emojis.add(emoji);\n    } else if (data.emojis) {\n      this.client.actions.GuildEmojisUpdate.handle({\n        guild_id: this.id,\n        emojis: data.emojis,\n      });\n    }\n  }\n\n  /**\n   * The URL to this guild's banner.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n  bannerURL({ format, size } = {}) {\n    if (!this.banner) return null;\n    return this.client.rest.cdn.Banner(this.id, this.banner, format, size);\n  }\n\n  /**\n   * The timestamp the guild was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n\n  /**\n   * The time the guild was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The time the client user joined the guild\n   * @type {Date}\n   * @readonly\n   */\n  get joinedAt() {\n    return new Date(this.joinedTimestamp);\n  }\n\n  /**\n   * If this guild is partnered\n   * @type {boolean}\n   * @readonly\n   */\n  get partnered() {\n    return this.features.includes('PARTNERED');\n  }\n\n  /**\n   * If this guild is verified\n   * @type {boolean}\n   * @readonly\n   */\n  get verified() {\n    return this.features.includes('VERIFIED');\n  }\n\n  /**\n   * The URL to this guild's icon.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n  iconURL({ format, size, dynamic } = {}) {\n    if (!this.icon) return null;\n    return this.client.rest.cdn.Icon(this.id, this.icon, format, size, dynamic);\n  }\n\n  /**\n   * The acronym that shows up in place of a guild icon.\n   * @type {string}\n   * @readonly\n   */\n  get nameAcronym() {\n    return this.name\n      .replace(/'s /g, ' ')\n      .replace(/\\w+/g, e => e[0])\n      .replace(/\\s/g, '');\n  }\n\n  /**\n   * The URL to this guild's invite splash image.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n  splashURL({ format, size } = {}) {\n    if (!this.splash) return null;\n    return this.client.rest.cdn.Splash(this.id, this.splash, format, size);\n  }\n\n  /**\n   * The URL to this guild's discovery splash image.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n  discoverySplashURL({ format, size } = {}) {\n    if (!this.discoverySplash) return null;\n    return this.client.rest.cdn.DiscoverySplash(this.id, this.discoverySplash, format, size);\n  }\n\n  /**\n   * The owner of the guild\n   * @type {?GuildMember}\n   * @readonly\n   */\n  get owner() {\n    return (\n      this.members.cache.get(this.ownerID) ||\n      (this.client.options.partials.includes(PartialTypes.GUILD_MEMBER)\n        ? this.members.add({ user: { id: this.ownerID } }, true)\n        : null)\n    );\n  }\n\n  /**\n   * AFK voice channel for this guild\n   * @type {?VoiceChannel}\n   * @readonly\n   */\n  get afkChannel() {\n    return this.client.channels.cache.get(this.afkChannelID) || null;\n  }\n\n  /**\n   * System channel for this guild\n   * @type {?TextChannel}\n   * @readonly\n   */\n  get systemChannel() {\n    return this.client.channels.cache.get(this.systemChannelID) || null;\n  }\n\n  /**\n   * Widget channel for this guild\n   * @type {?TextChannel}\n   * @readonly\n   */\n  get widgetChannel() {\n    return this.client.channels.cache.get(this.widgetChannelID) || null;\n  }\n\n  /**\n   * Embed channel for this guild\n   * @type {?TextChannel}\n   * @readonly\n   * @deprecated\n   */\n  get embedChannel() {\n    return this.client.channels.cache.get(this.embedChannelID) || null;\n  }\n\n  /**\n   * Rules channel for this guild\n   * @type {?TextChannel}\n   * @readonly\n   */\n  get rulesChannel() {\n    return this.client.channels.cache.get(this.rulesChannelID) || null;\n  }\n\n  /**\n   * Public updates channel for this guild\n   * @type {?TextChannel}\n   * @readonly\n   */\n  get publicUpdatesChannel() {\n    return this.client.channels.cache.get(this.publicUpdatesChannelID) || null;\n  }\n\n  /**\n   * The client user as a GuildMember of this guild\n   * @type {?GuildMember}\n   * @readonly\n   */\n  get me() {\n    return (\n      this.members.cache.get(this.client.user.id) ||\n      (this.client.options.partials.includes(PartialTypes.GUILD_MEMBER)\n        ? this.members.add({ user: { id: this.client.user.id } }, true)\n        : null)\n    );\n  }\n\n  /**\n   * The voice state for the client user of this guild, if any\n   * @type {?VoiceState}\n   * @readonly\n   */\n  get voice() {\n    return this.voiceStates.cache.get(this.client.user.id);\n  }\n\n  /**\n   * Returns the GuildMember form of a User object, if the user is present in the guild.\n   * @param {UserResolvable} user The user that you want to obtain the GuildMember of\n   * @returns {?GuildMember}\n   * @example\n   * // Get the guild member of a user\n   * const member = guild.member(message.author);\n   */\n  member(user) {\n    return this.members.resolve(user);\n  }\n\n  /**\n   * Fetches this guild.\n   * @returns {Promise<Guild>}\n   */\n  fetch() {\n    return this.client.api\n      .guilds(this.id)\n      .get({ query: { with_counts: true } })\n      .then(data => {\n        this._patch(data);\n        return this;\n      });\n  }\n\n  /**\n   * An object containing information about a guild member's ban.\n   * @typedef {Object} BanInfo\n   * @property {User} user User that was banned\n   * @property {?string} reason Reason the user was banned\n   */\n\n  /**\n   * Fetches information on a banned user from this guild.\n   * @param {UserResolvable} user The User to fetch the ban info of\n   * @returns {Promise<BanInfo>}\n   */\n  fetchBan(user) {\n    const id = this.client.users.resolveID(user);\n    if (!id) throw new Error('FETCH_BAN_RESOLVE_ID');\n    return this.client.api\n      .guilds(this.id)\n      .bans(id)\n      .get()\n      .then(ban => ({\n        reason: ban.reason,\n        user: this.client.users.add(ban.user),\n      }));\n  }\n\n  /**\n   * Fetches a collection of banned users in this guild.\n   * @returns {Promise<Collection<Snowflake, BanInfo>>}\n   */\n  fetchBans() {\n    return this.client.api\n      .guilds(this.id)\n      .bans.get()\n      .then(bans =>\n        bans.reduce((collection, ban) => {\n          collection.set(ban.user.id, {\n            reason: ban.reason,\n            user: this.client.users.add(ban.user),\n          });\n          return collection;\n        }, new Collection()),\n      );\n  }\n\n  /**\n   * Fetches a collection of integrations to this guild.\n   * Resolves with a collection mapping integrations by their ids.\n   * @param {Object} [options] Options for fetching integrations\n   * @param {boolean} [options.includeApplications] Whether to include bot and Oauth2 webhook integrations\n   * @returns {Promise<Collection<string, Integration>>}\n   * @example\n   * // Fetch integrations\n   * guild.fetchIntegrations()\n   *   .then(integrations => console.log(`Fetched ${integrations.size} integrations`))\n   *   .catch(console.error);\n   */\n  fetchIntegrations({ includeApplications = false } = {}) {\n    return this.client.api\n      .guilds(this.id)\n      .integrations.get({\n        query: {\n          include_applications: includeApplications,\n        },\n      })\n      .then(data =>\n        data.reduce(\n          (collection, integration) => collection.set(integration.id, new Integration(this.client, integration, this)),\n          new Collection(),\n        ),\n      );\n  }\n\n  /**\n   * Fetches a collection of templates from this guild.\n   * Resolves with a collection mapping templates by their codes.\n   * @returns {Promise<Collection<string, GuildTemplate>>}\n   */\n  fetchTemplates() {\n    return this.client.api\n      .guilds(this.id)\n      .templates.get()\n      .then(templates =>\n        templates.reduce((col, data) => col.set(data.code, new GuildTemplate(this.client, data)), new Collection()),\n      );\n  }\n\n  /**\n   * The data for creating an integration.\n   * @typedef {Object} IntegrationData\n   * @property {string} id The integration id\n   * @property {string} type The integration type\n   */\n\n  /**\n   * Creates an integration by attaching an integration object\n   * @param {IntegrationData} data The data for the integration\n   * @param {string} reason Reason for creating the integration\n   * @returns {Promise<Guild>}\n   */\n  createIntegration(data, reason) {\n    return this.client.api\n      .guilds(this.id)\n      .integrations.post({ data, reason })\n      .then(() => this);\n  }\n\n  /**\n   * Creates a template for the guild.\n   * @param {string} name The name for the template\n   * @param {string} [description] The description for the template\n   * @returns {Promise<GuildTemplate>}\n   */\n  createTemplate(name, description) {\n    return this.client.api\n      .guilds(this.id)\n      .templates.post({ data: { name, description } })\n      .then(data => new GuildTemplate(this.client, data));\n  }\n\n  /**\n   * Fetches a collection of invites to this guild.\n   * Resolves with a collection mapping invites by their codes.\n   * @returns {Promise<Collection<string, Invite>>}\n   * @example\n   * // Fetch invites\n   * guild.fetchInvites()\n   *   .then(invites => console.log(`Fetched ${invites.size} invites`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch invite creator by their id\n   * guild.fetchInvites()\n   *  .then(invites => console.log(invites.find(invite => invite.inviter.id === '84484653687267328')))\n   *  .catch(console.error);\n   */\n  fetchInvites() {\n    return this.client.api\n      .guilds(this.id)\n      .invites.get()\n      .then(inviteItems => {\n        const invites = new Collection();\n        for (const inviteItem of inviteItems) {\n          const invite = new Invite(this.client, inviteItem);\n          invites.set(invite.code, invite);\n        }\n        return invites;\n      });\n  }\n\n  /**\n   * Obtains a guild preview for this guild from Discord.\n   * @returns {Promise<GuildPreview>}\n   */\n  fetchPreview() {\n    return this.client.api\n      .guilds(this.id)\n      .preview.get()\n      .then(data => new GuildPreview(this.client, data));\n  }\n\n  /**\n   * Fetches the vanity url invite code to this guild.\n   * Resolves with a string matching the vanity url invite code, not the full url.\n   * @returns {Promise<string>}\n   * @deprecated\n   * @example\n   * // Fetch invites\n   * guild.fetchVanityCode()\n   *   .then(code => {\n   *     console.log(`Vanity URL: https://discord.gg/${code}`);\n   *   })\n   *   .catch(console.error);\n   */\n  fetchVanityCode() {\n    return this.fetchVanityData().then(vanity => vanity.code);\n  }\n\n  /**\n   * An object containing information about a guild's vanity invite.\n   * @typedef {Object} Vanity\n   * @property {?string} code Vanity invite code\n   * @property {?number} uses How many times this invite has been used\n   */\n\n  /**\n   * Fetches the vanity url invite object to this guild.\n   * Resolves with an object containing the vanity url invite code and the use count\n   * @returns {Promise<Vanity>}\n   * @example\n   * // Fetch invite data\n   * guild.fetchVanityData()\n   *   .then(res => {\n   *     console.log(`Vanity URL: https://discord.gg/${res.code} with ${res.uses} uses`);\n   *   })\n   *   .catch(console.error);\n   */\n  async fetchVanityData() {\n    if (!this.features.includes('VANITY_URL')) {\n      throw new Error('VANITY_URL');\n    }\n    const data = await this.client.api.guilds(this.id, 'vanity-url').get();\n    this.vanityURLUses = data.uses;\n\n    return data;\n  }\n\n  /**\n   * Fetches all webhooks for the guild.\n   * @returns {Promise<Collection<Snowflake, Webhook>>}\n   * @example\n   * // Fetch webhooks\n   * guild.fetchWebhooks()\n   *   .then(webhooks => console.log(`Fetched ${webhooks.size} webhooks`))\n   *   .catch(console.error);\n   */\n  fetchWebhooks() {\n    return this.client.api\n      .guilds(this.id)\n      .webhooks.get()\n      .then(data => {\n        const hooks = new Collection();\n        for (const hook of data) hooks.set(hook.id, new Webhook(this.client, hook));\n        return hooks;\n      });\n  }\n\n  /**\n   * Fetches available voice regions.\n   * @returns {Promise<Collection<string, VoiceRegion>>}\n   */\n  fetchVoiceRegions() {\n    return this.client.api\n      .guilds(this.id)\n      .regions.get()\n      .then(res => {\n        const regions = new Collection();\n        for (const region of res) regions.set(region.id, new VoiceRegion(region));\n        return regions;\n      });\n  }\n\n  /**\n   * Data for the Guild Widget object\n   * @typedef {Object} GuildWidget\n   * @property {boolean} enabled Whether the widget is enabled\n   * @property {?GuildChannel} channel The widget channel\n   */\n\n  /**\n   * The Guild Widget object\n   * @typedef {Object} GuildWidgetData\n   * @property {boolean} enabled Whether the widget is enabled\n   * @property {?GuildChannelResolvable} channel The widget channel\n   */\n\n  /**\n   * Fetches the guild embed.\n   * @returns {Promise<GuildWidget>}\n   * @deprecated\n   * @example\n   * // Fetches the guild embed\n   * guild.fetchEmbed()\n   *   .then(embed => console.log(`The embed is ${embed.enabled ? 'enabled' : 'disabled'}`))\n   *   .catch(console.error);\n   */\n  fetchEmbed() {\n    return this.fetchWidget();\n  }\n\n  /**\n   * Fetches the guild widget.\n   * @returns {Promise<GuildWidget>}\n   * @example\n   * // Fetches the guild widget\n   * guild.fetchWidget()\n   *   .then(widget => console.log(`The widget is ${widget.enabled ? 'enabled' : 'disabled'}`))\n   *   .catch(console.error);\n   */\n  async fetchWidget() {\n    const data = await this.client.api.guilds(this.id).widget.get();\n    this.widgetEnabled = this.embedEnabled = data.enabled;\n    this.widgetChannelID = this.embedChannelID = data.channel_id;\n    return {\n      enabled: data.enabled,\n      channel: data.channel_id ? this.channels.cache.get(data.channel_id) : null,\n    };\n  }\n\n  /**\n   * Fetches audit logs for this guild.\n   * @param {Object} [options={}] Options for fetching audit logs\n   * @param {Snowflake|GuildAuditLogsEntry} [options.before] Limit to entries from before specified entry\n   * @param {number} [options.limit] Limit number of entries\n   * @param {UserResolvable} [options.user] Only show entries involving this user\n   * @param {AuditLogAction|number} [options.type] Only show entries involving this action type\n   * @returns {Promise<GuildAuditLogs>}\n   * @example\n   * // Output audit log entries\n   * guild.fetchAuditLogs()\n   *   .then(audit => console.log(audit.entries.first()))\n   *   .catch(console.error);\n   */\n  fetchAuditLogs(options = {}) {\n    if (options.before && options.before instanceof GuildAuditLogs.Entry) options.before = options.before.id;\n    if (typeof options.type === 'string') options.type = GuildAuditLogs.Actions[options.type];\n\n    return this.client.api\n      .guilds(this.id)\n      ['audit-logs'].get({\n        query: {\n          before: options.before,\n          limit: options.limit,\n          user_id: this.client.users.resolveID(options.user),\n          action_type: options.type,\n        },\n      })\n      .then(data => GuildAuditLogs.build(this, data));\n  }\n\n  /**\n   * Adds a user to the guild using OAuth2. Requires the `CREATE_INSTANT_INVITE` permission.\n   * @param {UserResolvable} user User to add to the guild\n   * @param {Object} options Options for the addition\n   * @param {string} options.accessToken An OAuth2 access token for the user with the `guilds.join` scope granted to the\n   * bot's application\n   * @param {string} [options.nick] Nickname to give the member (requires `MANAGE_NICKNAMES`)\n   * @param {Collection<Snowflake, Role>|RoleResolvable[]} [options.roles] Roles to add to the member\n   * (requires `MANAGE_ROLES`)\n   * @param {boolean} [options.mute] Whether the member should be muted (requires `MUTE_MEMBERS`)\n   * @param {boolean} [options.deaf] Whether the member should be deafened (requires `DEAFEN_MEMBERS`)\n   * @returns {Promise<GuildMember>}\n   */\n  async addMember(user, options) {\n    user = this.client.users.resolveID(user);\n    if (!user) throw new TypeError('INVALID_TYPE', 'user', 'UserResolvable');\n    if (this.members.cache.has(user)) return this.members.cache.get(user);\n    options.access_token = options.accessToken;\n    if (options.roles) {\n      const roles = [];\n      for (let role of options.roles instanceof Collection ? options.roles.values() : options.roles) {\n        role = this.roles.resolve(role);\n        if (!role) {\n          throw new TypeError('INVALID_TYPE', 'options.roles', 'Array or Collection of Roles or Snowflakes', true);\n        }\n        roles.push(role.id);\n      }\n      options.roles = roles;\n    }\n    const data = await this.client.api.guilds(this.id).members(user).put({ data: options });\n    // Data is an empty buffer if the member is already part of the guild.\n    return data instanceof (browser ? ArrayBuffer : Buffer) ? this.members.fetch(user) : this.members.add(data);\n  }\n\n  /**\n   * The data for editing a guild.\n   * @typedef {Object} GuildEditData\n   * @property {string} [name] The name of the guild\n   * @property {string} [region] The region of the guild\n   * @property {VerificationLevel|number} [verificationLevel] The verification level of the guild\n   * @property {ExplicitContentFilterLevel|number} [explicitContentFilter] The level of the explicit content filter\n   * @property {ChannelResolvable} [afkChannel] The AFK channel of the guild\n   * @property {ChannelResolvable} [systemChannel] The system channel of the guild\n   * @property {number} [afkTimeout] The AFK timeout of the guild\n   * @property {Base64Resolvable} [icon] The icon of the guild\n   * @property {GuildMemberResolvable} [owner] The owner of the guild\n   * @property {Base64Resolvable} [splash] The invite splash image of the guild\n   * @property {Base64Resolvable} [discoverySplash] The discovery splash image of the guild\n   * @property {Base64Resolvable} [banner] The banner of the guild\n   * @property {DefaultMessageNotifications|number} [defaultMessageNotifications] The default message notifications\n   * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The system channel flags of the guild\n   * @property {ChannelResolvable} [rulesChannel] The rules channel of the guild\n   * @property {ChannelResolvable} [publicUpdatesChannel] The community updates channel of the guild\n   * @property {string} [preferredLocale] The preferred locale of the guild\n   */\n\n  /**\n   * Updates the guild with new information - e.g. a new name.\n   * @param {GuildEditData} data The data to update the guild with\n   * @param {string} [reason] Reason for editing this guild\n   * @returns {Promise<Guild>}\n   * @example\n   * // Set the guild name and region\n   * guild.edit({\n   *   name: 'Discord Guild',\n   *   region: 'london',\n   * })\n   *   .then(updated => console.log(`New guild name ${updated} in region ${updated.region}`))\n   *   .catch(console.error);\n   */\n  edit(data, reason) {\n    const _data = {};\n    if (data.name) _data.name = data.name;\n    if (data.region) _data.region = data.region;\n    if (typeof data.verificationLevel !== 'undefined') {\n      _data.verification_level =\n        typeof data.verificationLevel === 'number'\n          ? Number(data.verificationLevel)\n          : VerificationLevels.indexOf(data.verificationLevel);\n    }\n    if (typeof data.afkChannel !== 'undefined') {\n      _data.afk_channel_id = this.client.channels.resolveID(data.afkChannel);\n    }\n    if (typeof data.systemChannel !== 'undefined') {\n      _data.system_channel_id = this.client.channels.resolveID(data.systemChannel);\n    }\n    if (data.afkTimeout) _data.afk_timeout = Number(data.afkTimeout);\n    if (typeof data.icon !== 'undefined') _data.icon = data.icon;\n    if (data.owner) _data.owner_id = this.client.users.resolveID(data.owner);\n    if (data.splash) _data.splash = data.splash;\n    if (data.discoverySplash) _data.discovery_splash = data.discoverySplash;\n    if (data.banner) _data.banner = data.banner;\n    if (typeof data.explicitContentFilter !== 'undefined') {\n      _data.explicit_content_filter =\n        typeof data.explicitContentFilter === 'number'\n          ? data.explicitContentFilter\n          : ExplicitContentFilterLevels.indexOf(data.explicitContentFilter);\n    }\n    if (typeof data.defaultMessageNotifications !== 'undefined') {\n      _data.default_message_notifications =\n        typeof data.defaultMessageNotifications === 'string'\n          ? DefaultMessageNotifications.indexOf(data.defaultMessageNotifications)\n          : data.defaultMessageNotifications;\n    }\n    if (typeof data.systemChannelFlags !== 'undefined') {\n      _data.system_channel_flags = SystemChannelFlags.resolve(data.systemChannelFlags);\n    }\n    if (typeof data.rulesChannel !== 'undefined') {\n      _data.rules_channel_id = this.client.channels.resolveID(data.rulesChannel);\n    }\n    if (typeof data.publicUpdatesChannel !== 'undefined') {\n      _data.public_updates_channel_id = this.client.channels.resolveID(data.publicUpdatesChannel);\n    }\n    if (data.preferredLocale) _data.preferred_locale = data.preferredLocale;\n    return this.client.api\n      .guilds(this.id)\n      .patch({ data: _data, reason })\n      .then(newData => this.client.actions.GuildUpdate.handle(newData).updated);\n  }\n\n  /**\n   * Edits the level of the explicit content filter.\n   * @param {ExplicitContentFilterLevel|number} explicitContentFilter The new level of the explicit content filter\n   * @param {string} [reason] Reason for changing the level of the guild's explicit content filter\n   * @returns {Promise<Guild>}\n   */\n  setExplicitContentFilter(explicitContentFilter, reason) {\n    return this.edit({ explicitContentFilter }, reason);\n  }\n\n  /* eslint-disable max-len */\n  /**\n   * Edits the setting of the default message notifications of the guild.\n   * @param {DefaultMessageNotifications|number} defaultMessageNotifications The new setting for the default message notifications\n   * @param {string} [reason] Reason for changing the setting of the default message notifications\n   * @returns {Promise<Guild>}\n   */\n  setDefaultMessageNotifications(defaultMessageNotifications, reason) {\n    return this.edit({ defaultMessageNotifications }, reason);\n  }\n  /* eslint-enable max-len */\n\n  /**\n   * Edits the flags of the default message notifications of the guild.\n   * @param {SystemChannelFlagsResolvable} systemChannelFlags The new flags for the default message notifications\n   * @param {string} [reason] Reason for changing the flags of the default message notifications\n   * @returns {Promise<Guild>}\n   */\n  setSystemChannelFlags(systemChannelFlags, reason) {\n    return this.edit({ systemChannelFlags }, reason);\n  }\n\n  /**\n   * Edits the name of the guild.\n   * @param {string} name The new name of the guild\n   * @param {string} [reason] Reason for changing the guild's name\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild name\n   * guild.setName('Discord Guild')\n   *  .then(updated => console.log(`Updated guild name to ${updated.name}`))\n   *  .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({ name }, reason);\n  }\n\n  /**\n   * Edits the region of the guild.\n   * @param {string} region The new region of the guild\n   * @param {string} [reason] Reason for changing the guild's region\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild region\n   * guild.setRegion('london')\n   *  .then(updated => console.log(`Updated guild region to ${updated.region}`))\n   *  .catch(console.error);\n   */\n  setRegion(region, reason) {\n    return this.edit({ region }, reason);\n  }\n\n  /**\n   * Edits the verification level of the guild.\n   * @param {VerificationLevel|number} verificationLevel The new verification level of the guild\n   * @param {string} [reason] Reason for changing the guild's verification level\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild verification level\n   * guild.setVerificationLevel(1)\n   *  .then(updated => console.log(`Updated guild verification level to ${guild.verificationLevel}`))\n   *  .catch(console.error);\n   */\n  setVerificationLevel(verificationLevel, reason) {\n    return this.edit({ verificationLevel }, reason);\n  }\n\n  /**\n   * Edits the AFK channel of the guild.\n   * @param {ChannelResolvable} afkChannel The new AFK channel\n   * @param {string} [reason] Reason for changing the guild's AFK channel\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild AFK channel\n   * guild.setAFKChannel(channel)\n   *  .then(updated => console.log(`Updated guild AFK channel to ${guild.afkChannel.name}`))\n   *  .catch(console.error);\n   */\n  setAFKChannel(afkChannel, reason) {\n    return this.edit({ afkChannel }, reason);\n  }\n\n  /**\n   * Edits the system channel of the guild.\n   * @param {ChannelResolvable} systemChannel The new system channel\n   * @param {string} [reason] Reason for changing the guild's system channel\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild system channel\n   * guild.setSystemChannel(channel)\n   *  .then(updated => console.log(`Updated guild system channel to ${guild.systemChannel.name}`))\n   *  .catch(console.error);\n   */\n  setSystemChannel(systemChannel, reason) {\n    return this.edit({ systemChannel }, reason);\n  }\n\n  /**\n   * Edits the AFK timeout of the guild.\n   * @param {number} afkTimeout The time in seconds that a user must be idle to be considered AFK\n   * @param {string} [reason] Reason for changing the guild's AFK timeout\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild AFK channel\n   * guild.setAFKTimeout(60)\n   *  .then(updated => console.log(`Updated guild AFK timeout to ${guild.afkTimeout}`))\n   *  .catch(console.error);\n   */\n  setAFKTimeout(afkTimeout, reason) {\n    return this.edit({ afkTimeout }, reason);\n  }\n\n  /**\n   * Sets a new guild icon.\n   * @param {Base64Resolvable|BufferResolvable} icon The new icon of the guild\n   * @param {string} [reason] Reason for changing the guild's icon\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild icon\n   * guild.setIcon('./icon.png')\n   *  .then(updated => console.log('Updated the guild icon'))\n   *  .catch(console.error);\n   */\n  async setIcon(icon, reason) {\n    return this.edit({ icon: await DataResolver.resolveImage(icon), reason });\n  }\n\n  /**\n   * Sets a new owner of the guild.\n   * @param {GuildMemberResolvable} owner The new owner of the guild\n   * @param {string} [reason] Reason for setting the new owner\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild owner\n   * guild.setOwner(guild.members.cache.first())\n   *  .then(updated => console.log(`Updated the guild owner to ${updated.owner.displayName}`))\n   *  .catch(console.error);\n   */\n  setOwner(owner, reason) {\n    return this.edit({ owner }, reason);\n  }\n\n  /**\n   * Sets a new guild invite splash image.\n   * @param {Base64Resolvable|BufferResolvable} splash The new invite splash image of the guild\n   * @param {string} [reason] Reason for changing the guild's invite splash image\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild splash\n   * guild.setSplash('./splash.png')\n   *  .then(updated => console.log('Updated the guild splash'))\n   *  .catch(console.error);\n   */\n  async setSplash(splash, reason) {\n    return this.edit({ splash: await DataResolver.resolveImage(splash), reason });\n  }\n\n  /**\n   * Sets a new guild discovery splash image.\n   * @param {Base64Resolvable|BufferResolvable} discoverySplash The new discovery splash image of the guild\n   * @param {string} [reason] Reason for changing the guild's discovery splash image\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild discovery splash\n   * guild.setDiscoverySplash('./discoverysplash.png')\n   *   .then(updated => console.log('Updated the guild discovery splash'))\n   *   .catch(console.error);\n   */\n  async setDiscoverySplash(discoverySplash, reason) {\n    return this.edit({ discoverySplash: await DataResolver.resolveImage(discoverySplash), reason });\n  }\n\n  /**\n   * Sets a new guild banner.\n   * @param {Base64Resolvable|BufferResolvable} banner The new banner of the guild\n   * @param {string} [reason] Reason for changing the guild's banner\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.setBanner('./banner.png')\n   *  .then(updated => console.log('Updated the guild banner'))\n   *  .catch(console.error);\n   */\n  async setBanner(banner, reason) {\n    return this.edit({ banner: await DataResolver.resolveImage(banner), reason });\n  }\n\n  /**\n   * Edits the rules channel of the guild.\n   * @param {ChannelResolvable} rulesChannel The new rules channel\n   * @param {string} [reason] Reason for changing the guild's rules channel\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild rules channel\n   * guild.setRulesChannel(channel)\n   *  .then(updated => console.log(`Updated guild rules channel to ${guild.rulesChannel.name}`))\n   *  .catch(console.error);\n   */\n  setRulesChannel(rulesChannel, reason) {\n    return this.edit({ rulesChannel }, reason);\n  }\n\n  /**\n   * Edits the community updates channel of the guild.\n   * @param {ChannelResolvable} publicUpdatesChannel The new community updates channel\n   * @param {string} [reason] Reason for changing the guild's community updates channel\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild community updates channel\n   * guild.setPublicUpdatesChannel(channel)\n   *  .then(updated => console.log(`Updated guild community updates channel to ${guild.publicUpdatesChannel.name}`))\n   *  .catch(console.error);\n   */\n  setPublicUpdatesChannel(publicUpdatesChannel, reason) {\n    return this.edit({ publicUpdatesChannel }, reason);\n  }\n\n  /**\n   * Edits the preferred locale of the guild.\n   * @param {string} preferredLocale The new preferred locale of the guild\n   * @param {string} [reason] Reason for changing the guild's preferred locale\n   * @returns {Promise<Guild>}\n   * @example\n   * // Edit the guild preferred locale\n   * guild.setPreferredLocale('en-US')\n   *  .then(updated => console.log(`Updated guild preferred locale to ${guild.preferredLocale}`))\n   *  .catch(console.error);\n   */\n  setPreferredLocale(preferredLocale, reason) {\n    return this.edit({ preferredLocale }, reason);\n  }\n\n  /**\n   * The data needed for updating a channel's position.\n   * @typedef {Object} ChannelPosition\n   * @property {ChannelResolvable} channel Channel to update\n   * @property {number} position New position for the channel\n   */\n\n  /**\n   * Batch-updates the guild's channels' positions.\n   * @param {ChannelPosition[]} channelPositions Channel positions to update\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.setChannelPositions([{ channel: channelID, position: newChannelIndex }])\n   *   .then(guild => console.log(`Updated channel positions for ${guild}`))\n   *   .catch(console.error);\n   */\n  setChannelPositions(channelPositions) {\n    const updatedChannels = channelPositions.map(r => ({\n      id: this.client.channels.resolveID(r.channel),\n      position: r.position,\n    }));\n\n    return this.client.api\n      .guilds(this.id)\n      .channels.patch({ data: updatedChannels })\n      .then(\n        () =>\n          this.client.actions.GuildChannelsPositionUpdate.handle({\n            guild_id: this.id,\n            channels: updatedChannels,\n          }).guild,\n      );\n  }\n\n  /**\n   * The data needed for updating a guild role's position\n   * @typedef {Object} GuildRolePosition\n   * @property {RoleResolveable} role The ID of the role\n   * @property {number} position The position to update\n   */\n\n  /**\n   * Batch-updates the guild's role positions\n   * @param {GuildRolePosition[]} rolePositions Role positions to update\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.setRolePositions([{ role: roleID, position: updatedRoleIndex }])\n   *  .then(guild => console.log(`Role permissions updated for ${guild}`))\n   *  .catch(console.error);\n   */\n  setRolePositions(rolePositions) {\n    // Make sure rolePositions are prepared for API\n    rolePositions = rolePositions.map(o => ({\n      id: this.roles.resolveID(o.role),\n      position: o.position,\n    }));\n\n    // Call the API to update role positions\n    return this.client.api\n      .guilds(this.id)\n      .roles.patch({\n        data: rolePositions,\n      })\n      .then(\n        () =>\n          this.client.actions.GuildRolesPositionUpdate.handle({\n            guild_id: this.id,\n            roles: rolePositions,\n          }).guild,\n      );\n  }\n\n  /**\n   * Edits the guild's embed.\n   * @param {GuildWidgetData} embed The embed for the guild\n   * @param {string} [reason] Reason for changing the guild's embed\n   * @returns {Promise<Guild>}\n   * @deprecated\n   */\n  setEmbed(embed, reason) {\n    return this.setWidget(embed, reason);\n  }\n\n  /**\n   * Edits the guild's widget.\n   * @param {GuildWidgetData} widget The widget for the guild\n   * @param {string} [reason] Reason for changing the guild's widget\n   * @returns {Promise<Guild>}\n   */\n  setWidget(widget, reason) {\n    return this.client.api\n      .guilds(this.id)\n      .widget.patch({\n        data: {\n          enabled: widget.enabled,\n          channel_id: this.channels.resolveID(widget.channel),\n        },\n        reason,\n      })\n      .then(() => this);\n  }\n\n  /**\n   * Leaves the guild.\n   * @returns {Promise<Guild>}\n   * @example\n   * // Leave a guild\n   * guild.leave()\n   *   .then(g => console.log(`Left the guild ${g}`))\n   *   .catch(console.error);\n   */\n  leave() {\n    if (this.ownerID === this.client.user.id) return Promise.reject(new Error('GUILD_OWNED'));\n    return this.client.api\n      .users('@me')\n      .guilds(this.id)\n      .delete()\n      .then(() => this.client.actions.GuildDelete.handle({ id: this.id }).guild);\n  }\n\n  /**\n   * Deletes the guild.\n   * @returns {Promise<Guild>}\n   * @example\n   * // Delete a guild\n   * guild.delete()\n   *   .then(g => console.log(`Deleted the guild ${g}`))\n   *   .catch(console.error);\n   */\n  delete() {\n    return this.client.api\n      .guilds(this.id)\n      .delete()\n      .then(() => this.client.actions.GuildDelete.handle({ id: this.id }).guild);\n  }\n\n  /**\n   * Whether this guild equals another guild. It compares all properties, so for most operations\n   * it is advisable to just compare `guild.id === guild2.id` as it is much faster and is often\n   * what most users need.\n   * @param {Guild} guild The guild to compare with\n   * @returns {boolean}\n   */\n  equals(guild) {\n    let equal =\n      guild &&\n      guild instanceof this.constructor &&\n      this.id === guild.id &&\n      this.available === guild.available &&\n      this.splash === guild.splash &&\n      this.discoverySplash === guild.discoverySplash &&\n      this.region === guild.region &&\n      this.name === guild.name &&\n      this.memberCount === guild.memberCount &&\n      this.large === guild.large &&\n      this.icon === guild.icon &&\n      this.ownerID === guild.ownerID &&\n      this.verificationLevel === guild.verificationLevel &&\n      this.embedEnabled === guild.embedEnabled &&\n      (this.features === guild.features ||\n        (this.features.length === guild.features.length &&\n          this.features.every((feat, i) => feat === guild.features[i])));\n\n    if (equal) {\n      if (this.embedChannel) {\n        if (!guild.embedChannel || this.embedChannel.id !== guild.embedChannel.id) equal = false;\n      } else if (guild.embedChannel) {\n        equal = false;\n      }\n    }\n\n    return equal;\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the guild's name instead of the Guild object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from My Guild!\n   * console.log(`Hello from ${guild}!`);\n   */\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    const json = super.toJSON({\n      available: false,\n      createdTimestamp: true,\n      nameAcronym: true,\n      presences: false,\n      voiceStates: false,\n    });\n    json.iconURL = this.iconURL();\n    json.splashURL = this.splashURL();\n    json.discoverySplashURL = this.discoverySplashURL();\n    json.bannerURL = this.bannerURL();\n    return json;\n  }\n\n  /**\n   * Creates a collection of this guild's roles, sorted by their position and IDs.\n   * @returns {Collection<Role>}\n   * @private\n   */\n  _sortedRoles() {\n    return Util.discordSort(this.roles.cache);\n  }\n\n  /**\n   * Creates a collection of this guild's or a specific category's channels, sorted by their position and IDs.\n   * @param {GuildChannel} [channel] Category to get the channels of\n   * @returns {Collection<GuildChannel>}\n   * @private\n   */\n  _sortedChannels(channel) {\n    const category = channel.type === ChannelTypes.CATEGORY;\n    return Util.discordSort(\n      this.channels.cache.filter(\n        c =>\n          (['text', 'news', 'store'].includes(channel.type)\n            ? ['text', 'news', 'store'].includes(c.type)\n            : c.type === channel.type) &&\n          (category || c.parent === channel.parent),\n      ),\n    );\n  }\n}\n\nGuild.prototype.setEmbed = deprecate(Guild.prototype.setEmbed, 'Guild#setEmbed: Use setWidget instead');\n\nGuild.prototype.fetchEmbed = deprecate(Guild.prototype.fetchEmbed, 'Guild#fetchEmbed: Use fetchWidget instead');\n\nGuild.prototype.fetchVanityCode = deprecate(\n  Guild.prototype.fetchVanityCode,\n  'Guild#fetchVanityCode: Use fetchVanityData() instead',\n);\n\nmodule.exports = Guild;\n"]},"metadata":{},"sourceType":"script"}