{"ast":null,"code":"'use strict';\n\nconst BaseManager = require('./BaseManager');\n\nconst GuildChannel = require('../structures/GuildChannel');\n\nconst PermissionOverwrites = require('../structures/PermissionOverwrites');\n\nconst {\n  ChannelTypes\n} = require('../util/Constants');\n/**\n * Manages API methods for GuildChannels and stores their cache.\n * @extends {BaseManager}\n */\n\n\nclass GuildChannelManager extends BaseManager {\n  constructor(guild, iterable) {\n    super(guild.client, iterable, GuildChannel);\n    /**\n     * The guild this Manager belongs to\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n  }\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildChannel>}\n   * @name GuildChannelManager#cache\n   */\n\n\n  add(channel) {\n    const existing = this.cache.get(channel.id);\n    if (existing) return existing;\n    this.cache.set(channel.id, channel);\n    return channel;\n  }\n  /**\n   * Data that can be resolved to give a Guild Channel object. This can be:\n   * * A GuildChannel object\n   * * A Snowflake\n   * @typedef {GuildChannel|Snowflake} GuildChannelResolvable\n   */\n\n  /**\n   * Resolves a GuildChannelResolvable to a Channel object.\n   * @method resolve\n   * @memberof GuildChannelManager\n   * @instance\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?GuildChannel}\n   */\n\n  /**\n   * Resolves a GuildChannelResolvable to a channel ID string.\n   * @method resolveID\n   * @memberof GuildChannelManager\n   * @instance\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Creates a new channel in the guild.\n   * @param {string} name The name of the new channel\n   * @param {Object} [options] Options\n   * @param {string} [options.type='text'] The type of the new channel, either `text`, `voice`, or `category`\n   * @param {string} [options.topic] The topic for the new channel\n   * @param {boolean} [options.nsfw] Whether the new channel is nsfw\n   * @param {number} [options.bitrate] Bitrate of the new channel in bits (only voice)\n   * @param {number} [options.userLimit] Maximum amount of users allowed in the new channel (only voice)\n   * @param {ChannelResolvable} [options.parent] Parent of the new channel\n   * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [options.permissionOverwrites]\n   * Permission overwrites of the new channel\n   * @param {number} [options.position] Position of the new channel\n   * @param {number} [options.rateLimitPerUser] The ratelimit per user for the channel\n   * @param {string} [options.reason] Reason for creating the channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Create a new text channel\n   * guild.channels.create('new-general', { reason: 'Needed a cool new channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new channel with permission overwrites\n   * guild.channels.create('new-voice', {\n   *   type: 'voice',\n   *   permissionOverwrites: [\n   *      {\n   *        id: message.author.id,\n   *        deny: ['VIEW_CHANNEL'],\n   *     },\n   *   ],\n   * })\n   */\n\n\n  async create(name) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let {\n      type,\n      topic,\n      nsfw,\n      bitrate,\n      userLimit,\n      parent,\n      permissionOverwrites,\n      position,\n      rateLimitPerUser,\n      reason\n    } = options;\n    if (parent) parent = this.client.channels.resolveID(parent);\n\n    if (permissionOverwrites) {\n      permissionOverwrites = permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n    }\n\n    const data = await this.client.api.guilds(this.guild.id).channels.post({\n      data: {\n        name,\n        topic,\n        type: type ? ChannelTypes[type.toUpperCase()] : ChannelTypes.TEXT,\n        nsfw,\n        bitrate,\n        user_limit: userLimit,\n        parent_id: parent,\n        position,\n        permission_overwrites: permissionOverwrites,\n        rate_limit_per_user: rateLimitPerUser\n      },\n      reason\n    });\n    return this.client.actions.ChannelCreate.handle(data).channel;\n  }\n\n}\n\nmodule.exports = GuildChannelManager;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/managers/GuildChannelManager.js"],"names":["BaseManager","require","GuildChannel","PermissionOverwrites","ChannelTypes","GuildChannelManager","constructor","guild","iterable","client","add","channel","existing","cache","get","id","set","create","name","options","type","topic","nsfw","bitrate","userLimit","parent","permissionOverwrites","position","rateLimitPerUser","reason","channels","resolveID","map","o","resolve","data","api","guilds","post","toUpperCase","TEXT","user_limit","parent_id","permission_overwrites","rate_limit_per_user","actions","ChannelCreate","handle","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst BaseManager = require('./BaseManager');\nconst GuildChannel = require('../structures/GuildChannel');\nconst PermissionOverwrites = require('../structures/PermissionOverwrites');\nconst { ChannelTypes } = require('../util/Constants');\n\n/**\n * Manages API methods for GuildChannels and stores their cache.\n * @extends {BaseManager}\n */\nclass GuildChannelManager extends BaseManager {\n  constructor(guild, iterable) {\n    super(guild.client, iterable, GuildChannel);\n\n    /**\n     * The guild this Manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildChannel>}\n   * @name GuildChannelManager#cache\n   */\n\n  add(channel) {\n    const existing = this.cache.get(channel.id);\n    if (existing) return existing;\n    this.cache.set(channel.id, channel);\n    return channel;\n  }\n\n  /**\n   * Data that can be resolved to give a Guild Channel object. This can be:\n   * * A GuildChannel object\n   * * A Snowflake\n   * @typedef {GuildChannel|Snowflake} GuildChannelResolvable\n   */\n\n  /**\n   * Resolves a GuildChannelResolvable to a Channel object.\n   * @method resolve\n   * @memberof GuildChannelManager\n   * @instance\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?GuildChannel}\n   */\n\n  /**\n   * Resolves a GuildChannelResolvable to a channel ID string.\n   * @method resolveID\n   * @memberof GuildChannelManager\n   * @instance\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Creates a new channel in the guild.\n   * @param {string} name The name of the new channel\n   * @param {Object} [options] Options\n   * @param {string} [options.type='text'] The type of the new channel, either `text`, `voice`, or `category`\n   * @param {string} [options.topic] The topic for the new channel\n   * @param {boolean} [options.nsfw] Whether the new channel is nsfw\n   * @param {number} [options.bitrate] Bitrate of the new channel in bits (only voice)\n   * @param {number} [options.userLimit] Maximum amount of users allowed in the new channel (only voice)\n   * @param {ChannelResolvable} [options.parent] Parent of the new channel\n   * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [options.permissionOverwrites]\n   * Permission overwrites of the new channel\n   * @param {number} [options.position] Position of the new channel\n   * @param {number} [options.rateLimitPerUser] The ratelimit per user for the channel\n   * @param {string} [options.reason] Reason for creating the channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Create a new text channel\n   * guild.channels.create('new-general', { reason: 'Needed a cool new channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new channel with permission overwrites\n   * guild.channels.create('new-voice', {\n   *   type: 'voice',\n   *   permissionOverwrites: [\n   *      {\n   *        id: message.author.id,\n   *        deny: ['VIEW_CHANNEL'],\n   *     },\n   *   ],\n   * })\n   */\n  async create(name, options = {}) {\n    let {\n      type,\n      topic,\n      nsfw,\n      bitrate,\n      userLimit,\n      parent,\n      permissionOverwrites,\n      position,\n      rateLimitPerUser,\n      reason,\n    } = options;\n    if (parent) parent = this.client.channels.resolveID(parent);\n    if (permissionOverwrites) {\n      permissionOverwrites = permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n    }\n\n    const data = await this.client.api.guilds(this.guild.id).channels.post({\n      data: {\n        name,\n        topic,\n        type: type ? ChannelTypes[type.toUpperCase()] : ChannelTypes.TEXT,\n        nsfw,\n        bitrate,\n        user_limit: userLimit,\n        parent_id: parent,\n        position,\n        permission_overwrites: permissionOverwrites,\n        rate_limit_per_user: rateLimitPerUser,\n      },\n      reason,\n    });\n    return this.client.actions.ChannelCreate.handle(data).channel;\n  }\n}\n\nmodule.exports = GuildChannelManager;\n"]},"metadata":{},"sourceType":"script"}