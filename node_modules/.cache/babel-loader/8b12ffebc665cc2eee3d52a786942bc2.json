{"ast":null,"code":"'use strict';\n\nconst BaseGuildEmoji = require('./BaseGuildEmoji');\n\nconst {\n  Error\n} = require('../errors');\n\nconst GuildEmojiRoleManager = require('../managers/GuildEmojiRoleManager');\n\nconst Permissions = require('../util/Permissions');\n/**\n * Represents a custom emoji.\n * @extends {BaseGuildEmoji}\n */\n\n\nclass GuildEmoji extends BaseGuildEmoji {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the guild emoji\n   * @param {Guild} guild The guild the guild emoji is part of\n   */\n  constructor(client, data, guild) {\n    super(client, data, guild);\n    /**\n     * The user who created this emoji\n     * @type {?User}\n     */\n\n    this.author = null;\n  }\n  /**\n   * The guild this emoji is part of\n   * @type {Guild}\n   * @name GuildEmoji#guild\n   */\n\n\n  _clone() {\n    const clone = super._clone();\n\n    clone._roles = this._roles.slice();\n    return clone;\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if (typeof data.user !== 'undefined') this.author = this.client.users.add(data.user);\n  }\n  /**\n   * Whether the emoji is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get deletable() {\n    if (!this.guild.me) throw new Error('GUILD_UNCACHED_ME');\n    return !this.managed && this.guild.me.hasPermission(Permissions.FLAGS.MANAGE_EMOJIS);\n  }\n  /**\n   * A manager for roles this emoji is active for.\n   * @type {GuildEmojiRoleManager}\n   * @readonly\n   */\n\n\n  get roles() {\n    return new GuildEmojiRoleManager(this);\n  }\n  /**\n   * Fetches the author for this emoji\n   * @returns {Promise<User>}\n   */\n\n\n  async fetchAuthor() {\n    if (this.managed) {\n      throw new Error('EMOJI_MANAGED');\n    } else {\n      if (!this.guild.me) throw new Error('GUILD_UNCACHED_ME');\n\n      if (!this.guild.me.permissions.has(Permissions.FLAGS.MANAGE_EMOJIS)) {\n        throw new Error('MISSING_MANAGE_EMOJIS_PERMISSION', this.guild);\n      }\n    }\n\n    const data = await this.client.api.guilds(this.guild.id).emojis(this.id).get();\n\n    this._patch(data);\n\n    return this.author;\n  }\n  /**\n   * Data for editing an emoji.\n   * @typedef {Object} GuildEmojiEditData\n   * @property {string} [name] The name of the emoji\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] Roles to restrict emoji to\n   */\n\n  /**\n   * Edits the emoji.\n   * @param {GuildEmojiEditData} data The new data for the emoji\n   * @param {string} [reason] Reason for editing this emoji\n   * @returns {Promise<GuildEmoji>}\n   * @example\n   * // Edit an emoji\n   * emoji.edit({ name: 'newemoji' })\n   *   .then(e => console.log(`Edited emoji ${e}`))\n   *   .catch(console.error);\n   */\n\n\n  edit(data, reason) {\n    const roles = data.roles ? data.roles.map(r => r.id || r) : undefined;\n    return this.client.api.guilds(this.guild.id).emojis(this.id).patch({\n      data: {\n        name: data.name,\n        roles\n      },\n      reason\n    }).then(newData => {\n      const clone = this._clone();\n\n      clone._patch(newData);\n\n      return clone;\n    });\n  }\n  /**\n   * Sets the name of the emoji.\n   * @param {string} name The new name for the emoji\n   * @param {string} [reason] Reason for changing the emoji's name\n   * @returns {Promise<GuildEmoji>}\n   */\n\n\n  setName(name, reason) {\n    return this.edit({\n      name\n    }, reason);\n  }\n  /**\n   * Deletes the emoji.\n   * @param {string} [reason] Reason for deleting the emoji\n   * @returns {Promise<GuildEmoji>}\n   */\n\n\n  delete(reason) {\n    return this.client.api.guilds(this.guild.id).emojis(this.id).delete({\n      reason\n    }).then(() => this);\n  }\n  /**\n   * Whether this emoji is the same as another one.\n   * @param {GuildEmoji|Object} other The emoji to compare it to\n   * @returns {boolean} Whether the emoji is equal to the given emoji or not\n   */\n\n\n  equals(other) {\n    if (other instanceof GuildEmoji) {\n      return other.id === this.id && other.name === this.name && other.managed === this.managed && other.requiresColons === this.requiresColons && other.roles.cache.size === this.roles.cache.size && other.roles.cache.every(role => this.roles.cache.has(role.id));\n    } else {\n      return other.id === this.id && other.name === this.name && other.roles.length === this.roles.cache.size && other.roles.every(role => this.roles.cache.has(role));\n    }\n  }\n\n}\n\nmodule.exports = GuildEmoji;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/structures/GuildEmoji.js"],"names":["BaseGuildEmoji","require","Error","GuildEmojiRoleManager","Permissions","GuildEmoji","constructor","client","data","guild","author","_clone","clone","_roles","slice","_patch","user","users","add","deletable","me","managed","hasPermission","FLAGS","MANAGE_EMOJIS","roles","fetchAuthor","permissions","has","api","guilds","id","emojis","get","edit","reason","map","r","undefined","patch","name","then","newData","setName","delete","equals","other","requiresColons","cache","size","every","role","length","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst BaseGuildEmoji = require('./BaseGuildEmoji');\nconst { Error } = require('../errors');\nconst GuildEmojiRoleManager = require('../managers/GuildEmojiRoleManager');\nconst Permissions = require('../util/Permissions');\n\n/**\n * Represents a custom emoji.\n * @extends {BaseGuildEmoji}\n */\nclass GuildEmoji extends BaseGuildEmoji {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the guild emoji\n   * @param {Guild} guild The guild the guild emoji is part of\n   */\n  constructor(client, data, guild) {\n    super(client, data, guild);\n\n    /**\n     * The user who created this emoji\n     * @type {?User}\n     */\n    this.author = null;\n  }\n\n  /**\n   * The guild this emoji is part of\n   * @type {Guild}\n   * @name GuildEmoji#guild\n   */\n\n  _clone() {\n    const clone = super._clone();\n    clone._roles = this._roles.slice();\n    return clone;\n  }\n\n  _patch(data) {\n    super._patch(data);\n    if (typeof data.user !== 'undefined') this.author = this.client.users.add(data.user);\n  }\n\n  /**\n   * Whether the emoji is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    if (!this.guild.me) throw new Error('GUILD_UNCACHED_ME');\n    return !this.managed && this.guild.me.hasPermission(Permissions.FLAGS.MANAGE_EMOJIS);\n  }\n\n  /**\n   * A manager for roles this emoji is active for.\n   * @type {GuildEmojiRoleManager}\n   * @readonly\n   */\n  get roles() {\n    return new GuildEmojiRoleManager(this);\n  }\n\n  /**\n   * Fetches the author for this emoji\n   * @returns {Promise<User>}\n   */\n  async fetchAuthor() {\n    if (this.managed) {\n      throw new Error('EMOJI_MANAGED');\n    } else {\n      if (!this.guild.me) throw new Error('GUILD_UNCACHED_ME');\n      if (!this.guild.me.permissions.has(Permissions.FLAGS.MANAGE_EMOJIS)) {\n        throw new Error('MISSING_MANAGE_EMOJIS_PERMISSION', this.guild);\n      }\n    }\n    const data = await this.client.api.guilds(this.guild.id).emojis(this.id).get();\n    this._patch(data);\n    return this.author;\n  }\n\n  /**\n   * Data for editing an emoji.\n   * @typedef {Object} GuildEmojiEditData\n   * @property {string} [name] The name of the emoji\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] Roles to restrict emoji to\n   */\n\n  /**\n   * Edits the emoji.\n   * @param {GuildEmojiEditData} data The new data for the emoji\n   * @param {string} [reason] Reason for editing this emoji\n   * @returns {Promise<GuildEmoji>}\n   * @example\n   * // Edit an emoji\n   * emoji.edit({ name: 'newemoji' })\n   *   .then(e => console.log(`Edited emoji ${e}`))\n   *   .catch(console.error);\n   */\n  edit(data, reason) {\n    const roles = data.roles ? data.roles.map(r => r.id || r) : undefined;\n    return this.client.api\n      .guilds(this.guild.id)\n      .emojis(this.id)\n      .patch({\n        data: {\n          name: data.name,\n          roles,\n        },\n        reason,\n      })\n      .then(newData => {\n        const clone = this._clone();\n        clone._patch(newData);\n        return clone;\n      });\n  }\n\n  /**\n   * Sets the name of the emoji.\n   * @param {string} name The new name for the emoji\n   * @param {string} [reason] Reason for changing the emoji's name\n   * @returns {Promise<GuildEmoji>}\n   */\n  setName(name, reason) {\n    return this.edit({ name }, reason);\n  }\n\n  /**\n   * Deletes the emoji.\n   * @param {string} [reason] Reason for deleting the emoji\n   * @returns {Promise<GuildEmoji>}\n   */\n  delete(reason) {\n    return this.client.api\n      .guilds(this.guild.id)\n      .emojis(this.id)\n      .delete({ reason })\n      .then(() => this);\n  }\n\n  /**\n   * Whether this emoji is the same as another one.\n   * @param {GuildEmoji|Object} other The emoji to compare it to\n   * @returns {boolean} Whether the emoji is equal to the given emoji or not\n   */\n  equals(other) {\n    if (other instanceof GuildEmoji) {\n      return (\n        other.id === this.id &&\n        other.name === this.name &&\n        other.managed === this.managed &&\n        other.requiresColons === this.requiresColons &&\n        other.roles.cache.size === this.roles.cache.size &&\n        other.roles.cache.every(role => this.roles.cache.has(role.id))\n      );\n    } else {\n      return (\n        other.id === this.id &&\n        other.name === this.name &&\n        other.roles.length === this.roles.cache.size &&\n        other.roles.every(role => this.roles.cache.has(role))\n      );\n    }\n  }\n}\n\nmodule.exports = GuildEmoji;\n"]},"metadata":{},"sourceType":"script"}