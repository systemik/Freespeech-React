{"ast":null,"code":"'use strict';\n\nconst Action = require('./Action');\n\nconst {\n  Events\n} = require('../../util/Constants');\n\nclass PresenceUpdateAction extends Action {\n  handle(data) {\n    let user = this.client.users.cache.get(data.user.id);\n    if (!user && data.user.username) user = this.client.users.add(data.user);\n    if (!user) return;\n\n    if (data.user && data.user.username) {\n      if (!user.equals(data.user)) this.client.actions.UserUpdate.handle(data.user);\n    }\n\n    const guild = this.client.guilds.cache.get(data.guild_id);\n    if (!guild) return;\n    let oldPresence = guild.presences.cache.get(user.id);\n    if (oldPresence) oldPresence = oldPresence._clone();\n    let member = guild.members.cache.get(user.id);\n\n    if (!member && data.status !== 'offline') {\n      member = guild.members.add({\n        user,\n        roles: data.roles,\n        deaf: false,\n        mute: false\n      });\n      this.client.emit(Events.GUILD_MEMBER_AVAILABLE, member);\n    }\n\n    guild.presences.add(Object.assign(data, {\n      guild\n    }));\n\n    if (member && this.client.listenerCount(Events.PRESENCE_UPDATE)) {\n      /**\n       * Emitted whenever a guild member's presence (e.g. status, activity) is changed.\n       * @event Client#presenceUpdate\n       * @param {?Presence} oldPresence The presence before the update, if one at all\n       * @param {Presence} newPresence The presence after the update\n       */\n      this.client.emit(Events.PRESENCE_UPDATE, oldPresence, member.presence);\n    }\n  }\n\n}\n\nmodule.exports = PresenceUpdateAction;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/client/actions/PresenceUpdate.js"],"names":["Action","require","Events","PresenceUpdateAction","handle","data","user","client","users","cache","get","id","username","add","equals","actions","UserUpdate","guild","guilds","guild_id","oldPresence","presences","_clone","member","members","status","roles","deaf","mute","emit","GUILD_MEMBER_AVAILABLE","Object","assign","listenerCount","PRESENCE_UPDATE","presence","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAaD,OAAO,CAAC,sBAAD,CAA1B;;AAEA,MAAME,oBAAN,SAAmCH,MAAnC,CAA0C;AACxCI,EAAAA,MAAM,CAACC,IAAD,EAAO;AACX,QAAIC,IAAI,GAAG,KAAKC,MAAL,CAAYC,KAAZ,CAAkBC,KAAlB,CAAwBC,GAAxB,CAA4BL,IAAI,CAACC,IAAL,CAAUK,EAAtC,CAAX;AACA,QAAI,CAACL,IAAD,IAASD,IAAI,CAACC,IAAL,CAAUM,QAAvB,EAAiCN,IAAI,GAAG,KAAKC,MAAL,CAAYC,KAAZ,CAAkBK,GAAlB,CAAsBR,IAAI,CAACC,IAA3B,CAAP;AACjC,QAAI,CAACA,IAAL,EAAW;;AAEX,QAAID,IAAI,CAACC,IAAL,IAAaD,IAAI,CAACC,IAAL,CAAUM,QAA3B,EAAqC;AACnC,UAAI,CAACN,IAAI,CAACQ,MAAL,CAAYT,IAAI,CAACC,IAAjB,CAAL,EAA6B,KAAKC,MAAL,CAAYQ,OAAZ,CAAoBC,UAApB,CAA+BZ,MAA/B,CAAsCC,IAAI,CAACC,IAA3C;AAC9B;;AAED,UAAMW,KAAK,GAAG,KAAKV,MAAL,CAAYW,MAAZ,CAAmBT,KAAnB,CAAyBC,GAAzB,CAA6BL,IAAI,CAACc,QAAlC,CAAd;AACA,QAAI,CAACF,KAAL,EAAY;AAEZ,QAAIG,WAAW,GAAGH,KAAK,CAACI,SAAN,CAAgBZ,KAAhB,CAAsBC,GAAtB,CAA0BJ,IAAI,CAACK,EAA/B,CAAlB;AACA,QAAIS,WAAJ,EAAiBA,WAAW,GAAGA,WAAW,CAACE,MAAZ,EAAd;AACjB,QAAIC,MAAM,GAAGN,KAAK,CAACO,OAAN,CAAcf,KAAd,CAAoBC,GAApB,CAAwBJ,IAAI,CAACK,EAA7B,CAAb;;AACA,QAAI,CAACY,MAAD,IAAWlB,IAAI,CAACoB,MAAL,KAAgB,SAA/B,EAA0C;AACxCF,MAAAA,MAAM,GAAGN,KAAK,CAACO,OAAN,CAAcX,GAAd,CAAkB;AACzBP,QAAAA,IADyB;AAEzBoB,QAAAA,KAAK,EAAErB,IAAI,CAACqB,KAFa;AAGzBC,QAAAA,IAAI,EAAE,KAHmB;AAIzBC,QAAAA,IAAI,EAAE;AAJmB,OAAlB,CAAT;AAMA,WAAKrB,MAAL,CAAYsB,IAAZ,CAAiB3B,MAAM,CAAC4B,sBAAxB,EAAgDP,MAAhD;AACD;;AACDN,IAAAA,KAAK,CAACI,SAAN,CAAgBR,GAAhB,CAAoBkB,MAAM,CAACC,MAAP,CAAc3B,IAAd,EAAoB;AAAEY,MAAAA;AAAF,KAApB,CAApB;;AACA,QAAIM,MAAM,IAAI,KAAKhB,MAAL,CAAY0B,aAAZ,CAA0B/B,MAAM,CAACgC,eAAjC,CAAd,EAAiE;AAC/D;AACN;AACA;AACA;AACA;AACA;AACM,WAAK3B,MAAL,CAAYsB,IAAZ,CAAiB3B,MAAM,CAACgC,eAAxB,EAAyCd,WAAzC,EAAsDG,MAAM,CAACY,QAA7D;AACD;AACF;;AAnCuC;;AAsC1CC,MAAM,CAACC,OAAP,GAAiBlC,oBAAjB","sourcesContent":["'use strict';\n\nconst Action = require('./Action');\nconst { Events } = require('../../util/Constants');\n\nclass PresenceUpdateAction extends Action {\n  handle(data) {\n    let user = this.client.users.cache.get(data.user.id);\n    if (!user && data.user.username) user = this.client.users.add(data.user);\n    if (!user) return;\n\n    if (data.user && data.user.username) {\n      if (!user.equals(data.user)) this.client.actions.UserUpdate.handle(data.user);\n    }\n\n    const guild = this.client.guilds.cache.get(data.guild_id);\n    if (!guild) return;\n\n    let oldPresence = guild.presences.cache.get(user.id);\n    if (oldPresence) oldPresence = oldPresence._clone();\n    let member = guild.members.cache.get(user.id);\n    if (!member && data.status !== 'offline') {\n      member = guild.members.add({\n        user,\n        roles: data.roles,\n        deaf: false,\n        mute: false,\n      });\n      this.client.emit(Events.GUILD_MEMBER_AVAILABLE, member);\n    }\n    guild.presences.add(Object.assign(data, { guild }));\n    if (member && this.client.listenerCount(Events.PRESENCE_UPDATE)) {\n      /**\n       * Emitted whenever a guild member's presence (e.g. status, activity) is changed.\n       * @event Client#presenceUpdate\n       * @param {?Presence} oldPresence The presence before the update, if one at all\n       * @param {Presence} newPresence The presence after the update\n       */\n      this.client.emit(Events.PRESENCE_UPDATE, oldPresence, member.presence);\n    }\n  }\n}\n\nmodule.exports = PresenceUpdateAction;\n"]},"metadata":{},"sourceType":"script"}