{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst WebSocket = require('../../WebSocket');\n\nconst {\n  browser,\n  Status,\n  Events,\n  ShardEvents,\n  OPCodes,\n  WSEvents\n} = require('../../util/Constants');\n\nconst STATUS_KEYS = Object.keys(Status);\nconst CONNECTION_STATE = Object.keys(WebSocket.WebSocket);\nlet zlib;\n\nif (!browser) {\n  try {\n    zlib = require('zlib-sync');\n  } catch {} // eslint-disable-line no-empty\n\n}\n/**\n * Represents a Shard's WebSocket connection\n */\n\n\nclass WebSocketShard extends EventEmitter {\n  constructor(manager, id) {\n    super();\n    /**\n     * The WebSocketManager of the shard\n     * @type {WebSocketManager}\n     */\n\n    this.manager = manager;\n    /**\n     * The ID of the shard\n     * @type {number}\n     */\n\n    this.id = id;\n    /**\n     * The current status of the shard\n     * @type {Status}\n     */\n\n    this.status = Status.IDLE;\n    /**\n     * The current sequence of the shard\n     * @type {number}\n     * @private\n     */\n\n    this.sequence = -1;\n    /**\n     * The sequence of the shard after close\n     * @type {number}\n     * @private\n     */\n\n    this.closeSequence = 0;\n    /**\n     * The current session ID of the shard\n     * @type {?string}\n     * @private\n     */\n\n    this.sessionID = null;\n    /**\n     * The previous heartbeat ping of the shard\n     * @type {number}\n     */\n\n    this.ping = -1;\n    /**\n     * The last time a ping was sent (a timestamp)\n     * @type {number}\n     * @private\n     */\n\n    this.lastPingTimestamp = -1;\n    /**\n     * If we received a heartbeat ack back. Used to identify zombie connections\n     * @type {boolean}\n     * @private\n     */\n\n    this.lastHeartbeatAcked = true;\n    /**\n     * Contains the rate limit queue and metadata\n     * @name WebSocketShard#ratelimit\n     * @type {Object}\n     * @private\n     */\n\n    Object.defineProperty(this, 'ratelimit', {\n      value: {\n        queue: [],\n        total: 120,\n        remaining: 120,\n        time: 60e3,\n        timer: null\n      }\n    });\n    /**\n     * The WebSocket connection for the current shard\n     * @name WebSocketShard#connection\n     * @type {?WebSocket}\n     * @private\n     */\n\n    Object.defineProperty(this, 'connection', {\n      value: null,\n      writable: true\n    });\n    /**\n     * @external Inflate\n     * @see {@link https://www.npmjs.com/package/zlib-sync}\n     */\n\n    /**\n     * The compression to use\n     * @name WebSocketShard#inflate\n     * @type {?Inflate}\n     * @private\n     */\n\n    Object.defineProperty(this, 'inflate', {\n      value: null,\n      writable: true\n    });\n    /**\n     * The HELLO timeout\n     * @name WebSocketShard#helloTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n\n    Object.defineProperty(this, 'helloTimeout', {\n      value: null,\n      writable: true\n    });\n    /**\n     * If the manager attached its event handlers on the shard\n     * @name WebSocketShard#eventsAttached\n     * @type {boolean}\n     * @private\n     */\n\n    Object.defineProperty(this, 'eventsAttached', {\n      value: false,\n      writable: true\n    });\n    /**\n     * A set of guild IDs this shard expects to receive\n     * @name WebSocketShard#expectedGuilds\n     * @type {?Set<string>}\n     * @private\n     */\n\n    Object.defineProperty(this, 'expectedGuilds', {\n      value: null,\n      writable: true\n    });\n    /**\n     * The ready timeout\n     * @name WebSocketShard#readyTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n\n    Object.defineProperty(this, 'readyTimeout', {\n      value: null,\n      writable: true\n    });\n    /**\n     * Time when the WebSocket connection was opened\n     * @name WebSocketShard#connectedAt\n     * @type {number}\n     * @private\n     */\n\n    Object.defineProperty(this, 'connectedAt', {\n      value: 0,\n      writable: true\n    });\n  }\n  /**\n   * Emits a debug event.\n   * @param {string} message The debug message\n   * @private\n   */\n\n\n  debug(message) {\n    this.manager.debug(message, this);\n  }\n  /**\n   * Connects the shard to the gateway.\n   * @private\n   * @returns {Promise<void>} A promise that will resolve if the shard turns ready successfully,\n   * or reject if we couldn't connect\n   */\n\n\n  connect() {\n    const {\n      gateway,\n      client\n    } = this.manager;\n\n    if (this.connection && this.connection.readyState === WebSocket.OPEN && this.status === Status.READY) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve, reject) => {\n      const cleanup = () => {\n        this.removeListener(ShardEvents.CLOSE, onClose);\n        this.removeListener(ShardEvents.READY, onReady);\n        this.removeListener(ShardEvents.RESUMED, onResumed);\n        this.removeListener(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);\n        this.removeListener(ShardEvents.DESTROYED, onInvalidOrDestroyed);\n      };\n\n      const onReady = () => {\n        cleanup();\n        resolve();\n      };\n\n      const onResumed = () => {\n        cleanup();\n        resolve();\n      };\n\n      const onClose = event => {\n        cleanup();\n        reject(event);\n      };\n\n      const onInvalidOrDestroyed = () => {\n        cleanup(); // eslint-disable-next-line prefer-promise-reject-errors\n\n        reject();\n      };\n\n      this.once(ShardEvents.READY, onReady);\n      this.once(ShardEvents.RESUMED, onResumed);\n      this.once(ShardEvents.CLOSE, onClose);\n      this.once(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);\n      this.once(ShardEvents.DESTROYED, onInvalidOrDestroyed);\n\n      if (this.connection && this.connection.readyState === WebSocket.OPEN) {\n        this.debug('An open connection was found, attempting an immediate identify.');\n        this.identify();\n        return;\n      }\n\n      if (this.connection) {\n        this.debug(`A connection object was found. Cleaning up before continuing.\n    State: ${CONNECTION_STATE[this.connection.readyState]}`);\n        this.destroy({\n          emit: false\n        });\n      }\n\n      const wsQuery = {\n        v: client.options.ws.version\n      };\n\n      if (zlib) {\n        this.inflate = new zlib.Inflate({\n          chunkSize: 65535,\n          flush: zlib.Z_SYNC_FLUSH,\n          to: WebSocket.encoding === 'json' ? 'string' : ''\n        });\n        wsQuery.compress = 'zlib-stream';\n      }\n\n      this.debug(`[CONNECT]\n    Gateway    : ${gateway}\n    Version    : ${client.options.ws.version}\n    Encoding   : ${WebSocket.encoding}\n    Compression: ${zlib ? 'zlib-stream' : 'none'}`);\n      this.status = this.status === Status.DISCONNECTED ? Status.RECONNECTING : Status.CONNECTING;\n      this.setHelloTimeout();\n      this.connectedAt = Date.now();\n      const ws = this.connection = WebSocket.create(gateway, wsQuery);\n      ws.onopen = this.onOpen.bind(this);\n      ws.onmessage = this.onMessage.bind(this);\n      ws.onerror = this.onError.bind(this);\n      ws.onclose = this.onClose.bind(this);\n    });\n  }\n  /**\n   * Called whenever a connection is opened to the gateway.\n   * @private\n   */\n\n\n  onOpen() {\n    this.debug(`[CONNECTED] ${this.connection.url} in ${Date.now() - this.connectedAt}ms`);\n    this.status = Status.NEARLY;\n  }\n  /**\n   * Called whenever a message is received.\n   * @param {MessageEvent} event Event received\n   * @private\n   */\n\n\n  onMessage(_ref) {\n    let {\n      data\n    } = _ref;\n    let raw;\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data);\n\n    if (zlib) {\n      const l = data.length;\n      const flush = l >= 4 && data[l - 4] === 0x00 && data[l - 3] === 0x00 && data[l - 2] === 0xff && data[l - 1] === 0xff;\n      this.inflate.push(data, flush && zlib.Z_SYNC_FLUSH);\n      if (!flush) return;\n      raw = this.inflate.result;\n    } else {\n      raw = data;\n    }\n\n    let packet;\n\n    try {\n      packet = WebSocket.unpack(raw);\n      this.manager.client.emit(Events.RAW, packet, this.id);\n      if (packet.op === OPCodes.DISPATCH) this.manager.emit(packet.t, packet.d, this.id);\n    } catch (err) {\n      this.manager.client.emit(Events.SHARD_ERROR, err, this.id);\n      return;\n    }\n\n    this.onPacket(packet);\n  }\n  /**\n   * Called whenever an error occurs with the WebSocket.\n   * @param {ErrorEvent} event The error that occurred\n   * @private\n   */\n\n\n  onError(event) {\n    const error = event && event.error ? event.error : event;\n    if (!error) return;\n    /**\n     * Emitted whenever a shard's WebSocket encounters a connection error.\n     * @event Client#shardError\n     * @param {Error} error The encountered error\n     * @param {number} shardID The shard that encountered this error\n     */\n\n    this.manager.client.emit(Events.SHARD_ERROR, error, this.id);\n  }\n  /**\n   * @external CloseEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\n   */\n\n  /**\n   * @external ErrorEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent}\n   */\n\n  /**\n   * @external MessageEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n   */\n\n  /**\n   * Called whenever a connection to the gateway is closed.\n   * @param {CloseEvent} event Close event that was received\n   * @private\n   */\n\n\n  onClose(event) {\n    if (this.sequence !== -1) this.closeSequence = this.sequence;\n    this.sequence = -1;\n    this.debug(`[CLOSE]\n    Event Code: ${event.code}\n    Clean     : ${event.wasClean}\n    Reason    : ${event.reason || 'No reason received'}`);\n    this.setHeartbeatTimer(-1);\n    this.setHelloTimeout(-1); // If we still have a connection object, clean up its listeners\n\n    if (this.connection) this._cleanupConnection();\n    this.status = Status.DISCONNECTED;\n    /**\n     * Emitted when a shard's WebSocket closes.\n     * @private\n     * @event WebSocketShard#close\n     * @param {CloseEvent} event The received event\n     */\n\n    this.emit(ShardEvents.CLOSE, event);\n  }\n  /**\n   * Called whenever a packet is received.\n   * @param {Object} packet The received packet\n   * @private\n   */\n\n\n  onPacket(packet) {\n    if (!packet) {\n      this.debug(`Received broken packet: '${packet}'.`);\n      return;\n    }\n\n    switch (packet.t) {\n      case WSEvents.READY:\n        /**\n         * Emitted when the shard receives the READY payload and is now waiting for guilds\n         * @event WebSocketShard#ready\n         */\n        this.emit(ShardEvents.READY);\n        this.sessionID = packet.d.session_id;\n        this.expectedGuilds = new Set(packet.d.guilds.map(d => d.id));\n        this.status = Status.WAITING_FOR_GUILDS;\n        this.debug(`[READY] Session ${this.sessionID}.`);\n        this.lastHeartbeatAcked = true;\n        this.sendHeartbeat('ReadyHeartbeat');\n        break;\n\n      case WSEvents.RESUMED:\n        {\n          /**\n           * Emitted when the shard resumes successfully\n           * @event WebSocketShard#resumed\n           */\n          this.emit(ShardEvents.RESUMED);\n          this.status = Status.READY;\n          const replayed = packet.s - this.closeSequence;\n          this.debug(`[RESUMED] Session ${this.sessionID} | Replayed ${replayed} events.`);\n          this.lastHeartbeatAcked = true;\n          this.sendHeartbeat('ResumeHeartbeat');\n          break;\n        }\n    }\n\n    if (packet.s > this.sequence) this.sequence = packet.s;\n\n    switch (packet.op) {\n      case OPCodes.HELLO:\n        this.setHelloTimeout(-1);\n        this.setHeartbeatTimer(packet.d.heartbeat_interval);\n        this.identify();\n        break;\n\n      case OPCodes.RECONNECT:\n        this.debug('[RECONNECT] Discord asked us to reconnect');\n        this.destroy({\n          closeCode: 4000\n        });\n        break;\n\n      case OPCodes.INVALID_SESSION:\n        this.debug(`[INVALID SESSION] Resumable: ${packet.d}.`); // If we can resume the session, do so immediately\n\n        if (packet.d) {\n          this.identifyResume();\n          return;\n        } // Reset the sequence\n\n\n        this.sequence = -1; // Reset the session ID as it's invalid\n\n        this.sessionID = null; // Set the status to reconnecting\n\n        this.status = Status.RECONNECTING; // Finally, emit the INVALID_SESSION event\n\n        this.emit(ShardEvents.INVALID_SESSION);\n        break;\n\n      case OPCodes.HEARTBEAT_ACK:\n        this.ackHeartbeat();\n        break;\n\n      case OPCodes.HEARTBEAT:\n        this.sendHeartbeat('HeartbeatRequest', true);\n        break;\n\n      default:\n        this.manager.handlePacket(packet, this);\n\n        if (this.status === Status.WAITING_FOR_GUILDS && packet.t === WSEvents.GUILD_CREATE) {\n          this.expectedGuilds.delete(packet.d.id);\n          this.checkReady();\n        }\n\n    }\n  }\n  /**\n   * Checks if the shard can be marked as ready\n   * @private\n   */\n\n\n  checkReady() {\n    // Step 0. Clear the ready timeout, if it exists\n    if (this.readyTimeout) {\n      this.manager.client.clearTimeout(this.readyTimeout);\n      this.readyTimeout = null;\n    } // Step 1. If we don't have any other guilds pending, we are ready\n\n\n    if (!this.expectedGuilds.size) {\n      this.debug('Shard received all its guilds. Marking as fully ready.');\n      this.status = Status.READY;\n      /**\n       * Emitted when the shard is fully ready.\n       * This event is emitted if:\n       * * all guilds were received by this shard\n       * * the ready timeout expired, and some guilds are unavailable\n       * @event WebSocketShard#allReady\n       * @param {?Set<string>} unavailableGuilds Set of unavailable guilds, if any\n       */\n\n      this.emit(ShardEvents.ALL_READY);\n      return;\n    } // Step 2. Create a 15s timeout that will mark the shard as ready if there are still unavailable guilds\n\n\n    this.readyTimeout = this.manager.client.setTimeout(() => {\n      this.debug(`Shard did not receive any more guild packets in 15 seconds.\n  Unavailable guild count: ${this.expectedGuilds.size}`);\n      this.readyTimeout = null;\n      this.status = Status.READY;\n      this.emit(ShardEvents.ALL_READY, this.expectedGuilds);\n    }, 15000);\n  }\n  /**\n   * Sets the HELLO packet timeout.\n   * @param {number} [time] If set to -1, it will clear the hello timeout timeout\n   * @private\n   */\n\n\n  setHelloTimeout(time) {\n    if (time === -1) {\n      if (this.helloTimeout) {\n        this.debug('Clearing the HELLO timeout.');\n        this.manager.client.clearTimeout(this.helloTimeout);\n        this.helloTimeout = null;\n      }\n\n      return;\n    }\n\n    this.debug('Setting a HELLO timeout for 20s.');\n    this.helloTimeout = this.manager.client.setTimeout(() => {\n      this.debug('Did not receive HELLO in time. Destroying and connecting again.');\n      this.destroy({\n        reset: true,\n        closeCode: 4009\n      });\n    }, 20000);\n  }\n  /**\n   * Sets the heartbeat timer for this shard.\n   * @param {number} time If -1, clears the interval, any other number sets an interval\n   * @private\n   */\n\n\n  setHeartbeatTimer(time) {\n    if (time === -1) {\n      if (this.heartbeatInterval) {\n        this.debug('Clearing the heartbeat interval.');\n        this.manager.client.clearInterval(this.heartbeatInterval);\n        this.heartbeatInterval = null;\n      }\n\n      return;\n    }\n\n    this.debug(`Setting a heartbeat interval for ${time}ms.`); // Sanity checks\n\n    if (this.heartbeatInterval) this.manager.client.clearInterval(this.heartbeatInterval);\n    this.heartbeatInterval = this.manager.client.setInterval(() => this.sendHeartbeat(), time);\n  }\n  /**\n   * Sends a heartbeat to the WebSocket.\n   * If this shard didn't receive a heartbeat last time, it will destroy it and reconnect\n   * @param {string} [tag='HeartbeatTimer'] What caused this heartbeat to be sent\n   * @param {boolean} [ignoreHeartbeatAck] If we should send the heartbeat forcefully.\n   * @private\n   */\n\n\n  sendHeartbeat() {\n    let tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'HeartbeatTimer';\n    let ignoreHeartbeatAck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [Status.WAITING_FOR_GUILDS, Status.IDENTIFYING, Status.RESUMING].includes(this.status);\n\n    if (ignoreHeartbeatAck && !this.lastHeartbeatAcked) {\n      this.debug(`[${tag}] Didn't process heartbeat ack yet but we are still connected. Sending one now.`);\n    } else if (!this.lastHeartbeatAcked) {\n      this.debug(`[${tag}] Didn't receive a heartbeat ack last time, assuming zombie connection. Destroying and reconnecting.\n    Status          : ${STATUS_KEYS[this.status]}\n    Sequence        : ${this.sequence}\n    Connection State: ${this.connection ? CONNECTION_STATE[this.connection.readyState] : 'No Connection??'}`);\n      this.destroy({\n        closeCode: 4009,\n        reset: true\n      });\n      return;\n    }\n\n    this.debug(`[${tag}] Sending a heartbeat.`);\n    this.lastHeartbeatAcked = false;\n    this.lastPingTimestamp = Date.now();\n    this.send({\n      op: OPCodes.HEARTBEAT,\n      d: this.sequence\n    }, true);\n  }\n  /**\n   * Acknowledges a heartbeat.\n   * @private\n   */\n\n\n  ackHeartbeat() {\n    this.lastHeartbeatAcked = true;\n    const latency = Date.now() - this.lastPingTimestamp;\n    this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`);\n    this.ping = latency;\n  }\n  /**\n   * Identifies the client on the connection.\n   * @private\n   * @returns {void}\n   */\n\n\n  identify() {\n    return this.sessionID ? this.identifyResume() : this.identifyNew();\n  }\n  /**\n   * Identifies as a new connection on the gateway.\n   * @private\n   */\n\n\n  identifyNew() {\n    const {\n      client\n    } = this.manager;\n\n    if (!client.token) {\n      this.debug('[IDENTIFY] No token available to identify a new session.');\n      return;\n    }\n\n    this.status = Status.IDENTIFYING; // Clone the identify payload and assign the token and shard info\n\n    const d = { ...client.options.ws,\n      token: client.token,\n      shard: [this.id, Number(client.options.shardCount)]\n    };\n    this.debug(`[IDENTIFY] Shard ${this.id}/${client.options.shardCount}`);\n    this.send({\n      op: OPCodes.IDENTIFY,\n      d\n    }, true);\n  }\n  /**\n   * Resumes a session on the gateway.\n   * @private\n   */\n\n\n  identifyResume() {\n    if (!this.sessionID) {\n      this.debug('[RESUME] No session ID was present; identifying as a new session.');\n      this.identifyNew();\n      return;\n    }\n\n    this.status = Status.RESUMING;\n    this.debug(`[RESUME] Session ${this.sessionID}, sequence ${this.closeSequence}`);\n    const d = {\n      token: this.manager.client.token,\n      session_id: this.sessionID,\n      seq: this.closeSequence\n    };\n    this.send({\n      op: OPCodes.RESUME,\n      d\n    }, true);\n  }\n  /**\n   * Adds a packet to the queue to be sent to the gateway.\n   * <warn>If you use this method, make sure you understand that you need to provide\n   * a full [Payload](https://discord.com/developers/docs/topics/gateway#commands-and-events-gateway-commands).\n   * Do not use this method if you don't know what you're doing.</warn>\n   * @param {Object} data The full packet to send\n   * @param {boolean} [important=false] If this packet should be added first in queue\n   */\n\n\n  send(data) {\n    let important = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.ratelimit.queue[important ? 'unshift' : 'push'](data);\n    this.processQueue();\n  }\n  /**\n   * Sends data, bypassing the queue.\n   * @param {Object} data Packet to send\n   * @returns {void}\n   * @private\n   */\n\n\n  _send(data) {\n    if (!this.connection || this.connection.readyState !== WebSocket.OPEN) {\n      this.debug(`Tried to send packet '${JSON.stringify(data)}' but no WebSocket is available!`);\n      this.destroy({\n        close: 4000\n      });\n      return;\n    }\n\n    this.connection.send(WebSocket.pack(data), err => {\n      if (err) this.manager.client.emit(Events.SHARD_ERROR, err, this.id);\n    });\n  }\n  /**\n   * Processes the current WebSocket queue.\n   * @returns {void}\n   * @private\n   */\n\n\n  processQueue() {\n    if (this.ratelimit.remaining === 0) return;\n    if (this.ratelimit.queue.length === 0) return;\n\n    if (this.ratelimit.remaining === this.ratelimit.total) {\n      this.ratelimit.timer = this.manager.client.setTimeout(() => {\n        this.ratelimit.remaining = this.ratelimit.total;\n        this.processQueue();\n      }, this.ratelimit.time);\n    }\n\n    while (this.ratelimit.remaining > 0) {\n      const item = this.ratelimit.queue.shift();\n      if (!item) return;\n\n      this._send(item);\n\n      this.ratelimit.remaining--;\n    }\n  }\n  /**\n   * Destroys this shard and closes its WebSocket connection.\n   * @param {Object} [options={ closeCode: 1000, reset: false, emit: true, log: true }] Options for destroying the shard\n   * @private\n   */\n\n\n  destroy() {\n    let {\n      closeCode = 1000,\n      reset = false,\n      emit = true,\n      log = true\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (log) {\n      this.debug(`[DESTROY]\n    Close Code    : ${closeCode}\n    Reset         : ${reset}\n    Emit DESTROYED: ${emit}`);\n    } // Step 0: Remove all timers\n\n\n    this.setHeartbeatTimer(-1);\n    this.setHelloTimeout(-1); // Step 1: Close the WebSocket connection, if any, otherwise, emit DESTROYED\n\n    if (this.connection) {\n      // If the connection is currently opened, we will (hopefully) receive close\n      if (this.connection.readyState === WebSocket.OPEN) {\n        this.connection.close(closeCode);\n      } else {\n        // Connection is not OPEN\n        this.debug(`WS State: ${CONNECTION_STATE[this.connection.readyState]}`); // Remove listeners from the connection\n\n        this._cleanupConnection(); // Attempt to close the connection just in case\n\n\n        try {\n          this.connection.close(closeCode);\n        } catch {// No-op\n        } // Emit the destroyed event if needed\n\n\n        if (emit) this._emitDestroyed();\n      }\n    } else if (emit) {\n      // We requested a destroy, but we had no connection. Emit destroyed\n      this._emitDestroyed();\n    } // Step 2: Null the connection object\n\n\n    this.connection = null; // Step 3: Set the shard status to DISCONNECTED\n\n    this.status = Status.DISCONNECTED; // Step 4: Cache the old sequence (use to attempt a resume)\n\n    if (this.sequence !== -1) this.closeSequence = this.sequence; // Step 5: Reset the sequence and session ID if requested\n\n    if (reset) {\n      this.sequence = -1;\n      this.sessionID = null;\n    } // Step 6: reset the ratelimit data\n\n\n    this.ratelimit.remaining = this.ratelimit.total;\n    this.ratelimit.queue.length = 0;\n\n    if (this.ratelimit.timer) {\n      this.manager.client.clearTimeout(this.ratelimit.timer);\n      this.ratelimit.timer = null;\n    }\n  }\n  /**\n   * Cleans up the WebSocket connection listeners.\n   * @private\n   */\n\n\n  _cleanupConnection() {\n    this.connection.onopen = this.connection.onclose = this.connection.onerror = this.connection.onmessage = null;\n  }\n  /**\n   * Emits the DESTROYED event on the shard\n   * @private\n   */\n\n\n  _emitDestroyed() {\n    /**\n     * Emitted when a shard is destroyed, but no WebSocket connection was present.\n     * @private\n     * @event WebSocketShard#destroyed\n     */\n    this.emit(ShardEvents.DESTROYED);\n  }\n\n}\n\nmodule.exports = WebSocketShard;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/client/websocket/WebSocketShard.js"],"names":["EventEmitter","require","WebSocket","browser","Status","Events","ShardEvents","OPCodes","WSEvents","STATUS_KEYS","Object","keys","CONNECTION_STATE","zlib","WebSocketShard","constructor","manager","id","status","IDLE","sequence","closeSequence","sessionID","ping","lastPingTimestamp","lastHeartbeatAcked","defineProperty","value","queue","total","remaining","time","timer","writable","debug","message","connect","gateway","client","connection","readyState","OPEN","READY","Promise","resolve","reject","cleanup","removeListener","CLOSE","onClose","onReady","RESUMED","onResumed","INVALID_SESSION","onInvalidOrDestroyed","DESTROYED","event","once","identify","destroy","emit","wsQuery","v","options","ws","version","inflate","Inflate","chunkSize","flush","Z_SYNC_FLUSH","to","encoding","compress","DISCONNECTED","RECONNECTING","CONNECTING","setHelloTimeout","connectedAt","Date","now","create","onopen","onOpen","bind","onmessage","onMessage","onerror","onError","onclose","url","NEARLY","data","raw","ArrayBuffer","Uint8Array","l","length","push","result","packet","unpack","RAW","op","DISPATCH","t","d","err","SHARD_ERROR","onPacket","error","code","wasClean","reason","setHeartbeatTimer","_cleanupConnection","session_id","expectedGuilds","Set","guilds","map","WAITING_FOR_GUILDS","sendHeartbeat","replayed","s","HELLO","heartbeat_interval","RECONNECT","closeCode","identifyResume","HEARTBEAT_ACK","ackHeartbeat","HEARTBEAT","handlePacket","GUILD_CREATE","delete","checkReady","readyTimeout","clearTimeout","size","ALL_READY","setTimeout","helloTimeout","reset","heartbeatInterval","clearInterval","setInterval","tag","ignoreHeartbeatAck","IDENTIFYING","RESUMING","includes","send","latency","identifyNew","token","shard","Number","shardCount","IDENTIFY","seq","RESUME","important","ratelimit","processQueue","_send","JSON","stringify","close","pack","item","shift","log","_emitDestroyed","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst WebSocket = require('../../WebSocket');\nconst { browser, Status, Events, ShardEvents, OPCodes, WSEvents } = require('../../util/Constants');\n\nconst STATUS_KEYS = Object.keys(Status);\nconst CONNECTION_STATE = Object.keys(WebSocket.WebSocket);\n\nlet zlib;\n\nif (!browser) {\n  try {\n    zlib = require('zlib-sync');\n  } catch {} // eslint-disable-line no-empty\n}\n\n/**\n * Represents a Shard's WebSocket connection\n */\nclass WebSocketShard extends EventEmitter {\n  constructor(manager, id) {\n    super();\n\n    /**\n     * The WebSocketManager of the shard\n     * @type {WebSocketManager}\n     */\n    this.manager = manager;\n\n    /**\n     * The ID of the shard\n     * @type {number}\n     */\n    this.id = id;\n\n    /**\n     * The current status of the shard\n     * @type {Status}\n     */\n    this.status = Status.IDLE;\n\n    /**\n     * The current sequence of the shard\n     * @type {number}\n     * @private\n     */\n    this.sequence = -1;\n\n    /**\n     * The sequence of the shard after close\n     * @type {number}\n     * @private\n     */\n    this.closeSequence = 0;\n\n    /**\n     * The current session ID of the shard\n     * @type {?string}\n     * @private\n     */\n    this.sessionID = null;\n\n    /**\n     * The previous heartbeat ping of the shard\n     * @type {number}\n     */\n    this.ping = -1;\n\n    /**\n     * The last time a ping was sent (a timestamp)\n     * @type {number}\n     * @private\n     */\n    this.lastPingTimestamp = -1;\n\n    /**\n     * If we received a heartbeat ack back. Used to identify zombie connections\n     * @type {boolean}\n     * @private\n     */\n    this.lastHeartbeatAcked = true;\n\n    /**\n     * Contains the rate limit queue and metadata\n     * @name WebSocketShard#ratelimit\n     * @type {Object}\n     * @private\n     */\n    Object.defineProperty(this, 'ratelimit', {\n      value: {\n        queue: [],\n        total: 120,\n        remaining: 120,\n        time: 60e3,\n        timer: null,\n      },\n    });\n\n    /**\n     * The WebSocket connection for the current shard\n     * @name WebSocketShard#connection\n     * @type {?WebSocket}\n     * @private\n     */\n    Object.defineProperty(this, 'connection', { value: null, writable: true });\n\n    /**\n     * @external Inflate\n     * @see {@link https://www.npmjs.com/package/zlib-sync}\n     */\n\n    /**\n     * The compression to use\n     * @name WebSocketShard#inflate\n     * @type {?Inflate}\n     * @private\n     */\n    Object.defineProperty(this, 'inflate', { value: null, writable: true });\n\n    /**\n     * The HELLO timeout\n     * @name WebSocketShard#helloTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n    Object.defineProperty(this, 'helloTimeout', { value: null, writable: true });\n\n    /**\n     * If the manager attached its event handlers on the shard\n     * @name WebSocketShard#eventsAttached\n     * @type {boolean}\n     * @private\n     */\n    Object.defineProperty(this, 'eventsAttached', { value: false, writable: true });\n\n    /**\n     * A set of guild IDs this shard expects to receive\n     * @name WebSocketShard#expectedGuilds\n     * @type {?Set<string>}\n     * @private\n     */\n    Object.defineProperty(this, 'expectedGuilds', { value: null, writable: true });\n\n    /**\n     * The ready timeout\n     * @name WebSocketShard#readyTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n    Object.defineProperty(this, 'readyTimeout', { value: null, writable: true });\n\n    /**\n     * Time when the WebSocket connection was opened\n     * @name WebSocketShard#connectedAt\n     * @type {number}\n     * @private\n     */\n    Object.defineProperty(this, 'connectedAt', { value: 0, writable: true });\n  }\n\n  /**\n   * Emits a debug event.\n   * @param {string} message The debug message\n   * @private\n   */\n  debug(message) {\n    this.manager.debug(message, this);\n  }\n\n  /**\n   * Connects the shard to the gateway.\n   * @private\n   * @returns {Promise<void>} A promise that will resolve if the shard turns ready successfully,\n   * or reject if we couldn't connect\n   */\n  connect() {\n    const { gateway, client } = this.manager;\n\n    if (this.connection && this.connection.readyState === WebSocket.OPEN && this.status === Status.READY) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve, reject) => {\n      const cleanup = () => {\n        this.removeListener(ShardEvents.CLOSE, onClose);\n        this.removeListener(ShardEvents.READY, onReady);\n        this.removeListener(ShardEvents.RESUMED, onResumed);\n        this.removeListener(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);\n        this.removeListener(ShardEvents.DESTROYED, onInvalidOrDestroyed);\n      };\n\n      const onReady = () => {\n        cleanup();\n        resolve();\n      };\n\n      const onResumed = () => {\n        cleanup();\n        resolve();\n      };\n\n      const onClose = event => {\n        cleanup();\n        reject(event);\n      };\n\n      const onInvalidOrDestroyed = () => {\n        cleanup();\n        // eslint-disable-next-line prefer-promise-reject-errors\n        reject();\n      };\n\n      this.once(ShardEvents.READY, onReady);\n      this.once(ShardEvents.RESUMED, onResumed);\n      this.once(ShardEvents.CLOSE, onClose);\n      this.once(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);\n      this.once(ShardEvents.DESTROYED, onInvalidOrDestroyed);\n\n      if (this.connection && this.connection.readyState === WebSocket.OPEN) {\n        this.debug('An open connection was found, attempting an immediate identify.');\n        this.identify();\n        return;\n      }\n\n      if (this.connection) {\n        this.debug(`A connection object was found. Cleaning up before continuing.\n    State: ${CONNECTION_STATE[this.connection.readyState]}`);\n        this.destroy({ emit: false });\n      }\n\n      const wsQuery = { v: client.options.ws.version };\n\n      if (zlib) {\n        this.inflate = new zlib.Inflate({\n          chunkSize: 65535,\n          flush: zlib.Z_SYNC_FLUSH,\n          to: WebSocket.encoding === 'json' ? 'string' : '',\n        });\n        wsQuery.compress = 'zlib-stream';\n      }\n\n      this.debug(\n        `[CONNECT]\n    Gateway    : ${gateway}\n    Version    : ${client.options.ws.version}\n    Encoding   : ${WebSocket.encoding}\n    Compression: ${zlib ? 'zlib-stream' : 'none'}`,\n      );\n\n      this.status = this.status === Status.DISCONNECTED ? Status.RECONNECTING : Status.CONNECTING;\n      this.setHelloTimeout();\n\n      this.connectedAt = Date.now();\n\n      const ws = (this.connection = WebSocket.create(gateway, wsQuery));\n      ws.onopen = this.onOpen.bind(this);\n      ws.onmessage = this.onMessage.bind(this);\n      ws.onerror = this.onError.bind(this);\n      ws.onclose = this.onClose.bind(this);\n    });\n  }\n\n  /**\n   * Called whenever a connection is opened to the gateway.\n   * @private\n   */\n  onOpen() {\n    this.debug(`[CONNECTED] ${this.connection.url} in ${Date.now() - this.connectedAt}ms`);\n    this.status = Status.NEARLY;\n  }\n\n  /**\n   * Called whenever a message is received.\n   * @param {MessageEvent} event Event received\n   * @private\n   */\n  onMessage({ data }) {\n    let raw;\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data);\n    if (zlib) {\n      const l = data.length;\n      const flush =\n        l >= 4 && data[l - 4] === 0x00 && data[l - 3] === 0x00 && data[l - 2] === 0xff && data[l - 1] === 0xff;\n\n      this.inflate.push(data, flush && zlib.Z_SYNC_FLUSH);\n      if (!flush) return;\n      raw = this.inflate.result;\n    } else {\n      raw = data;\n    }\n    let packet;\n    try {\n      packet = WebSocket.unpack(raw);\n      this.manager.client.emit(Events.RAW, packet, this.id);\n      if (packet.op === OPCodes.DISPATCH) this.manager.emit(packet.t, packet.d, this.id);\n    } catch (err) {\n      this.manager.client.emit(Events.SHARD_ERROR, err, this.id);\n      return;\n    }\n    this.onPacket(packet);\n  }\n\n  /**\n   * Called whenever an error occurs with the WebSocket.\n   * @param {ErrorEvent} event The error that occurred\n   * @private\n   */\n  onError(event) {\n    const error = event && event.error ? event.error : event;\n    if (!error) return;\n\n    /**\n     * Emitted whenever a shard's WebSocket encounters a connection error.\n     * @event Client#shardError\n     * @param {Error} error The encountered error\n     * @param {number} shardID The shard that encountered this error\n     */\n    this.manager.client.emit(Events.SHARD_ERROR, error, this.id);\n  }\n\n  /**\n   * @external CloseEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\n   */\n\n  /**\n   * @external ErrorEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent}\n   */\n\n  /**\n   * @external MessageEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n   */\n\n  /**\n   * Called whenever a connection to the gateway is closed.\n   * @param {CloseEvent} event Close event that was received\n   * @private\n   */\n  onClose(event) {\n    if (this.sequence !== -1) this.closeSequence = this.sequence;\n    this.sequence = -1;\n\n    this.debug(`[CLOSE]\n    Event Code: ${event.code}\n    Clean     : ${event.wasClean}\n    Reason    : ${event.reason || 'No reason received'}`);\n\n    this.setHeartbeatTimer(-1);\n    this.setHelloTimeout(-1);\n    // If we still have a connection object, clean up its listeners\n    if (this.connection) this._cleanupConnection();\n\n    this.status = Status.DISCONNECTED;\n\n    /**\n     * Emitted when a shard's WebSocket closes.\n     * @private\n     * @event WebSocketShard#close\n     * @param {CloseEvent} event The received event\n     */\n    this.emit(ShardEvents.CLOSE, event);\n  }\n\n  /**\n   * Called whenever a packet is received.\n   * @param {Object} packet The received packet\n   * @private\n   */\n  onPacket(packet) {\n    if (!packet) {\n      this.debug(`Received broken packet: '${packet}'.`);\n      return;\n    }\n\n    switch (packet.t) {\n      case WSEvents.READY:\n        /**\n         * Emitted when the shard receives the READY payload and is now waiting for guilds\n         * @event WebSocketShard#ready\n         */\n        this.emit(ShardEvents.READY);\n\n        this.sessionID = packet.d.session_id;\n        this.expectedGuilds = new Set(packet.d.guilds.map(d => d.id));\n        this.status = Status.WAITING_FOR_GUILDS;\n        this.debug(`[READY] Session ${this.sessionID}.`);\n        this.lastHeartbeatAcked = true;\n        this.sendHeartbeat('ReadyHeartbeat');\n        break;\n      case WSEvents.RESUMED: {\n        /**\n         * Emitted when the shard resumes successfully\n         * @event WebSocketShard#resumed\n         */\n        this.emit(ShardEvents.RESUMED);\n\n        this.status = Status.READY;\n        const replayed = packet.s - this.closeSequence;\n        this.debug(`[RESUMED] Session ${this.sessionID} | Replayed ${replayed} events.`);\n        this.lastHeartbeatAcked = true;\n        this.sendHeartbeat('ResumeHeartbeat');\n        break;\n      }\n    }\n\n    if (packet.s > this.sequence) this.sequence = packet.s;\n\n    switch (packet.op) {\n      case OPCodes.HELLO:\n        this.setHelloTimeout(-1);\n        this.setHeartbeatTimer(packet.d.heartbeat_interval);\n        this.identify();\n        break;\n      case OPCodes.RECONNECT:\n        this.debug('[RECONNECT] Discord asked us to reconnect');\n        this.destroy({ closeCode: 4000 });\n        break;\n      case OPCodes.INVALID_SESSION:\n        this.debug(`[INVALID SESSION] Resumable: ${packet.d}.`);\n        // If we can resume the session, do so immediately\n        if (packet.d) {\n          this.identifyResume();\n          return;\n        }\n        // Reset the sequence\n        this.sequence = -1;\n        // Reset the session ID as it's invalid\n        this.sessionID = null;\n        // Set the status to reconnecting\n        this.status = Status.RECONNECTING;\n        // Finally, emit the INVALID_SESSION event\n        this.emit(ShardEvents.INVALID_SESSION);\n        break;\n      case OPCodes.HEARTBEAT_ACK:\n        this.ackHeartbeat();\n        break;\n      case OPCodes.HEARTBEAT:\n        this.sendHeartbeat('HeartbeatRequest', true);\n        break;\n      default:\n        this.manager.handlePacket(packet, this);\n        if (this.status === Status.WAITING_FOR_GUILDS && packet.t === WSEvents.GUILD_CREATE) {\n          this.expectedGuilds.delete(packet.d.id);\n          this.checkReady();\n        }\n    }\n  }\n\n  /**\n   * Checks if the shard can be marked as ready\n   * @private\n   */\n  checkReady() {\n    // Step 0. Clear the ready timeout, if it exists\n    if (this.readyTimeout) {\n      this.manager.client.clearTimeout(this.readyTimeout);\n      this.readyTimeout = null;\n    }\n    // Step 1. If we don't have any other guilds pending, we are ready\n    if (!this.expectedGuilds.size) {\n      this.debug('Shard received all its guilds. Marking as fully ready.');\n      this.status = Status.READY;\n\n      /**\n       * Emitted when the shard is fully ready.\n       * This event is emitted if:\n       * * all guilds were received by this shard\n       * * the ready timeout expired, and some guilds are unavailable\n       * @event WebSocketShard#allReady\n       * @param {?Set<string>} unavailableGuilds Set of unavailable guilds, if any\n       */\n      this.emit(ShardEvents.ALL_READY);\n      return;\n    }\n    // Step 2. Create a 15s timeout that will mark the shard as ready if there are still unavailable guilds\n    this.readyTimeout = this.manager.client.setTimeout(() => {\n      this.debug(`Shard did not receive any more guild packets in 15 seconds.\n  Unavailable guild count: ${this.expectedGuilds.size}`);\n\n      this.readyTimeout = null;\n\n      this.status = Status.READY;\n\n      this.emit(ShardEvents.ALL_READY, this.expectedGuilds);\n    }, 15000);\n  }\n\n  /**\n   * Sets the HELLO packet timeout.\n   * @param {number} [time] If set to -1, it will clear the hello timeout timeout\n   * @private\n   */\n  setHelloTimeout(time) {\n    if (time === -1) {\n      if (this.helloTimeout) {\n        this.debug('Clearing the HELLO timeout.');\n        this.manager.client.clearTimeout(this.helloTimeout);\n        this.helloTimeout = null;\n      }\n      return;\n    }\n    this.debug('Setting a HELLO timeout for 20s.');\n    this.helloTimeout = this.manager.client.setTimeout(() => {\n      this.debug('Did not receive HELLO in time. Destroying and connecting again.');\n      this.destroy({ reset: true, closeCode: 4009 });\n    }, 20000);\n  }\n\n  /**\n   * Sets the heartbeat timer for this shard.\n   * @param {number} time If -1, clears the interval, any other number sets an interval\n   * @private\n   */\n  setHeartbeatTimer(time) {\n    if (time === -1) {\n      if (this.heartbeatInterval) {\n        this.debug('Clearing the heartbeat interval.');\n        this.manager.client.clearInterval(this.heartbeatInterval);\n        this.heartbeatInterval = null;\n      }\n      return;\n    }\n    this.debug(`Setting a heartbeat interval for ${time}ms.`);\n    // Sanity checks\n    if (this.heartbeatInterval) this.manager.client.clearInterval(this.heartbeatInterval);\n    this.heartbeatInterval = this.manager.client.setInterval(() => this.sendHeartbeat(), time);\n  }\n\n  /**\n   * Sends a heartbeat to the WebSocket.\n   * If this shard didn't receive a heartbeat last time, it will destroy it and reconnect\n   * @param {string} [tag='HeartbeatTimer'] What caused this heartbeat to be sent\n   * @param {boolean} [ignoreHeartbeatAck] If we should send the heartbeat forcefully.\n   * @private\n   */\n  sendHeartbeat(\n    tag = 'HeartbeatTimer',\n    ignoreHeartbeatAck = [Status.WAITING_FOR_GUILDS, Status.IDENTIFYING, Status.RESUMING].includes(this.status),\n  ) {\n    if (ignoreHeartbeatAck && !this.lastHeartbeatAcked) {\n      this.debug(`[${tag}] Didn't process heartbeat ack yet but we are still connected. Sending one now.`);\n    } else if (!this.lastHeartbeatAcked) {\n      this.debug(\n        `[${tag}] Didn't receive a heartbeat ack last time, assuming zombie connection. Destroying and reconnecting.\n    Status          : ${STATUS_KEYS[this.status]}\n    Sequence        : ${this.sequence}\n    Connection State: ${this.connection ? CONNECTION_STATE[this.connection.readyState] : 'No Connection??'}`,\n      );\n\n      this.destroy({ closeCode: 4009, reset: true });\n      return;\n    }\n\n    this.debug(`[${tag}] Sending a heartbeat.`);\n    this.lastHeartbeatAcked = false;\n    this.lastPingTimestamp = Date.now();\n    this.send({ op: OPCodes.HEARTBEAT, d: this.sequence }, true);\n  }\n\n  /**\n   * Acknowledges a heartbeat.\n   * @private\n   */\n  ackHeartbeat() {\n    this.lastHeartbeatAcked = true;\n    const latency = Date.now() - this.lastPingTimestamp;\n    this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`);\n    this.ping = latency;\n  }\n\n  /**\n   * Identifies the client on the connection.\n   * @private\n   * @returns {void}\n   */\n  identify() {\n    return this.sessionID ? this.identifyResume() : this.identifyNew();\n  }\n\n  /**\n   * Identifies as a new connection on the gateway.\n   * @private\n   */\n  identifyNew() {\n    const { client } = this.manager;\n    if (!client.token) {\n      this.debug('[IDENTIFY] No token available to identify a new session.');\n      return;\n    }\n\n    this.status = Status.IDENTIFYING;\n\n    // Clone the identify payload and assign the token and shard info\n    const d = {\n      ...client.options.ws,\n      token: client.token,\n      shard: [this.id, Number(client.options.shardCount)],\n    };\n\n    this.debug(`[IDENTIFY] Shard ${this.id}/${client.options.shardCount}`);\n    this.send({ op: OPCodes.IDENTIFY, d }, true);\n  }\n\n  /**\n   * Resumes a session on the gateway.\n   * @private\n   */\n  identifyResume() {\n    if (!this.sessionID) {\n      this.debug('[RESUME] No session ID was present; identifying as a new session.');\n      this.identifyNew();\n      return;\n    }\n\n    this.status = Status.RESUMING;\n\n    this.debug(`[RESUME] Session ${this.sessionID}, sequence ${this.closeSequence}`);\n\n    const d = {\n      token: this.manager.client.token,\n      session_id: this.sessionID,\n      seq: this.closeSequence,\n    };\n\n    this.send({ op: OPCodes.RESUME, d }, true);\n  }\n\n  /**\n   * Adds a packet to the queue to be sent to the gateway.\n   * <warn>If you use this method, make sure you understand that you need to provide\n   * a full [Payload](https://discord.com/developers/docs/topics/gateway#commands-and-events-gateway-commands).\n   * Do not use this method if you don't know what you're doing.</warn>\n   * @param {Object} data The full packet to send\n   * @param {boolean} [important=false] If this packet should be added first in queue\n   */\n  send(data, important = false) {\n    this.ratelimit.queue[important ? 'unshift' : 'push'](data);\n    this.processQueue();\n  }\n\n  /**\n   * Sends data, bypassing the queue.\n   * @param {Object} data Packet to send\n   * @returns {void}\n   * @private\n   */\n  _send(data) {\n    if (!this.connection || this.connection.readyState !== WebSocket.OPEN) {\n      this.debug(`Tried to send packet '${JSON.stringify(data)}' but no WebSocket is available!`);\n      this.destroy({ close: 4000 });\n      return;\n    }\n\n    this.connection.send(WebSocket.pack(data), err => {\n      if (err) this.manager.client.emit(Events.SHARD_ERROR, err, this.id);\n    });\n  }\n\n  /**\n   * Processes the current WebSocket queue.\n   * @returns {void}\n   * @private\n   */\n  processQueue() {\n    if (this.ratelimit.remaining === 0) return;\n    if (this.ratelimit.queue.length === 0) return;\n    if (this.ratelimit.remaining === this.ratelimit.total) {\n      this.ratelimit.timer = this.manager.client.setTimeout(() => {\n        this.ratelimit.remaining = this.ratelimit.total;\n        this.processQueue();\n      }, this.ratelimit.time);\n    }\n    while (this.ratelimit.remaining > 0) {\n      const item = this.ratelimit.queue.shift();\n      if (!item) return;\n      this._send(item);\n      this.ratelimit.remaining--;\n    }\n  }\n\n  /**\n   * Destroys this shard and closes its WebSocket connection.\n   * @param {Object} [options={ closeCode: 1000, reset: false, emit: true, log: true }] Options for destroying the shard\n   * @private\n   */\n  destroy({ closeCode = 1000, reset = false, emit = true, log = true } = {}) {\n    if (log) {\n      this.debug(`[DESTROY]\n    Close Code    : ${closeCode}\n    Reset         : ${reset}\n    Emit DESTROYED: ${emit}`);\n    }\n\n    // Step 0: Remove all timers\n    this.setHeartbeatTimer(-1);\n    this.setHelloTimeout(-1);\n\n    // Step 1: Close the WebSocket connection, if any, otherwise, emit DESTROYED\n    if (this.connection) {\n      // If the connection is currently opened, we will (hopefully) receive close\n      if (this.connection.readyState === WebSocket.OPEN) {\n        this.connection.close(closeCode);\n      } else {\n        // Connection is not OPEN\n        this.debug(`WS State: ${CONNECTION_STATE[this.connection.readyState]}`);\n        // Remove listeners from the connection\n        this._cleanupConnection();\n        // Attempt to close the connection just in case\n        try {\n          this.connection.close(closeCode);\n        } catch {\n          // No-op\n        }\n        // Emit the destroyed event if needed\n        if (emit) this._emitDestroyed();\n      }\n    } else if (emit) {\n      // We requested a destroy, but we had no connection. Emit destroyed\n      this._emitDestroyed();\n    }\n\n    // Step 2: Null the connection object\n    this.connection = null;\n\n    // Step 3: Set the shard status to DISCONNECTED\n    this.status = Status.DISCONNECTED;\n\n    // Step 4: Cache the old sequence (use to attempt a resume)\n    if (this.sequence !== -1) this.closeSequence = this.sequence;\n\n    // Step 5: Reset the sequence and session ID if requested\n    if (reset) {\n      this.sequence = -1;\n      this.sessionID = null;\n    }\n\n    // Step 6: reset the ratelimit data\n    this.ratelimit.remaining = this.ratelimit.total;\n    this.ratelimit.queue.length = 0;\n    if (this.ratelimit.timer) {\n      this.manager.client.clearTimeout(this.ratelimit.timer);\n      this.ratelimit.timer = null;\n    }\n  }\n\n  /**\n   * Cleans up the WebSocket connection listeners.\n   * @private\n   */\n  _cleanupConnection() {\n    this.connection.onopen = this.connection.onclose = this.connection.onerror = this.connection.onmessage = null;\n  }\n\n  /**\n   * Emits the DESTROYED event on the shard\n   * @private\n   */\n  _emitDestroyed() {\n    /**\n     * Emitted when a shard is destroyed, but no WebSocket connection was present.\n     * @private\n     * @event WebSocketShard#destroyed\n     */\n    this.emit(ShardEvents.DESTROYED);\n  }\n}\n\nmodule.exports = WebSocketShard;\n"]},"metadata":{},"sourceType":"script"}