{"ast":null,"code":"'use strict';\n\nconst APIMessage = require('./APIMessage');\n\nconst Channel = require('./Channel');\n\nconst {\n  WebhookTypes\n} = require('../util/Constants');\n\nconst DataResolver = require('../util/DataResolver');\n\nconst Snowflake = require('../util/Snowflake');\n/**\n * Represents a webhook.\n */\n\n\nclass Webhook {\n  constructor(client, data) {\n    /**\n     * The client that instantiated the webhook\n     * @name Webhook#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The name of the webhook\n     * @type {string}\n     */\n    this.name = data.name;\n    /**\n     * The token for the webhook\n     * @name Webhook#token\n     * @type {?string}\n     */\n\n    Object.defineProperty(this, 'token', {\n      value: data.token || null,\n      writable: true,\n      configurable: true\n    });\n    /**\n     * The avatar for the webhook\n     * @type {?string}\n     */\n\n    this.avatar = data.avatar;\n    /**\n     * The ID of the webhook\n     * @type {Snowflake}\n     */\n\n    this.id = data.id;\n    /**\n     * The type of the webhook\n     * @type {WebhookTypes}\n     */\n\n    this.type = WebhookTypes[data.type];\n    /**\n     * The guild the webhook belongs to\n     * @type {Snowflake}\n     */\n\n    this.guildID = data.guild_id;\n    /**\n     * The channel the webhook belongs to\n     * @type {Snowflake}\n     */\n\n    this.channelID = data.channel_id;\n\n    if (data.user) {\n      /**\n       * The owner of the webhook\n       * @type {?User|Object}\n       */\n      this.owner = this.client.users ? this.client.users.cache.get(data.user.id) : data.user;\n    } else {\n      this.owner = null;\n    }\n  }\n  /**\n   * Options that can be passed into send.\n   * @typedef {Object} WebhookMessageOptions\n   * @property {string} [username=this.name] Username override for the message\n   * @property {string} [avatarURL] Avatar URL override for the message\n   * @property {boolean} [tts=false] Whether or not the message should be spoken aloud\n   * @property {string} [nonce=''] The nonce for the message\n   * @property {Object[]} [embeds] An array of embeds for the message\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   * (see [here](https://discord.com/developers/docs/resources/channel#embed-object) for more details)\n   * @property {DisableMentionType} [disableMentions=this.client.options.disableMentions] Whether or not all mentions or\n   * everyone/here mentions should be sanitized to prevent unexpected mentions\n   * @property {FileOptions[]|string[]} [files] Files to send with the message\n   * @property {string|boolean} [code] Language for optional codeblock formatting to apply\n   * @property {boolean|SplitOptions} [split=false] Whether or not the message should be split into multiple messages if\n   * it exceeds the character limit. If an object is provided, these are the options for splitting the message.\n   */\n\n  /**\n   * Sends a message with this webhook.\n   * @param {StringResolvable|APIMessage} [content=''] The content to send\n   * @param {WebhookMessageOptions|MessageAdditions} [options={}] The options to provide\n   * @returns {Promise<Message|Object>}\n   * @example\n   * // Send a basic message\n   * webhook.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * webhook.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * webhook.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send an embed with a local image inside\n   * webhook.send('This is an embed', {\n   *   embeds: [{\n   *     thumbnail: {\n   *          url: 'attachment://file.jpg'\n   *       }\n   *    }],\n   *    files: [{\n   *       attachment: 'entire/path/to/file.jpg',\n   *       name: 'file.jpg'\n   *    }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async send(content, options) {\n    let apiMessage;\n\n    if (content instanceof APIMessage) {\n      apiMessage = content.resolveData();\n    } else {\n      apiMessage = APIMessage.create(this, content, options).resolveData();\n\n      if (Array.isArray(apiMessage.data.content)) {\n        return Promise.all(apiMessage.split().map(this.send.bind(this)));\n      }\n    }\n\n    const {\n      data,\n      files\n    } = await apiMessage.resolveFiles();\n    return this.client.api.webhooks(this.id, this.token).post({\n      data,\n      files,\n      query: {\n        wait: true\n      },\n      auth: false\n    }).then(d => {\n      const channel = this.client.channels ? this.client.channels.cache.get(d.channel_id) : undefined;\n      if (!channel) return d;\n      return channel.messages.add(d, false);\n    });\n  }\n  /**\n   * Sends a raw slack message with this webhook.\n   * @param {Object} body The raw body to send\n   * @returns {Promise<boolean>}\n   * @example\n   * // Send a slack message\n   * webhook.sendSlackMessage({\n   *   'username': 'Wumpus',\n   *   'attachments': [{\n   *     'pretext': 'this looks pretty cool',\n   *     'color': '#F0F',\n   *     'footer_icon': 'http://snek.s3.amazonaws.com/topSnek.png',\n   *     'footer': 'Powered by sneks',\n   *     'ts': Date.now() / 1000\n   *   }]\n   * }).catch(console.error);\n   */\n\n\n  sendSlackMessage(body) {\n    return this.client.api.webhooks(this.id, this.token).slack.post({\n      query: {\n        wait: true\n      },\n      auth: false,\n      data: body\n    }).then(data => data.toString() === 'ok');\n  }\n  /**\n   * Edits the webhook.\n   * @param {Object} options Options\n   * @param {string} [options.name=this.name] New name for this webhook\n   * @param {BufferResolvable} [options.avatar] New avatar for this webhook\n   * @param {ChannelResolvable} [options.channel] New channel for this webhook\n   * @param {string} [reason] Reason for editing this webhook\n   * @returns {Promise<Webhook>}\n   */\n\n\n  async edit(_ref, reason) {\n    let {\n      name = this.name,\n      avatar,\n      channel\n    } = _ref;\n\n    if (avatar && typeof avatar === 'string' && !avatar.startsWith('data:')) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n\n    if (channel) channel = channel instanceof Channel ? channel.id : channel;\n    const data = await this.client.api.webhooks(this.id, channel ? undefined : this.token).patch({\n      data: {\n        name,\n        avatar,\n        channel_id: channel\n      },\n      reason\n    });\n    this.name = data.name;\n    this.avatar = data.avatar;\n    this.channelID = data.channel_id;\n    return this;\n  }\n  /**\n   * Deletes the webhook.\n   * @param {string} [reason] Reason for deleting this webhook\n   * @returns {Promise}\n   */\n\n\n  delete(reason) {\n    return this.client.api.webhooks(this.id, this.token).delete({\n      reason\n    });\n  }\n  /**\n   * The timestamp the webhook was created at\n   * @type {number}\n   * @readonly\n   */\n\n\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n  /**\n   * The time the webhook was created at\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * The url of this webhook\n   * @type {string}\n   * @readonly\n   */\n\n\n  get url() {\n    return this.client.options.http.api + this.client.api.webhooks(this.id, this.token);\n  }\n  /**\n   * A link to the webhook's avatar.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n\n\n  avatarURL() {\n    let {\n      format,\n      size\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.avatar) return null;\n    return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size);\n  }\n\n  static applyToClass(structure) {\n    for (const prop of ['send', 'sendSlackMessage', 'edit', 'delete', 'createdTimestamp', 'createdAt', 'url']) {\n      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook.prototype, prop));\n    }\n  }\n\n}\n\nmodule.exports = Webhook;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/structures/Webhook.js"],"names":["APIMessage","require","Channel","WebhookTypes","DataResolver","Snowflake","Webhook","constructor","client","data","Object","defineProperty","value","_patch","name","token","writable","configurable","avatar","id","type","guildID","guild_id","channelID","channel_id","user","owner","users","cache","get","send","content","options","apiMessage","resolveData","create","Array","isArray","Promise","all","split","map","bind","files","resolveFiles","api","webhooks","post","query","wait","auth","then","d","channel","channels","undefined","messages","add","sendSlackMessage","body","slack","toString","edit","reason","startsWith","resolveImage","patch","delete","createdTimestamp","deconstruct","timestamp","createdAt","Date","url","http","avatarURL","format","size","rest","cdn","Avatar","applyToClass","structure","prop","prototype","getOwnPropertyDescriptor","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst APIMessage = require('./APIMessage');\nconst Channel = require('./Channel');\nconst { WebhookTypes } = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst Snowflake = require('../util/Snowflake');\n\n/**\n * Represents a webhook.\n */\nclass Webhook {\n  constructor(client, data) {\n    /**\n     * The client that instantiated the webhook\n     * @name Webhook#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', { value: client });\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The name of the webhook\n     * @type {string}\n     */\n    this.name = data.name;\n\n    /**\n     * The token for the webhook\n     * @name Webhook#token\n     * @type {?string}\n     */\n    Object.defineProperty(this, 'token', { value: data.token || null, writable: true, configurable: true });\n\n    /**\n     * The avatar for the webhook\n     * @type {?string}\n     */\n    this.avatar = data.avatar;\n\n    /**\n     * The ID of the webhook\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    /**\n     * The type of the webhook\n     * @type {WebhookTypes}\n     */\n    this.type = WebhookTypes[data.type];\n\n    /**\n     * The guild the webhook belongs to\n     * @type {Snowflake}\n     */\n    this.guildID = data.guild_id;\n\n    /**\n     * The channel the webhook belongs to\n     * @type {Snowflake}\n     */\n    this.channelID = data.channel_id;\n\n    if (data.user) {\n      /**\n       * The owner of the webhook\n       * @type {?User|Object}\n       */\n      this.owner = this.client.users ? this.client.users.cache.get(data.user.id) : data.user;\n    } else {\n      this.owner = null;\n    }\n  }\n\n  /**\n   * Options that can be passed into send.\n   * @typedef {Object} WebhookMessageOptions\n   * @property {string} [username=this.name] Username override for the message\n   * @property {string} [avatarURL] Avatar URL override for the message\n   * @property {boolean} [tts=false] Whether or not the message should be spoken aloud\n   * @property {string} [nonce=''] The nonce for the message\n   * @property {Object[]} [embeds] An array of embeds for the message\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   * (see [here](https://discord.com/developers/docs/resources/channel#embed-object) for more details)\n   * @property {DisableMentionType} [disableMentions=this.client.options.disableMentions] Whether or not all mentions or\n   * everyone/here mentions should be sanitized to prevent unexpected mentions\n   * @property {FileOptions[]|string[]} [files] Files to send with the message\n   * @property {string|boolean} [code] Language for optional codeblock formatting to apply\n   * @property {boolean|SplitOptions} [split=false] Whether or not the message should be split into multiple messages if\n   * it exceeds the character limit. If an object is provided, these are the options for splitting the message.\n   */\n\n  /**\n   * Sends a message with this webhook.\n   * @param {StringResolvable|APIMessage} [content=''] The content to send\n   * @param {WebhookMessageOptions|MessageAdditions} [options={}] The options to provide\n   * @returns {Promise<Message|Object>}\n   * @example\n   * // Send a basic message\n   * webhook.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * webhook.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * webhook.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send an embed with a local image inside\n   * webhook.send('This is an embed', {\n   *   embeds: [{\n   *     thumbnail: {\n   *          url: 'attachment://file.jpg'\n   *       }\n   *    }],\n   *    files: [{\n   *       attachment: 'entire/path/to/file.jpg',\n   *       name: 'file.jpg'\n   *    }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async send(content, options) {\n    let apiMessage;\n\n    if (content instanceof APIMessage) {\n      apiMessage = content.resolveData();\n    } else {\n      apiMessage = APIMessage.create(this, content, options).resolveData();\n      if (Array.isArray(apiMessage.data.content)) {\n        return Promise.all(apiMessage.split().map(this.send.bind(this)));\n      }\n    }\n\n    const { data, files } = await apiMessage.resolveFiles();\n    return this.client.api\n      .webhooks(this.id, this.token)\n      .post({\n        data,\n        files,\n        query: { wait: true },\n        auth: false,\n      })\n      .then(d => {\n        const channel = this.client.channels ? this.client.channels.cache.get(d.channel_id) : undefined;\n        if (!channel) return d;\n        return channel.messages.add(d, false);\n      });\n  }\n\n  /**\n   * Sends a raw slack message with this webhook.\n   * @param {Object} body The raw body to send\n   * @returns {Promise<boolean>}\n   * @example\n   * // Send a slack message\n   * webhook.sendSlackMessage({\n   *   'username': 'Wumpus',\n   *   'attachments': [{\n   *     'pretext': 'this looks pretty cool',\n   *     'color': '#F0F',\n   *     'footer_icon': 'http://snek.s3.amazonaws.com/topSnek.png',\n   *     'footer': 'Powered by sneks',\n   *     'ts': Date.now() / 1000\n   *   }]\n   * }).catch(console.error);\n   */\n  sendSlackMessage(body) {\n    return this.client.api\n      .webhooks(this.id, this.token)\n      .slack.post({\n        query: { wait: true },\n        auth: false,\n        data: body,\n      })\n      .then(data => data.toString() === 'ok');\n  }\n\n  /**\n   * Edits the webhook.\n   * @param {Object} options Options\n   * @param {string} [options.name=this.name] New name for this webhook\n   * @param {BufferResolvable} [options.avatar] New avatar for this webhook\n   * @param {ChannelResolvable} [options.channel] New channel for this webhook\n   * @param {string} [reason] Reason for editing this webhook\n   * @returns {Promise<Webhook>}\n   */\n  async edit({ name = this.name, avatar, channel }, reason) {\n    if (avatar && typeof avatar === 'string' && !avatar.startsWith('data:')) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n    if (channel) channel = channel instanceof Channel ? channel.id : channel;\n    const data = await this.client.api.webhooks(this.id, channel ? undefined : this.token).patch({\n      data: { name, avatar, channel_id: channel },\n      reason,\n    });\n\n    this.name = data.name;\n    this.avatar = data.avatar;\n    this.channelID = data.channel_id;\n    return this;\n  }\n\n  /**\n   * Deletes the webhook.\n   * @param {string} [reason] Reason for deleting this webhook\n   * @returns {Promise}\n   */\n  delete(reason) {\n    return this.client.api.webhooks(this.id, this.token).delete({ reason });\n  }\n  /**\n   * The timestamp the webhook was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n\n  /**\n   * The time the webhook was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The url of this webhook\n   * @type {string}\n   * @readonly\n   */\n  get url() {\n    return this.client.options.http.api + this.client.api.webhooks(this.id, this.token);\n  }\n\n  /**\n   * A link to the webhook's avatar.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n  avatarURL({ format, size } = {}) {\n    if (!this.avatar) return null;\n    return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size);\n  }\n\n  static applyToClass(structure) {\n    for (const prop of ['send', 'sendSlackMessage', 'edit', 'delete', 'createdTimestamp', 'createdAt', 'url']) {\n      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook.prototype, prop));\n    }\n  }\n}\n\nmodule.exports = Webhook;\n"]},"metadata":{},"sourceType":"script"}