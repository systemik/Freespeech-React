{"ast":null,"code":"'use strict';\n\nconst APIMessage = require('./APIMessage');\n\nconst Base = require('./Base');\n\nconst ClientApplication = require('./ClientApplication');\n\nconst MessageAttachment = require('./MessageAttachment');\n\nconst Embed = require('./MessageEmbed');\n\nconst Mentions = require('./MessageMentions');\n\nconst ReactionCollector = require('./ReactionCollector');\n\nconst {\n  Error,\n  TypeError\n} = require('../errors');\n\nconst ReactionManager = require('../managers/ReactionManager');\n\nconst Collection = require('../util/Collection');\n\nconst {\n  MessageTypes\n} = require('../util/Constants');\n\nconst MessageFlags = require('../util/MessageFlags');\n\nconst Permissions = require('../util/Permissions');\n\nconst SnowflakeUtil = require('../util/Snowflake');\n\nconst Util = require('../util/Util');\n/**\n * Represents a message on Discord.\n * @extends {Base}\n */\n\n\nclass Message extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the message\n   * @param {TextChannel|DMChannel|NewsChannel} channel The channel the message was sent in\n   */\n  constructor(client, data, channel) {\n    super(client);\n    /**\n     * The channel that the message was sent in\n     * @type {TextChannel|DMChannel|NewsChannel}\n     */\n\n    this.channel = channel;\n    /**\n     * Whether this message has been deleted\n     * @type {boolean}\n     */\n\n    this.deleted = false;\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The ID of the message\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    if ('type' in data) {\n      /**\n       * The type of the message\n       * @type {?MessageType}\n       */\n      this.type = MessageTypes[data.type];\n      /**\n       * Whether or not this message was sent by Discord, not actually a user (e.g. pin notifications)\n       * @type {?boolean}\n       */\n\n      this.system = data.type !== 0;\n    } else if (typeof this.type !== 'string') {\n      this.system = null;\n      this.type = null;\n    }\n\n    if ('content' in data) {\n      /**\n       * The content of the message\n       * @type {?string}\n       */\n      this.content = data.content;\n    } else if (typeof this.content !== 'string') {\n      this.content = null;\n    }\n\n    if ('author' in data) {\n      /**\n       * The author of the message\n       * @type {?User}\n       */\n      this.author = this.client.users.add(data.author, !data.webhook_id);\n    } else if (!this.author) {\n      this.author = null;\n    }\n\n    if ('pinned' in data) {\n      /**\n       * Whether or not this message is pinned\n       * @type {?boolean}\n       */\n      this.pinned = Boolean(data.pinned);\n    } else if (typeof this.pinned !== 'boolean') {\n      this.pinned = null;\n    }\n\n    if ('tts' in data) {\n      /**\n       * Whether or not the message was Text-To-Speech\n       * @type {?boolean}\n       */\n      this.tts = data.tts;\n    } else if (typeof this.tts !== 'boolean') {\n      this.tts = null;\n    }\n    /**\n     * A random number or string used for checking message delivery\n     * <warn>This is only received after the message was sent successfully, and\n     * lost if re-fetched</warn>\n     * @type {?string}\n     */\n\n\n    this.nonce = 'nonce' in data ? data.nonce : null;\n    /**\n     * A list of embeds in the message - e.g. YouTube Player\n     * @type {MessageEmbed[]}\n     */\n\n    this.embeds = (data.embeds || []).map(e => new Embed(e, true));\n    /**\n     * A collection of attachments in the message - e.g. Pictures - mapped by their ID\n     * @type {Collection<Snowflake, MessageAttachment>}\n     */\n\n    this.attachments = new Collection();\n\n    if (data.attachments) {\n      for (const attachment of data.attachments) {\n        this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));\n      }\n    }\n    /**\n     * The timestamp the message was sent at\n     * @type {number}\n     */\n\n\n    this.createdTimestamp = SnowflakeUtil.deconstruct(this.id).timestamp;\n    /**\n     * The timestamp the message was last edited at (if applicable)\n     * @type {?number}\n     */\n\n    this.editedTimestamp = 'edited_timestamp' in data ? new Date(data.edited_timestamp).getTime() : null;\n    /**\n     * A manager of the reactions belonging to this message\n     * @type {ReactionManager}\n     */\n\n    this.reactions = new ReactionManager(this);\n\n    if (data.reactions && data.reactions.length > 0) {\n      for (const reaction of data.reactions) {\n        this.reactions.add(reaction);\n      }\n    }\n    /**\n     * All valid mentions that the message contains\n     * @type {MessageMentions}\n     */\n\n\n    this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone, data.mention_channels);\n    /**\n     * ID of the webhook that sent the message, if applicable\n     * @type {?Snowflake}\n     */\n\n    this.webhookID = data.webhook_id || null;\n    /**\n     * Supplemental application information for group activities\n     * @type {?ClientApplication}\n     */\n\n    this.application = data.application ? new ClientApplication(this.client, data.application) : null;\n    /**\n     * Group activity\n     * @type {?MessageActivity}\n     */\n\n    this.activity = data.activity ? {\n      partyID: data.activity.party_id,\n      type: data.activity.type\n    } : null;\n    /**\n     * The previous versions of the message, sorted with the most recent first\n     * @type {Message[]}\n     * @private\n     */\n\n    this._edits = [];\n\n    if (this.member && data.member) {\n      this.member._patch(data.member);\n    } else if (data.member && this.guild && this.author) {\n      this.guild.members.add(Object.assign(data.member, {\n        user: this.author\n      }));\n    }\n    /**\n     * Flags that are applied to the message\n     * @type {Readonly<MessageFlags>}\n     */\n\n\n    this.flags = new MessageFlags(data.flags).freeze();\n    /**\n     * Reference data sent in a crossposted message.\n     * @typedef {Object} MessageReference\n     * @property {string} channelID ID of the channel the message was crossposted from\n     * @property {?string} guildID ID of the guild the message was crossposted from\n     * @property {?string} messageID ID of the message that was crossposted\n     */\n\n    /**\n     * Message reference data\n     * @type {?MessageReference}\n     */\n\n    this.reference = data.message_reference ? {\n      channelID: data.message_reference.channel_id,\n      guildID: data.message_reference.guild_id,\n      messageID: data.message_reference.message_id\n    } : null;\n  }\n  /**\n   * Whether or not this message is a partial\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get partial() {\n    return typeof this.content !== 'string' || !this.author;\n  }\n  /**\n   * Updates the message and returns the old message.\n   * @param {Object} data Raw Discord message update data\n   * @returns {Message}\n   * @private\n   */\n\n\n  patch(data) {\n    const clone = this._clone();\n\n    const {\n      messageEditHistoryMaxSize\n    } = this.client.options;\n\n    if (messageEditHistoryMaxSize !== 0) {\n      const editsLimit = messageEditHistoryMaxSize === -1 ? Infinity : messageEditHistoryMaxSize;\n      if (this._edits.unshift(clone) > editsLimit) this._edits.pop();\n    }\n\n    if ('edited_timestamp' in data) this.editedTimestamp = new Date(data.edited_timestamp).getTime();\n    if ('content' in data) this.content = data.content;\n    if ('pinned' in data) this.pinned = data.pinned;\n    if ('tts' in data) this.tts = data.tts;\n    if ('embeds' in data) this.embeds = data.embeds.map(e => new Embed(e, true));else this.embeds = this.embeds.slice();\n\n    if ('attachments' in data) {\n      this.attachments = new Collection();\n\n      for (const attachment of data.attachments) {\n        this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));\n      }\n    } else {\n      this.attachments = new Collection(this.attachments);\n    }\n\n    this.mentions = new Mentions(this, 'mentions' in data ? data.mentions : this.mentions.users, 'mention_roles' in data ? data.mention_roles : this.mentions.roles, 'mention_everyone' in data ? data.mention_everyone : this.mentions.everyone, 'mention_channels' in data ? data.mention_channels : this.mentions.crosspostedChannels);\n    this.flags = new MessageFlags('flags' in data ? data.flags : 0).freeze();\n    return clone;\n  }\n  /**\n   * Represents the author of the message as a guild member.\n   * Only available if the message comes from a guild where the author is still a member\n   * @type {?GuildMember}\n   * @readonly\n   */\n\n\n  get member() {\n    return this.guild ? this.guild.member(this.author) || null : null;\n  }\n  /**\n   * The time the message was sent at\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * The time the message was last edited at (if applicable)\n   * @type {?Date}\n   * @readonly\n   */\n\n\n  get editedAt() {\n    return this.editedTimestamp ? new Date(this.editedTimestamp) : null;\n  }\n  /**\n   * The guild the message was sent in (if in a guild channel)\n   * @type {?Guild}\n   * @readonly\n   */\n\n\n  get guild() {\n    return this.channel.guild || null;\n  }\n  /**\n   * The url to jump to this message\n   * @type {string}\n   * @readonly\n   */\n\n\n  get url() {\n    return `https://discord.com/channels/${this.guild ? this.guild.id : '@me'}/${this.channel.id}/${this.id}`;\n  }\n  /**\n   * The message contents with all mentions replaced by the equivalent text.\n   * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.\n   * @type {string}\n   * @readonly\n   */\n\n\n  get cleanContent() {\n    // eslint-disable-next-line eqeqeq\n    return this.content != null ? Util.cleanContent(this.content, this) : null;\n  }\n  /**\n   * Creates a reaction collector.\n   * @param {CollectorFilter} filter The filter to apply\n   * @param {ReactionCollectorOptions} [options={}] Options to send to the collector\n   * @returns {ReactionCollector}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someID';\n   * const collector = message.createReactionCollector(filter, { time: 15000 });\n   * collector.on('collect', r => console.log(`Collected ${r.emoji.name}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n\n\n  createReactionCollector(filter) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new ReactionCollector(this, filter, options);\n  }\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {ReactionCollectorOptions} AwaitReactionsOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createReactionCollector but in promise form.\n   * Resolves with a collection of reactions that pass the specified filter.\n   * @param {CollectorFilter} filter The filter function to use\n   * @param {AwaitReactionsOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<string, MessageReaction>>}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someID'\n   * message.awaitReactions(filter, { time: 15000 })\n   *   .then(collected => console.log(`Collected ${collected.size} reactions`))\n   *   .catch(console.error);\n   */\n\n\n  awaitReactions(filter) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new Promise((resolve, reject) => {\n      const collector = this.createReactionCollector(filter, options);\n      collector.once('end', (reactions, reason) => {\n        if (options.errors && options.errors.includes(reason)) reject(reactions);else resolve(reactions);\n      });\n    });\n  }\n  /**\n   * An array of cached versions of the message, including the current version\n   * Sorted from latest (first) to oldest (last)\n   * @type {Message[]}\n   * @readonly\n   */\n\n\n  get edits() {\n    const copy = this._edits.slice();\n\n    copy.unshift(this);\n    return copy;\n  }\n  /**\n   * Whether the message is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get editable() {\n    return this.author.id === this.client.user.id;\n  }\n  /**\n   * Whether the message is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get deletable() {\n    return !this.deleted && (this.author.id === this.client.user.id || this.guild && this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES, false));\n  }\n  /**\n   * Whether the message is pinnable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get pinnable() {\n    return this.type === 'DEFAULT' && (!this.guild || this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES, false));\n  }\n  /**\n   * Whether the message is crosspostable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get crosspostable() {\n    return this.channel.type === 'news' && !this.flags.has(MessageFlags.FLAGS.CROSSPOSTED) && this.type === 'DEFAULT' && this.channel.viewable && this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.SEND_MESSAGES) && (this.author.id === this.client.user.id || this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES));\n  }\n  /**\n   * Options that can be passed into editMessage.\n   * @typedef {Object} MessageEditOptions\n   * @property {string} [content] Content to be edited\n   * @property {MessageEmbed|Object} [embed] An embed to be added/edited\n   * @property {string|boolean} [code] Language for optional codeblock formatting to apply\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   */\n\n  /**\n   * Edits the content of the message.\n   * @param {StringResolvable|APIMessage} [content] The new content for the message\n   * @param {MessageEditOptions|MessageEmbed} [options] The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Update the content of a message\n   * message.edit('This is my new content!')\n   *   .then(msg => console.log(`Updated the content of a message to ${msg.content}`))\n   *   .catch(console.error);\n   */\n\n\n  edit(content, options) {\n    const {\n      data\n    } = content instanceof APIMessage ? content.resolveData() : APIMessage.create(this, content, options).resolveData();\n    return this.client.api.channels[this.channel.id].messages[this.id].patch({\n      data\n    }).then(d => {\n      const clone = this._clone();\n\n      clone._patch(d);\n\n      return clone;\n    });\n  }\n  /**\n   * Publishes a message in an announcement channel to all channels following it.\n   * @returns {Promise<Message>}\n   * @example\n   * // Crosspost a message\n   * if (message.channel.type === 'news') {\n   *   message.crosspost()\n   *     .then(() => console.log('Crossposted message'))\n   *     .catch(console.error);\n   * }\n   */\n\n\n  async crosspost() {\n    await this.client.api.channels(this.channel.id).messages(this.id).crosspost.post();\n    return this;\n  }\n  /**\n   * Pins this message to the channel's pinned messages.\n   * @param {Object} [options] Options for pinning\n   * @param {string} [options.reason] Reason for pinning\n   * @returns {Promise<Message>}\n   * @example\n   * // Pin a message with a reason\n   * message.pin({ reason: 'important' })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n\n\n  pin(options) {\n    return this.client.api.channels(this.channel.id).pins(this.id).put(options).then(() => this);\n  }\n  /**\n   * Unpins this message from the channel's pinned messages.\n   * @param {Object} [options] Options for unpinning\n   * @param {string} [options.reason] Reason for unpinning\n   * @returns {Promise<Message>}\n   * @example\n   * // Unpin a message with a reason\n   * message.unpin({ reason: 'no longer relevant' })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n\n\n  unpin(options) {\n    return this.client.api.channels(this.channel.id).pins(this.id).delete(options).then(() => this);\n  }\n  /**\n   * Adds a reaction to the message.\n   * @param {EmojiIdentifierResolvable} emoji The emoji to react with\n   * @returns {Promise<MessageReaction>}\n   * @example\n   * // React to a message with a unicode emoji\n   * message.react('🤔')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // React to a message with a custom emoji\n   * message.react(message.guild.emojis.cache.get('123456789012345678'))\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  react(emoji) {\n    emoji = this.client.emojis.resolveIdentifier(emoji);\n    if (!emoji) throw new TypeError('EMOJI_TYPE');\n    return this.client.api.channels(this.channel.id).messages(this.id).reactions(emoji, '@me').put().then(() => this.client.actions.MessageReactionAdd.handle({\n      user: this.client.user,\n      channel: this.channel,\n      message: this,\n      emoji: Util.parseEmoji(emoji)\n    }).reaction);\n  }\n  /**\n   * Deletes the message.\n   * @param {Object} [options] Options\n   * @param {number} [options.timeout=0] How long to wait to delete the message in milliseconds\n   * @param {string} [options.reason] Reason for deleting this message, if it does not belong to the client user\n   * @returns {Promise<Message>}\n   * @example\n   * // Delete a message\n   * message.delete({ timeout: 5000 })\n   *   .then(msg => console.log(`Deleted message from ${msg.author.username} after 5 seconds`))\n   *   .catch(console.error);\n   */\n\n\n  delete() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (typeof options !== 'object') return Promise.reject(new TypeError('INVALID_TYPE', 'options', 'object', true));\n    const {\n      timeout = 0,\n      reason\n    } = options;\n\n    if (timeout <= 0) {\n      return this.channel.messages.delete(this.id, reason).then(() => this);\n    } else {\n      return new Promise(resolve => {\n        this.client.setTimeout(() => {\n          resolve(this.delete({\n            reason\n          }));\n        }, timeout);\n      });\n    }\n  }\n  /**\n   * Replies to the message.\n   * @param {StringResolvable|APIMessage} [content=''] The content for the message\n   * @param {MessageOptions|MessageAdditions} [options={}] The options to provide\n   * @returns {Promise<Message|Message[]>}\n   * @example\n   * // Reply to a message\n   * message.reply('Hey, I\\'m a reply!')\n   *   .then(() => console.log(`Sent a reply to ${message.author.username}`))\n   *   .catch(console.error);\n   */\n\n\n  reply(content, options) {\n    return this.channel.send(content instanceof APIMessage ? content : APIMessage.transformOptions(content, options, {\n      reply: this.member || this.author\n    }));\n  }\n  /**\n   * Fetch this message.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Message>}\n   */\n\n\n  fetch() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this.channel.messages.fetch(this.id, true, force);\n  }\n  /**\n   * Fetches the webhook used to create this message.\n   * @returns {Promise<?Webhook>}\n   */\n\n\n  fetchWebhook() {\n    if (!this.webhookID) return Promise.reject(new Error('WEBHOOK_MESSAGE'));\n    return this.client.fetchWebhook(this.webhookID);\n  }\n  /**\n   * Suppresses or unsuppresses embeds on a message\n   * @param {boolean} [suppress=true] If the embeds should be suppressed or not\n   * @returns {Promise<Message>}\n   */\n\n\n  suppressEmbeds() {\n    let suppress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const flags = new MessageFlags(this.flags.bitfield);\n\n    if (suppress) {\n      flags.add(MessageFlags.FLAGS.SUPPRESS_EMBEDS);\n    } else {\n      flags.remove(MessageFlags.FLAGS.SUPPRESS_EMBEDS);\n    }\n\n    return this.edit({\n      flags\n    });\n  }\n  /**\n   * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages\n   * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This\n   * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.\n   * @param {Message} message The message to compare it to\n   * @param {Object} rawData Raw data passed through the WebSocket about this message\n   * @returns {boolean}\n   */\n\n\n  equals(message, rawData) {\n    if (!message) return false;\n    const embedUpdate = !message.author && !message.attachments;\n    if (embedUpdate) return this.id === message.id && this.embeds.length === message.embeds.length;\n    let equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.tts === message.tts && this.nonce === message.nonce && this.embeds.length === message.embeds.length && this.attachments.length === message.attachments.length;\n\n    if (equal && rawData) {\n      equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === new Date(rawData.timestamp).getTime() && this.editedTimestamp === new Date(rawData.edited_timestamp).getTime();\n    }\n\n    return equal;\n  }\n  /**\n   * When concatenated with a string, this automatically concatenates the message's content instead of the object.\n   * @returns {string}\n   * @example\n   * // Logs: Message: This is a message!\n   * console.log(`Message: ${message}`);\n   */\n\n\n  toString() {\n    return this.content;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      channel: 'channelID',\n      author: 'authorID',\n      application: 'applicationID',\n      guild: 'guildID',\n      cleanContent: true,\n      member: false,\n      reactions: false\n    });\n  }\n\n}\n\nmodule.exports = Message;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/structures/Message.js"],"names":["APIMessage","require","Base","ClientApplication","MessageAttachment","Embed","Mentions","ReactionCollector","Error","TypeError","ReactionManager","Collection","MessageTypes","MessageFlags","Permissions","SnowflakeUtil","Util","Message","constructor","client","data","channel","deleted","_patch","id","type","system","content","author","users","add","webhook_id","pinned","Boolean","tts","nonce","embeds","map","e","attachments","attachment","set","url","filename","createdTimestamp","deconstruct","timestamp","editedTimestamp","Date","edited_timestamp","getTime","reactions","length","reaction","mentions","mention_roles","mention_everyone","mention_channels","webhookID","application","activity","partyID","party_id","_edits","member","guild","members","Object","assign","user","flags","freeze","reference","message_reference","channelID","channel_id","guildID","guild_id","messageID","message_id","partial","patch","clone","_clone","messageEditHistoryMaxSize","options","editsLimit","Infinity","unshift","pop","slice","roles","everyone","crosspostedChannels","createdAt","editedAt","cleanContent","createReactionCollector","filter","awaitReactions","Promise","resolve","reject","collector","once","reason","errors","includes","edits","copy","editable","deletable","permissionsFor","has","FLAGS","MANAGE_MESSAGES","pinnable","crosspostable","CROSSPOSTED","viewable","SEND_MESSAGES","edit","resolveData","create","api","channels","messages","then","d","crosspost","post","pin","pins","put","unpin","delete","react","emoji","emojis","resolveIdentifier","actions","MessageReactionAdd","handle","message","parseEmoji","timeout","setTimeout","reply","send","transformOptions","fetch","force","fetchWebhook","suppressEmbeds","suppress","bitfield","SUPPRESS_EMBEDS","remove","equals","rawData","embedUpdate","equal","toString","toJSON","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst APIMessage = require('./APIMessage');\nconst Base = require('./Base');\nconst ClientApplication = require('./ClientApplication');\nconst MessageAttachment = require('./MessageAttachment');\nconst Embed = require('./MessageEmbed');\nconst Mentions = require('./MessageMentions');\nconst ReactionCollector = require('./ReactionCollector');\nconst { Error, TypeError } = require('../errors');\nconst ReactionManager = require('../managers/ReactionManager');\nconst Collection = require('../util/Collection');\nconst { MessageTypes } = require('../util/Constants');\nconst MessageFlags = require('../util/MessageFlags');\nconst Permissions = require('../util/Permissions');\nconst SnowflakeUtil = require('../util/Snowflake');\nconst Util = require('../util/Util');\n\n/**\n * Represents a message on Discord.\n * @extends {Base}\n */\nclass Message extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the message\n   * @param {TextChannel|DMChannel|NewsChannel} channel The channel the message was sent in\n   */\n  constructor(client, data, channel) {\n    super(client);\n\n    /**\n     * The channel that the message was sent in\n     * @type {TextChannel|DMChannel|NewsChannel}\n     */\n    this.channel = channel;\n\n    /**\n     * Whether this message has been deleted\n     * @type {boolean}\n     */\n    this.deleted = false;\n\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The ID of the message\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    if ('type' in data) {\n      /**\n       * The type of the message\n       * @type {?MessageType}\n       */\n      this.type = MessageTypes[data.type];\n\n      /**\n       * Whether or not this message was sent by Discord, not actually a user (e.g. pin notifications)\n       * @type {?boolean}\n       */\n      this.system = data.type !== 0;\n    } else if (typeof this.type !== 'string') {\n      this.system = null;\n      this.type = null;\n    }\n\n    if ('content' in data) {\n      /**\n       * The content of the message\n       * @type {?string}\n       */\n      this.content = data.content;\n    } else if (typeof this.content !== 'string') {\n      this.content = null;\n    }\n\n    if ('author' in data) {\n      /**\n       * The author of the message\n       * @type {?User}\n       */\n      this.author = this.client.users.add(data.author, !data.webhook_id);\n    } else if (!this.author) {\n      this.author = null;\n    }\n\n    if ('pinned' in data) {\n      /**\n       * Whether or not this message is pinned\n       * @type {?boolean}\n       */\n      this.pinned = Boolean(data.pinned);\n    } else if (typeof this.pinned !== 'boolean') {\n      this.pinned = null;\n    }\n\n    if ('tts' in data) {\n      /**\n       * Whether or not the message was Text-To-Speech\n       * @type {?boolean}\n       */\n      this.tts = data.tts;\n    } else if (typeof this.tts !== 'boolean') {\n      this.tts = null;\n    }\n\n    /**\n     * A random number or string used for checking message delivery\n     * <warn>This is only received after the message was sent successfully, and\n     * lost if re-fetched</warn>\n     * @type {?string}\n     */\n    this.nonce = 'nonce' in data ? data.nonce : null;\n\n    /**\n     * A list of embeds in the message - e.g. YouTube Player\n     * @type {MessageEmbed[]}\n     */\n    this.embeds = (data.embeds || []).map(e => new Embed(e, true));\n\n    /**\n     * A collection of attachments in the message - e.g. Pictures - mapped by their ID\n     * @type {Collection<Snowflake, MessageAttachment>}\n     */\n    this.attachments = new Collection();\n    if (data.attachments) {\n      for (const attachment of data.attachments) {\n        this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));\n      }\n    }\n\n    /**\n     * The timestamp the message was sent at\n     * @type {number}\n     */\n    this.createdTimestamp = SnowflakeUtil.deconstruct(this.id).timestamp;\n\n    /**\n     * The timestamp the message was last edited at (if applicable)\n     * @type {?number}\n     */\n    this.editedTimestamp = 'edited_timestamp' in data ? new Date(data.edited_timestamp).getTime() : null;\n\n    /**\n     * A manager of the reactions belonging to this message\n     * @type {ReactionManager}\n     */\n    this.reactions = new ReactionManager(this);\n    if (data.reactions && data.reactions.length > 0) {\n      for (const reaction of data.reactions) {\n        this.reactions.add(reaction);\n      }\n    }\n\n    /**\n     * All valid mentions that the message contains\n     * @type {MessageMentions}\n     */\n    this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone, data.mention_channels);\n\n    /**\n     * ID of the webhook that sent the message, if applicable\n     * @type {?Snowflake}\n     */\n    this.webhookID = data.webhook_id || null;\n\n    /**\n     * Supplemental application information for group activities\n     * @type {?ClientApplication}\n     */\n    this.application = data.application ? new ClientApplication(this.client, data.application) : null;\n\n    /**\n     * Group activity\n     * @type {?MessageActivity}\n     */\n    this.activity = data.activity\n      ? {\n          partyID: data.activity.party_id,\n          type: data.activity.type,\n        }\n      : null;\n\n    /**\n     * The previous versions of the message, sorted with the most recent first\n     * @type {Message[]}\n     * @private\n     */\n    this._edits = [];\n\n    if (this.member && data.member) {\n      this.member._patch(data.member);\n    } else if (data.member && this.guild && this.author) {\n      this.guild.members.add(Object.assign(data.member, { user: this.author }));\n    }\n\n    /**\n     * Flags that are applied to the message\n     * @type {Readonly<MessageFlags>}\n     */\n    this.flags = new MessageFlags(data.flags).freeze();\n\n    /**\n     * Reference data sent in a crossposted message.\n     * @typedef {Object} MessageReference\n     * @property {string} channelID ID of the channel the message was crossposted from\n     * @property {?string} guildID ID of the guild the message was crossposted from\n     * @property {?string} messageID ID of the message that was crossposted\n     */\n\n    /**\n     * Message reference data\n     * @type {?MessageReference}\n     */\n    this.reference = data.message_reference\n      ? {\n          channelID: data.message_reference.channel_id,\n          guildID: data.message_reference.guild_id,\n          messageID: data.message_reference.message_id,\n        }\n      : null;\n  }\n\n  /**\n   * Whether or not this message is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return typeof this.content !== 'string' || !this.author;\n  }\n\n  /**\n   * Updates the message and returns the old message.\n   * @param {Object} data Raw Discord message update data\n   * @returns {Message}\n   * @private\n   */\n  patch(data) {\n    const clone = this._clone();\n    const { messageEditHistoryMaxSize } = this.client.options;\n    if (messageEditHistoryMaxSize !== 0) {\n      const editsLimit = messageEditHistoryMaxSize === -1 ? Infinity : messageEditHistoryMaxSize;\n      if (this._edits.unshift(clone) > editsLimit) this._edits.pop();\n    }\n\n    if ('edited_timestamp' in data) this.editedTimestamp = new Date(data.edited_timestamp).getTime();\n    if ('content' in data) this.content = data.content;\n    if ('pinned' in data) this.pinned = data.pinned;\n    if ('tts' in data) this.tts = data.tts;\n    if ('embeds' in data) this.embeds = data.embeds.map(e => new Embed(e, true));\n    else this.embeds = this.embeds.slice();\n\n    if ('attachments' in data) {\n      this.attachments = new Collection();\n      for (const attachment of data.attachments) {\n        this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));\n      }\n    } else {\n      this.attachments = new Collection(this.attachments);\n    }\n\n    this.mentions = new Mentions(\n      this,\n      'mentions' in data ? data.mentions : this.mentions.users,\n      'mention_roles' in data ? data.mention_roles : this.mentions.roles,\n      'mention_everyone' in data ? data.mention_everyone : this.mentions.everyone,\n      'mention_channels' in data ? data.mention_channels : this.mentions.crosspostedChannels,\n    );\n\n    this.flags = new MessageFlags('flags' in data ? data.flags : 0).freeze();\n\n    return clone;\n  }\n\n  /**\n   * Represents the author of the message as a guild member.\n   * Only available if the message comes from a guild where the author is still a member\n   * @type {?GuildMember}\n   * @readonly\n   */\n  get member() {\n    return this.guild ? this.guild.member(this.author) || null : null;\n  }\n\n  /**\n   * The time the message was sent at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The time the message was last edited at (if applicable)\n   * @type {?Date}\n   * @readonly\n   */\n  get editedAt() {\n    return this.editedTimestamp ? new Date(this.editedTimestamp) : null;\n  }\n\n  /**\n   * The guild the message was sent in (if in a guild channel)\n   * @type {?Guild}\n   * @readonly\n   */\n  get guild() {\n    return this.channel.guild || null;\n  }\n\n  /**\n   * The url to jump to this message\n   * @type {string}\n   * @readonly\n   */\n  get url() {\n    return `https://discord.com/channels/${this.guild ? this.guild.id : '@me'}/${this.channel.id}/${this.id}`;\n  }\n\n  /**\n   * The message contents with all mentions replaced by the equivalent text.\n   * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.\n   * @type {string}\n   * @readonly\n   */\n  get cleanContent() {\n    // eslint-disable-next-line eqeqeq\n    return this.content != null ? Util.cleanContent(this.content, this) : null;\n  }\n\n  /**\n   * Creates a reaction collector.\n   * @param {CollectorFilter} filter The filter to apply\n   * @param {ReactionCollectorOptions} [options={}] Options to send to the collector\n   * @returns {ReactionCollector}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someID';\n   * const collector = message.createReactionCollector(filter, { time: 15000 });\n   * collector.on('collect', r => console.log(`Collected ${r.emoji.name}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createReactionCollector(filter, options = {}) {\n    return new ReactionCollector(this, filter, options);\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {ReactionCollectorOptions} AwaitReactionsOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createReactionCollector but in promise form.\n   * Resolves with a collection of reactions that pass the specified filter.\n   * @param {CollectorFilter} filter The filter function to use\n   * @param {AwaitReactionsOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<string, MessageReaction>>}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someID'\n   * message.awaitReactions(filter, { time: 15000 })\n   *   .then(collected => console.log(`Collected ${collected.size} reactions`))\n   *   .catch(console.error);\n   */\n  awaitReactions(filter, options = {}) {\n    return new Promise((resolve, reject) => {\n      const collector = this.createReactionCollector(filter, options);\n      collector.once('end', (reactions, reason) => {\n        if (options.errors && options.errors.includes(reason)) reject(reactions);\n        else resolve(reactions);\n      });\n    });\n  }\n\n  /**\n   * An array of cached versions of the message, including the current version\n   * Sorted from latest (first) to oldest (last)\n   * @type {Message[]}\n   * @readonly\n   */\n  get edits() {\n    const copy = this._edits.slice();\n    copy.unshift(this);\n    return copy;\n  }\n\n  /**\n   * Whether the message is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    return this.author.id === this.client.user.id;\n  }\n\n  /**\n   * Whether the message is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    return (\n      !this.deleted &&\n      (this.author.id === this.client.user.id ||\n        (this.guild && this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES, false)))\n    );\n  }\n\n  /**\n   * Whether the message is pinnable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get pinnable() {\n    return (\n      this.type === 'DEFAULT' &&\n      (!this.guild || this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES, false))\n    );\n  }\n\n  /**\n   * Whether the message is crosspostable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get crosspostable() {\n    return (\n      this.channel.type === 'news' &&\n      !this.flags.has(MessageFlags.FLAGS.CROSSPOSTED) &&\n      this.type === 'DEFAULT' &&\n      this.channel.viewable &&\n      this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.SEND_MESSAGES) &&\n      (this.author.id === this.client.user.id ||\n        this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES))\n    );\n  }\n\n  /**\n   * Options that can be passed into editMessage.\n   * @typedef {Object} MessageEditOptions\n   * @property {string} [content] Content to be edited\n   * @property {MessageEmbed|Object} [embed] An embed to be added/edited\n   * @property {string|boolean} [code] Language for optional codeblock formatting to apply\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   */\n\n  /**\n   * Edits the content of the message.\n   * @param {StringResolvable|APIMessage} [content] The new content for the message\n   * @param {MessageEditOptions|MessageEmbed} [options] The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Update the content of a message\n   * message.edit('This is my new content!')\n   *   .then(msg => console.log(`Updated the content of a message to ${msg.content}`))\n   *   .catch(console.error);\n   */\n  edit(content, options) {\n    const { data } =\n      content instanceof APIMessage ? content.resolveData() : APIMessage.create(this, content, options).resolveData();\n    return this.client.api.channels[this.channel.id].messages[this.id].patch({ data }).then(d => {\n      const clone = this._clone();\n      clone._patch(d);\n      return clone;\n    });\n  }\n\n  /**\n   * Publishes a message in an announcement channel to all channels following it.\n   * @returns {Promise<Message>}\n   * @example\n   * // Crosspost a message\n   * if (message.channel.type === 'news') {\n   *   message.crosspost()\n   *     .then(() => console.log('Crossposted message'))\n   *     .catch(console.error);\n   * }\n   */\n  async crosspost() {\n    await this.client.api.channels(this.channel.id).messages(this.id).crosspost.post();\n    return this;\n  }\n\n  /**\n   * Pins this message to the channel's pinned messages.\n   * @param {Object} [options] Options for pinning\n   * @param {string} [options.reason] Reason for pinning\n   * @returns {Promise<Message>}\n   * @example\n   * // Pin a message with a reason\n   * message.pin({ reason: 'important' })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  pin(options) {\n    return this.client.api\n      .channels(this.channel.id)\n      .pins(this.id)\n      .put(options)\n      .then(() => this);\n  }\n\n  /**\n   * Unpins this message from the channel's pinned messages.\n   * @param {Object} [options] Options for unpinning\n   * @param {string} [options.reason] Reason for unpinning\n   * @returns {Promise<Message>}\n   * @example\n   * // Unpin a message with a reason\n   * message.unpin({ reason: 'no longer relevant' })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  unpin(options) {\n    return this.client.api\n      .channels(this.channel.id)\n      .pins(this.id)\n      .delete(options)\n      .then(() => this);\n  }\n\n  /**\n   * Adds a reaction to the message.\n   * @param {EmojiIdentifierResolvable} emoji The emoji to react with\n   * @returns {Promise<MessageReaction>}\n   * @example\n   * // React to a message with a unicode emoji\n   * message.react('🤔')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // React to a message with a custom emoji\n   * message.react(message.guild.emojis.cache.get('123456789012345678'))\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  react(emoji) {\n    emoji = this.client.emojis.resolveIdentifier(emoji);\n    if (!emoji) throw new TypeError('EMOJI_TYPE');\n\n    return this.client.api\n      .channels(this.channel.id)\n      .messages(this.id)\n      .reactions(emoji, '@me')\n      .put()\n      .then(\n        () =>\n          this.client.actions.MessageReactionAdd.handle({\n            user: this.client.user,\n            channel: this.channel,\n            message: this,\n            emoji: Util.parseEmoji(emoji),\n          }).reaction,\n      );\n  }\n\n  /**\n   * Deletes the message.\n   * @param {Object} [options] Options\n   * @param {number} [options.timeout=0] How long to wait to delete the message in milliseconds\n   * @param {string} [options.reason] Reason for deleting this message, if it does not belong to the client user\n   * @returns {Promise<Message>}\n   * @example\n   * // Delete a message\n   * message.delete({ timeout: 5000 })\n   *   .then(msg => console.log(`Deleted message from ${msg.author.username} after 5 seconds`))\n   *   .catch(console.error);\n   */\n  delete(options = {}) {\n    if (typeof options !== 'object') return Promise.reject(new TypeError('INVALID_TYPE', 'options', 'object', true));\n    const { timeout = 0, reason } = options;\n    if (timeout <= 0) {\n      return this.channel.messages.delete(this.id, reason).then(() => this);\n    } else {\n      return new Promise(resolve => {\n        this.client.setTimeout(() => {\n          resolve(this.delete({ reason }));\n        }, timeout);\n      });\n    }\n  }\n\n  /**\n   * Replies to the message.\n   * @param {StringResolvable|APIMessage} [content=''] The content for the message\n   * @param {MessageOptions|MessageAdditions} [options={}] The options to provide\n   * @returns {Promise<Message|Message[]>}\n   * @example\n   * // Reply to a message\n   * message.reply('Hey, I\\'m a reply!')\n   *   .then(() => console.log(`Sent a reply to ${message.author.username}`))\n   *   .catch(console.error);\n   */\n  reply(content, options) {\n    return this.channel.send(\n      content instanceof APIMessage\n        ? content\n        : APIMessage.transformOptions(content, options, { reply: this.member || this.author }),\n    );\n  }\n\n  /**\n   * Fetch this message.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Message>}\n   */\n  fetch(force = false) {\n    return this.channel.messages.fetch(this.id, true, force);\n  }\n\n  /**\n   * Fetches the webhook used to create this message.\n   * @returns {Promise<?Webhook>}\n   */\n  fetchWebhook() {\n    if (!this.webhookID) return Promise.reject(new Error('WEBHOOK_MESSAGE'));\n    return this.client.fetchWebhook(this.webhookID);\n  }\n\n  /**\n   * Suppresses or unsuppresses embeds on a message\n   * @param {boolean} [suppress=true] If the embeds should be suppressed or not\n   * @returns {Promise<Message>}\n   */\n  suppressEmbeds(suppress = true) {\n    const flags = new MessageFlags(this.flags.bitfield);\n\n    if (suppress) {\n      flags.add(MessageFlags.FLAGS.SUPPRESS_EMBEDS);\n    } else {\n      flags.remove(MessageFlags.FLAGS.SUPPRESS_EMBEDS);\n    }\n\n    return this.edit({ flags });\n  }\n\n  /**\n   * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages\n   * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This\n   * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.\n   * @param {Message} message The message to compare it to\n   * @param {Object} rawData Raw data passed through the WebSocket about this message\n   * @returns {boolean}\n   */\n  equals(message, rawData) {\n    if (!message) return false;\n    const embedUpdate = !message.author && !message.attachments;\n    if (embedUpdate) return this.id === message.id && this.embeds.length === message.embeds.length;\n\n    let equal =\n      this.id === message.id &&\n      this.author.id === message.author.id &&\n      this.content === message.content &&\n      this.tts === message.tts &&\n      this.nonce === message.nonce &&\n      this.embeds.length === message.embeds.length &&\n      this.attachments.length === message.attachments.length;\n\n    if (equal && rawData) {\n      equal =\n        this.mentions.everyone === message.mentions.everyone &&\n        this.createdTimestamp === new Date(rawData.timestamp).getTime() &&\n        this.editedTimestamp === new Date(rawData.edited_timestamp).getTime();\n    }\n\n    return equal;\n  }\n\n  /**\n   * When concatenated with a string, this automatically concatenates the message's content instead of the object.\n   * @returns {string}\n   * @example\n   * // Logs: Message: This is a message!\n   * console.log(`Message: ${message}`);\n   */\n  toString() {\n    return this.content;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      channel: 'channelID',\n      author: 'authorID',\n      application: 'applicationID',\n      guild: 'guildID',\n      cleanContent: true,\n      member: false,\n      reactions: false,\n    });\n  }\n}\n\nmodule.exports = Message;\n"]},"metadata":{},"sourceType":"script"}