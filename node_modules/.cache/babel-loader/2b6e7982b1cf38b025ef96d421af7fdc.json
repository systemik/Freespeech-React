{"ast":null,"code":"'use strict';\n\nconst {\n  parse\n} = require('path');\n\nconst fetch = require('node-fetch');\n\nconst {\n  Colors,\n  DefaultOptions,\n  Endpoints\n} = require('./Constants');\n\nconst {\n  Error: DiscordError,\n  RangeError,\n  TypeError\n} = require('../errors');\n\nconst has = (o, k) => Object.prototype.hasOwnProperty.call(o, k);\n\nconst isObject = d => typeof d === 'object' && d !== null;\n/**\n * Contains various general-purpose utility methods. These functions are also available on the base `Discord` object.\n */\n\n\nclass Util {\n  constructor() {\n    throw new Error(`The ${this.constructor.name} class may not be instantiated.`);\n  }\n  /**\n   * Flatten an object. Any properties that are collections will get converted to an array of keys.\n   * @param {Object} obj The object to flatten.\n   * @param {...Object<string, boolean|string>} [props] Specific properties to include/exclude.\n   * @returns {Object}\n   */\n\n\n  static flatten(obj) {\n    for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      props[_key - 1] = arguments[_key];\n    }\n\n    if (!isObject(obj)) return obj;\n    const objProps = Object.keys(obj).filter(k => !k.startsWith('_')).map(k => ({\n      [k]: true\n    }));\n    props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);\n    const out = {};\n\n    for (let [prop, newProp] of Object.entries(props)) {\n      if (!newProp) continue;\n      newProp = newProp === true ? prop : newProp;\n      const element = obj[prop];\n      const elemIsObj = isObject(element);\n      const valueOf = elemIsObj && typeof element.valueOf === 'function' ? element.valueOf() : null; // If it's a Collection, make the array of keys\n\n      if (element instanceof require('./Collection')) out[newProp] = Array.from(element.keys()); // If the valueOf is a Collection, use its array of keys\n      else if (valueOf instanceof require('./Collection')) out[newProp] = Array.from(valueOf.keys()); // If it's an array, flatten each element\n      else if (Array.isArray(element)) out[newProp] = element.map(e => Util.flatten(e)); // If it's an object with a primitive `valueOf`, use that value\n      else if (typeof valueOf !== 'object') out[newProp] = valueOf; // If it's a primitive\n      else if (!elemIsObj) out[newProp] = element;\n    }\n\n    return out;\n  }\n  /**\n   * Splits a string into multiple chunks at a designated character that do not exceed a specific length.\n   * @param {StringResolvable} text Content to split\n   * @param {SplitOptions} [options] Options controlling the behavior of the split\n   * @returns {string[]}\n   */\n\n\n  static splitMessage(text) {\n    let {\n      maxLength = 2000,\n      char = '\\n',\n      prepend = '',\n      append = ''\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    text = Util.resolveString(text);\n    if (text.length <= maxLength) return [text];\n    const splitText = text.split(char);\n    if (splitText.some(chunk => chunk.length > maxLength)) throw new RangeError('SPLIT_MAX_LEN');\n    const messages = [];\n    let msg = '';\n\n    for (const chunk of splitText) {\n      if (msg && (msg + char + chunk + append).length > maxLength) {\n        messages.push(msg + append);\n        msg = prepend;\n      }\n\n      msg += (msg && msg !== prepend ? char : '') + chunk;\n    }\n\n    return messages.concat(msg).filter(m => m);\n  }\n  /**\n   * Escapes any Discord-flavour markdown in a string.\n   * @param {string} text Content to escape\n   * @param {Object} [options={}] What types of markdown to escape\n   * @param {boolean} [options.codeBlock=true] Whether to escape code blocks or not\n   * @param {boolean} [options.inlineCode=true] Whether to escape inline code or not\n   * @param {boolean} [options.bold=true] Whether to escape bolds or not\n   * @param {boolean} [options.italic=true] Whether to escape italics or not\n   * @param {boolean} [options.underline=true] Whether to escape underlines or not\n   * @param {boolean} [options.strikethrough=true] Whether to escape strikethroughs or not\n   * @param {boolean} [options.spoiler=true] Whether to escape spoilers or not\n   * @param {boolean} [options.codeBlockContent=true] Whether to escape text inside code blocks or not\n   * @param {boolean} [options.inlineCodeContent=true] Whether to escape text inside inline code or not\n   * @returns {string}\n   */\n\n\n  static escapeMarkdown(text) {\n    let {\n      codeBlock = true,\n      inlineCode = true,\n      bold = true,\n      italic = true,\n      underline = true,\n      strikethrough = true,\n      spoiler = true,\n      codeBlockContent = true,\n      inlineCodeContent = true\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!codeBlockContent) {\n      return text.split('```').map((subString, index, array) => {\n        if (index % 2 && index !== array.length - 1) return subString;\n        return Util.escapeMarkdown(subString, {\n          inlineCode,\n          bold,\n          italic,\n          underline,\n          strikethrough,\n          spoiler,\n          inlineCodeContent\n        });\n      }).join(codeBlock ? '\\\\`\\\\`\\\\`' : '```');\n    }\n\n    if (!inlineCodeContent) {\n      return text.split(/(?<=^|[^`])`(?=[^`]|$)/g).map((subString, index, array) => {\n        if (index % 2 && index !== array.length - 1) return subString;\n        return Util.escapeMarkdown(subString, {\n          codeBlock,\n          bold,\n          italic,\n          underline,\n          strikethrough,\n          spoiler\n        });\n      }).join(inlineCode ? '\\\\`' : '`');\n    }\n\n    if (inlineCode) text = Util.escapeInlineCode(text);\n    if (codeBlock) text = Util.escapeCodeBlock(text);\n    if (italic) text = Util.escapeItalic(text);\n    if (bold) text = Util.escapeBold(text);\n    if (underline) text = Util.escapeUnderline(text);\n    if (strikethrough) text = Util.escapeStrikethrough(text);\n    if (spoiler) text = Util.escapeSpoiler(text);\n    return text;\n  }\n  /**\n   * Escapes code block markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeCodeBlock(text) {\n    return text.replace(/```/g, '\\\\`\\\\`\\\\`');\n  }\n  /**\n   * Escapes inline code markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeInlineCode(text) {\n    return text.replace(/(?<=^|[^`])`(?=[^`]|$)/g, '\\\\`');\n  }\n  /**\n   * Escapes italic markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeItalic(text) {\n    let i = 0;\n    text = text.replace(/(?<=^|[^*])\\*([^*]|\\*\\*|$)/g, (_, match) => {\n      if (match === '**') return ++i % 2 ? `\\\\*${match}` : `${match}\\\\*`;\n      return `\\\\*${match}`;\n    });\n    i = 0;\n    return text.replace(/(?<=^|[^_])_([^_]|__|$)/g, (_, match) => {\n      if (match === '__') return ++i % 2 ? `\\\\_${match}` : `${match}\\\\_`;\n      return `\\\\_${match}`;\n    });\n  }\n  /**\n   * Escapes bold markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeBold(text) {\n    let i = 0;\n    return text.replace(/\\*\\*(\\*)?/g, (_, match) => {\n      if (match) return ++i % 2 ? `${match}\\\\*\\\\*` : `\\\\*\\\\*${match}`;\n      return '\\\\*\\\\*';\n    });\n  }\n  /**\n   * Escapes underline markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeUnderline(text) {\n    let i = 0;\n    return text.replace(/__(_)?/g, (_, match) => {\n      if (match) return ++i % 2 ? `${match}\\\\_\\\\_` : `\\\\_\\\\_${match}`;\n      return '\\\\_\\\\_';\n    });\n  }\n  /**\n   * Escapes strikethrough markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeStrikethrough(text) {\n    return text.replace(/~~/g, '\\\\~\\\\~');\n  }\n  /**\n   * Escapes spoiler markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeSpoiler(text) {\n    return text.replace(/\\|\\|/g, '\\\\|\\\\|');\n  }\n  /**\n   * Gets the recommended shard count from Discord.\n   * @param {string} token Discord auth token\n   * @param {number} [guildsPerShard=1000] Number of guilds per shard\n   * @returns {Promise<number>} The recommended number of shards\n   */\n\n\n  static fetchRecommendedShards(token) {\n    let guildsPerShard = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    if (!token) throw new DiscordError('TOKEN_MISSING');\n    return fetch(`${DefaultOptions.http.api}/v${DefaultOptions.http.version}${Endpoints.botGateway}`, {\n      method: 'GET',\n      headers: {\n        Authorization: `Bot ${token.replace(/^Bot\\s*/i, '')}`\n      }\n    }).then(res => {\n      if (res.ok) return res.json();\n      if (res.status === 401) throw new DiscordError('TOKEN_INVALID');\n      throw res;\n    }).then(data => data.shards * (1000 / guildsPerShard));\n  }\n  /**\n   * Parses emoji info out of a string. The string must be one of:\n   * * A UTF-8 emoji (no ID)\n   * * A URL-encoded UTF-8 emoji (no ID)\n   * * A Discord custom emoji (`<:name:id>` or `<a:name:id>`)\n   * @param {string} text Emoji string to parse\n   * @returns {Object} Object with `animated`, `name`, and `id` properties\n   * @private\n   */\n\n\n  static parseEmoji(text) {\n    if (text.includes('%')) text = decodeURIComponent(text);\n    if (!text.includes(':')) return {\n      animated: false,\n      name: text,\n      id: null\n    };\n    const m = text.match(/<?(?:(a):)?(\\w{2,32}):(\\d{17,19})?>?/);\n    if (!m) return null;\n    return {\n      animated: Boolean(m[1]),\n      name: m[2],\n      id: m[3] || null\n    };\n  }\n  /**\n   * Shallow-copies an object with its class/prototype intact.\n   * @param {Object} obj Object to clone\n   * @returns {Object}\n   * @private\n   */\n\n\n  static cloneObject(obj) {\n    return Object.assign(Object.create(obj), obj);\n  }\n  /**\n   * Sets default properties on an object that aren't already specified.\n   * @param {Object} def Default properties\n   * @param {Object} given Object to assign defaults to\n   * @returns {Object}\n   * @private\n   */\n\n\n  static mergeDefault(def, given) {\n    if (!given) return def;\n\n    for (const key in def) {\n      if (!has(given, key) || given[key] === undefined) {\n        given[key] = def[key];\n      } else if (given[key] === Object(given[key])) {\n        given[key] = Util.mergeDefault(def[key], given[key]);\n      }\n    }\n\n    return given;\n  }\n  /**\n   * Converts an ArrayBuffer or string to a Buffer.\n   * @param {ArrayBuffer|string} ab ArrayBuffer to convert\n   * @returns {Buffer}\n   * @private\n   */\n\n\n  static convertToBuffer(ab) {\n    if (typeof ab === 'string') ab = Util.str2ab(ab);\n    return Buffer.from(ab);\n  }\n  /**\n   * Converts a string to an ArrayBuffer.\n   * @param {string} str String to convert\n   * @returns {ArrayBuffer}\n   * @private\n   */\n\n\n  static str2ab(str) {\n    const buffer = new ArrayBuffer(str.length * 2);\n    const view = new Uint16Array(buffer);\n\n    for (var i = 0, strLen = str.length; i < strLen; i++) view[i] = str.charCodeAt(i);\n\n    return buffer;\n  }\n  /**\n   * Makes an Error from a plain info object.\n   * @param {Object} obj Error info\n   * @param {string} obj.name Error type\n   * @param {string} obj.message Message for the error\n   * @param {string} obj.stack Stack for the error\n   * @returns {Error}\n   * @private\n   */\n\n\n  static makeError(obj) {\n    const err = new Error(obj.message);\n    err.name = obj.name;\n    err.stack = obj.stack;\n    return err;\n  }\n  /**\n   * Makes a plain error info object from an Error.\n   * @param {Error} err Error to get info from\n   * @returns {Object}\n   * @private\n   */\n\n\n  static makePlainError(err) {\n    return {\n      name: err.name,\n      message: err.message,\n      stack: err.stack\n    };\n  }\n  /**\n   * Moves an element in an array *in place*.\n   * @param {Array<*>} array Array to modify\n   * @param {*} element Element to move\n   * @param {number} newIndex Index or offset to move the element to\n   * @param {boolean} [offset=false] Move the element by an offset amount rather than to a set index\n   * @returns {number}\n   * @private\n   */\n\n\n  static moveElementInArray(array, element, newIndex) {\n    let offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const index = array.indexOf(element);\n    newIndex = (offset ? index : 0) + newIndex;\n\n    if (newIndex > -1 && newIndex < array.length) {\n      const removedElement = array.splice(index, 1)[0];\n      array.splice(newIndex, 0, removedElement);\n    }\n\n    return array.indexOf(element);\n  }\n  /**\n   * Data that can be resolved to give a string. This can be:\n   * * A string\n   * * An array (joined with a new line delimiter to give a string)\n   * * Any value\n   * @typedef {string|Array|*} StringResolvable\n   */\n\n  /**\n   * Resolves a StringResolvable to a string.\n   * @param {StringResolvable} data The string resolvable to resolve\n   * @returns {string}\n   */\n\n\n  static resolveString(data) {\n    if (typeof data === 'string') return data;\n    if (Array.isArray(data)) return data.join('\\n');\n    return String(data);\n  }\n  /**\n   * Can be a number, hex string, an RGB array like:\n   * ```js\n   * [255, 0, 255] // purple\n   * ```\n   * or one of the following strings:\n   * - `DEFAULT`\n   * - `WHITE`\n   * - `AQUA`\n   * - `GREEN`\n   * - `BLUE`\n   * - `YELLOW`\n   * - `PURPLE`\n   * - `LUMINOUS_VIVID_PINK`\n   * - `GOLD`\n   * - `ORANGE`\n   * - `RED`\n   * - `GREY`\n   * - `DARKER_GREY`\n   * - `NAVY`\n   * - `DARK_AQUA`\n   * - `DARK_GREEN`\n   * - `DARK_BLUE`\n   * - `DARK_PURPLE`\n   * - `DARK_VIVID_PINK`\n   * - `DARK_GOLD`\n   * - `DARK_ORANGE`\n   * - `DARK_RED`\n   * - `DARK_GREY`\n   * - `LIGHT_GREY`\n   * - `DARK_NAVY`\n   * - `BLURPLE`\n   * - `GREYPLE`\n   * - `DARK_BUT_NOT_BLACK`\n   * - `NOT_QUITE_BLACK`\n   * - `RANDOM`\n   * @typedef {string|number|number[]} ColorResolvable\n   */\n\n  /**\n   * Resolves a ColorResolvable into a color number.\n   * @param {ColorResolvable} color Color to resolve\n   * @returns {number} A color\n   */\n\n\n  static resolveColor(color) {\n    if (typeof color === 'string') {\n      if (color === 'RANDOM') return Math.floor(Math.random() * (0xffffff + 1));\n      if (color === 'DEFAULT') return 0;\n      color = Colors[color] || parseInt(color.replace('#', ''), 16);\n    } else if (Array.isArray(color)) {\n      color = (color[0] << 16) + (color[1] << 8) + color[2];\n    }\n\n    if (color < 0 || color > 0xffffff) throw new RangeError('COLOR_RANGE');else if (color && isNaN(color)) throw new TypeError('COLOR_CONVERT');\n    return color;\n  }\n  /**\n   * Sorts by Discord's position and ID.\n   * @param  {Collection} collection Collection of objects to sort\n   * @returns {Collection}\n   */\n\n\n  static discordSort(collection) {\n    return collection.sorted((a, b) => a.rawPosition - b.rawPosition || parseInt(b.id.slice(0, -10)) - parseInt(a.id.slice(0, -10)) || parseInt(b.id.slice(10)) - parseInt(a.id.slice(10)));\n  }\n  /**\n   * Sets the position of a Channel or Role.\n   * @param {Channel|Role} item Object to set the position of\n   * @param {number} position New position for the object\n   * @param {boolean} relative Whether `position` is relative to its current position\n   * @param {Collection<string, Channel|Role>} sorted A collection of the objects sorted properly\n   * @param {APIRouter} route Route to call PATCH on\n   * @param {string} [reason] Reason for the change\n   * @returns {Promise<Object[]>} Updated item list, with `id` and `position` properties\n   * @private\n   */\n\n\n  static setPosition(item, position, relative, sorted, route, reason) {\n    let updatedItems = sorted.array();\n    Util.moveElementInArray(updatedItems, item, position, relative);\n    updatedItems = updatedItems.map((r, i) => ({\n      id: r.id,\n      position: i\n    }));\n    return route.patch({\n      data: updatedItems,\n      reason\n    }).then(() => updatedItems);\n  }\n  /**\n   * Alternative to Node's `path.basename`, removing query string after the extension if it exists.\n   * @param {string} path Path to get the basename of\n   * @param {string} [ext] File extension to remove\n   * @returns {string} Basename of the path\n   * @private\n   */\n\n\n  static basename(path, ext) {\n    let res = parse(path);\n    return ext && res.ext.startsWith(ext) ? res.name : res.base.split('?')[0];\n  }\n  /**\n   * Transforms a snowflake from a decimal string to a bit string.\n   * @param  {Snowflake} num Snowflake to be transformed\n   * @returns {string}\n   * @private\n   */\n\n\n  static idToBinary(num) {\n    let bin = '';\n    let high = parseInt(num.slice(0, -10)) || 0;\n    let low = parseInt(num.slice(-10));\n\n    while (low > 0 || high > 0) {\n      bin = String(low & 1) + bin;\n      low = Math.floor(low / 2);\n\n      if (high > 0) {\n        low += 5000000000 * (high % 2);\n        high = Math.floor(high / 2);\n      }\n    }\n\n    return bin;\n  }\n  /**\n   * Transforms a snowflake from a bit string to a decimal string.\n   * @param  {string} num Bit string to be transformed\n   * @returns {Snowflake}\n   * @private\n   */\n\n\n  static binaryToID(num) {\n    let dec = '';\n\n    while (num.length > 50) {\n      const high = parseInt(num.slice(0, -32), 2);\n      const low = parseInt((high % 10).toString(2) + num.slice(-32), 2);\n      dec = (low % 10).toString() + dec;\n      num = Math.floor(high / 10).toString(2) + Math.floor(low / 10).toString(2).padStart(32, '0');\n    }\n\n    num = parseInt(num, 2);\n\n    while (num > 0) {\n      dec = (num % 10).toString() + dec;\n      num = Math.floor(num / 10);\n    }\n\n    return dec;\n  }\n  /**\n   * Breaks user, role and everyone/here mentions by adding a zero width space after every @ character\n   * @param {string} str The string to sanitize\n   * @returns {string}\n   */\n\n\n  static removeMentions(str) {\n    return str.replace(/@/g, '@\\u200b');\n  }\n  /**\n   * The content to have all mentions replaced by the equivalent text.\n   * @param {string} str The string to be converted\n   * @param {Message} message The message object to reference\n   * @returns {string}\n   */\n\n\n  static cleanContent(str, message) {\n    str = str.replace(/<@!?[0-9]+>/g, input => {\n      const id = input.replace(/<|!|>|@/g, '');\n\n      if (message.channel.type === 'dm') {\n        const user = message.client.users.cache.get(id);\n        return user ? Util.removeMentions(`@${user.username}`) : input;\n      }\n\n      const member = message.channel.guild.members.cache.get(id);\n\n      if (member) {\n        return Util.removeMentions(`@${member.displayName}`);\n      } else {\n        const user = message.client.users.cache.get(id);\n        return user ? Util.removeMentions(`@${user.username}`) : input;\n      }\n    }).replace(/<#[0-9]+>/g, input => {\n      const channel = message.client.channels.cache.get(input.replace(/<|#|>/g, ''));\n      return channel ? `#${channel.name}` : input;\n    }).replace(/<@&[0-9]+>/g, input => {\n      if (message.channel.type === 'dm') return input;\n      const role = message.guild.roles.cache.get(input.replace(/<|@|>|&/g, ''));\n      return role ? `@${role.name}` : input;\n    });\n\n    if (message.client.options.disableMentions === 'everyone') {\n      str = str.replace(/@([^<>@ ]*)/gmsu, (match, target) => {\n        if (target.match(/^[&!]?\\d+$/)) {\n          return `@${target}`;\n        } else {\n          return `@\\u200b${target}`;\n        }\n      });\n    }\n\n    if (message.client.options.disableMentions === 'all') {\n      return Util.removeMentions(str);\n    } else {\n      return str;\n    }\n  }\n  /**\n   * The content to put in a codeblock with all codeblock fences replaced by the equivalent backticks.\n   * @param {string} text The string to be converted\n   * @returns {string}\n   */\n\n\n  static cleanCodeBlockContent(text) {\n    return text.replace(/```/g, '`\\u200b``');\n  }\n  /**\n   * Creates a Promise that resolves after a specified duration.\n   * @param {number} ms How long to wait before resolving (in milliseconds)\n   * @returns {Promise<void>}\n   * @private\n   */\n\n\n  static delayFor(ms) {\n    return new Promise(resolve => {\n      setTimeout(resolve, ms);\n    });\n  }\n\n}\n\nmodule.exports = Util;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/util/Util.js"],"names":["parse","require","fetch","Colors","DefaultOptions","Endpoints","Error","DiscordError","RangeError","TypeError","has","o","k","Object","prototype","hasOwnProperty","call","isObject","d","Util","constructor","name","flatten","obj","props","objProps","keys","filter","startsWith","map","length","assign","out","prop","newProp","entries","element","elemIsObj","valueOf","Array","from","isArray","e","splitMessage","text","maxLength","char","prepend","append","resolveString","splitText","split","some","chunk","messages","msg","push","concat","m","escapeMarkdown","codeBlock","inlineCode","bold","italic","underline","strikethrough","spoiler","codeBlockContent","inlineCodeContent","subString","index","array","join","escapeInlineCode","escapeCodeBlock","escapeItalic","escapeBold","escapeUnderline","escapeStrikethrough","escapeSpoiler","replace","i","_","match","fetchRecommendedShards","token","guildsPerShard","http","api","version","botGateway","method","headers","Authorization","then","res","ok","json","status","data","shards","parseEmoji","includes","decodeURIComponent","animated","id","Boolean","cloneObject","create","mergeDefault","def","given","key","undefined","convertToBuffer","ab","str2ab","Buffer","str","buffer","ArrayBuffer","view","Uint16Array","strLen","charCodeAt","makeError","err","message","stack","makePlainError","moveElementInArray","newIndex","offset","indexOf","removedElement","splice","String","resolveColor","color","Math","floor","random","parseInt","isNaN","discordSort","collection","sorted","a","b","rawPosition","slice","setPosition","item","position","relative","route","reason","updatedItems","r","patch","basename","path","ext","base","idToBinary","num","bin","high","low","binaryToID","dec","toString","padStart","removeMentions","cleanContent","input","channel","type","user","client","users","cache","get","username","member","guild","members","displayName","channels","role","roles","options","disableMentions","target","cleanCodeBlockContent","delayFor","ms","Promise","resolve","setTimeout","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst { parse } = require('path');\nconst fetch = require('node-fetch');\nconst { Colors, DefaultOptions, Endpoints } = require('./Constants');\nconst { Error: DiscordError, RangeError, TypeError } = require('../errors');\nconst has = (o, k) => Object.prototype.hasOwnProperty.call(o, k);\nconst isObject = d => typeof d === 'object' && d !== null;\n\n/**\n * Contains various general-purpose utility methods. These functions are also available on the base `Discord` object.\n */\nclass Util {\n  constructor() {\n    throw new Error(`The ${this.constructor.name} class may not be instantiated.`);\n  }\n\n  /**\n   * Flatten an object. Any properties that are collections will get converted to an array of keys.\n   * @param {Object} obj The object to flatten.\n   * @param {...Object<string, boolean|string>} [props] Specific properties to include/exclude.\n   * @returns {Object}\n   */\n  static flatten(obj, ...props) {\n    if (!isObject(obj)) return obj;\n\n    const objProps = Object.keys(obj)\n      .filter(k => !k.startsWith('_'))\n      .map(k => ({ [k]: true }));\n\n    props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);\n\n    const out = {};\n\n    for (let [prop, newProp] of Object.entries(props)) {\n      if (!newProp) continue;\n      newProp = newProp === true ? prop : newProp;\n\n      const element = obj[prop];\n      const elemIsObj = isObject(element);\n      const valueOf = elemIsObj && typeof element.valueOf === 'function' ? element.valueOf() : null;\n\n      // If it's a Collection, make the array of keys\n      if (element instanceof require('./Collection')) out[newProp] = Array.from(element.keys());\n      // If the valueOf is a Collection, use its array of keys\n      else if (valueOf instanceof require('./Collection')) out[newProp] = Array.from(valueOf.keys());\n      // If it's an array, flatten each element\n      else if (Array.isArray(element)) out[newProp] = element.map(e => Util.flatten(e));\n      // If it's an object with a primitive `valueOf`, use that value\n      else if (typeof valueOf !== 'object') out[newProp] = valueOf;\n      // If it's a primitive\n      else if (!elemIsObj) out[newProp] = element;\n    }\n\n    return out;\n  }\n\n  /**\n   * Splits a string into multiple chunks at a designated character that do not exceed a specific length.\n   * @param {StringResolvable} text Content to split\n   * @param {SplitOptions} [options] Options controlling the behavior of the split\n   * @returns {string[]}\n   */\n  static splitMessage(text, { maxLength = 2000, char = '\\n', prepend = '', append = '' } = {}) {\n    text = Util.resolveString(text);\n    if (text.length <= maxLength) return [text];\n    const splitText = text.split(char);\n    if (splitText.some(chunk => chunk.length > maxLength)) throw new RangeError('SPLIT_MAX_LEN');\n    const messages = [];\n    let msg = '';\n    for (const chunk of splitText) {\n      if (msg && (msg + char + chunk + append).length > maxLength) {\n        messages.push(msg + append);\n        msg = prepend;\n      }\n      msg += (msg && msg !== prepend ? char : '') + chunk;\n    }\n    return messages.concat(msg).filter(m => m);\n  }\n\n  /**\n   * Escapes any Discord-flavour markdown in a string.\n   * @param {string} text Content to escape\n   * @param {Object} [options={}] What types of markdown to escape\n   * @param {boolean} [options.codeBlock=true] Whether to escape code blocks or not\n   * @param {boolean} [options.inlineCode=true] Whether to escape inline code or not\n   * @param {boolean} [options.bold=true] Whether to escape bolds or not\n   * @param {boolean} [options.italic=true] Whether to escape italics or not\n   * @param {boolean} [options.underline=true] Whether to escape underlines or not\n   * @param {boolean} [options.strikethrough=true] Whether to escape strikethroughs or not\n   * @param {boolean} [options.spoiler=true] Whether to escape spoilers or not\n   * @param {boolean} [options.codeBlockContent=true] Whether to escape text inside code blocks or not\n   * @param {boolean} [options.inlineCodeContent=true] Whether to escape text inside inline code or not\n   * @returns {string}\n   */\n  static escapeMarkdown(\n    text,\n    {\n      codeBlock = true,\n      inlineCode = true,\n      bold = true,\n      italic = true,\n      underline = true,\n      strikethrough = true,\n      spoiler = true,\n      codeBlockContent = true,\n      inlineCodeContent = true,\n    } = {},\n  ) {\n    if (!codeBlockContent) {\n      return text\n        .split('```')\n        .map((subString, index, array) => {\n          if (index % 2 && index !== array.length - 1) return subString;\n          return Util.escapeMarkdown(subString, {\n            inlineCode,\n            bold,\n            italic,\n            underline,\n            strikethrough,\n            spoiler,\n            inlineCodeContent,\n          });\n        })\n        .join(codeBlock ? '\\\\`\\\\`\\\\`' : '```');\n    }\n    if (!inlineCodeContent) {\n      return text\n        .split(/(?<=^|[^`])`(?=[^`]|$)/g)\n        .map((subString, index, array) => {\n          if (index % 2 && index !== array.length - 1) return subString;\n          return Util.escapeMarkdown(subString, {\n            codeBlock,\n            bold,\n            italic,\n            underline,\n            strikethrough,\n            spoiler,\n          });\n        })\n        .join(inlineCode ? '\\\\`' : '`');\n    }\n    if (inlineCode) text = Util.escapeInlineCode(text);\n    if (codeBlock) text = Util.escapeCodeBlock(text);\n    if (italic) text = Util.escapeItalic(text);\n    if (bold) text = Util.escapeBold(text);\n    if (underline) text = Util.escapeUnderline(text);\n    if (strikethrough) text = Util.escapeStrikethrough(text);\n    if (spoiler) text = Util.escapeSpoiler(text);\n    return text;\n  }\n\n  /**\n   * Escapes code block markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeCodeBlock(text) {\n    return text.replace(/```/g, '\\\\`\\\\`\\\\`');\n  }\n\n  /**\n   * Escapes inline code markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeInlineCode(text) {\n    return text.replace(/(?<=^|[^`])`(?=[^`]|$)/g, '\\\\`');\n  }\n\n  /**\n   * Escapes italic markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeItalic(text) {\n    let i = 0;\n    text = text.replace(/(?<=^|[^*])\\*([^*]|\\*\\*|$)/g, (_, match) => {\n      if (match === '**') return ++i % 2 ? `\\\\*${match}` : `${match}\\\\*`;\n      return `\\\\*${match}`;\n    });\n    i = 0;\n    return text.replace(/(?<=^|[^_])_([^_]|__|$)/g, (_, match) => {\n      if (match === '__') return ++i % 2 ? `\\\\_${match}` : `${match}\\\\_`;\n      return `\\\\_${match}`;\n    });\n  }\n\n  /**\n   * Escapes bold markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeBold(text) {\n    let i = 0;\n    return text.replace(/\\*\\*(\\*)?/g, (_, match) => {\n      if (match) return ++i % 2 ? `${match}\\\\*\\\\*` : `\\\\*\\\\*${match}`;\n      return '\\\\*\\\\*';\n    });\n  }\n\n  /**\n   * Escapes underline markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeUnderline(text) {\n    let i = 0;\n    return text.replace(/__(_)?/g, (_, match) => {\n      if (match) return ++i % 2 ? `${match}\\\\_\\\\_` : `\\\\_\\\\_${match}`;\n      return '\\\\_\\\\_';\n    });\n  }\n\n  /**\n   * Escapes strikethrough markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeStrikethrough(text) {\n    return text.replace(/~~/g, '\\\\~\\\\~');\n  }\n\n  /**\n   * Escapes spoiler markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeSpoiler(text) {\n    return text.replace(/\\|\\|/g, '\\\\|\\\\|');\n  }\n\n  /**\n   * Gets the recommended shard count from Discord.\n   * @param {string} token Discord auth token\n   * @param {number} [guildsPerShard=1000] Number of guilds per shard\n   * @returns {Promise<number>} The recommended number of shards\n   */\n  static fetchRecommendedShards(token, guildsPerShard = 1000) {\n    if (!token) throw new DiscordError('TOKEN_MISSING');\n    return fetch(`${DefaultOptions.http.api}/v${DefaultOptions.http.version}${Endpoints.botGateway}`, {\n      method: 'GET',\n      headers: { Authorization: `Bot ${token.replace(/^Bot\\s*/i, '')}` },\n    })\n      .then(res => {\n        if (res.ok) return res.json();\n        if (res.status === 401) throw new DiscordError('TOKEN_INVALID');\n        throw res;\n      })\n      .then(data => data.shards * (1000 / guildsPerShard));\n  }\n\n  /**\n   * Parses emoji info out of a string. The string must be one of:\n   * * A UTF-8 emoji (no ID)\n   * * A URL-encoded UTF-8 emoji (no ID)\n   * * A Discord custom emoji (`<:name:id>` or `<a:name:id>`)\n   * @param {string} text Emoji string to parse\n   * @returns {Object} Object with `animated`, `name`, and `id` properties\n   * @private\n   */\n  static parseEmoji(text) {\n    if (text.includes('%')) text = decodeURIComponent(text);\n    if (!text.includes(':')) return { animated: false, name: text, id: null };\n    const m = text.match(/<?(?:(a):)?(\\w{2,32}):(\\d{17,19})?>?/);\n    if (!m) return null;\n    return { animated: Boolean(m[1]), name: m[2], id: m[3] || null };\n  }\n\n  /**\n   * Shallow-copies an object with its class/prototype intact.\n   * @param {Object} obj Object to clone\n   * @returns {Object}\n   * @private\n   */\n  static cloneObject(obj) {\n    return Object.assign(Object.create(obj), obj);\n  }\n\n  /**\n   * Sets default properties on an object that aren't already specified.\n   * @param {Object} def Default properties\n   * @param {Object} given Object to assign defaults to\n   * @returns {Object}\n   * @private\n   */\n  static mergeDefault(def, given) {\n    if (!given) return def;\n    for (const key in def) {\n      if (!has(given, key) || given[key] === undefined) {\n        given[key] = def[key];\n      } else if (given[key] === Object(given[key])) {\n        given[key] = Util.mergeDefault(def[key], given[key]);\n      }\n    }\n\n    return given;\n  }\n\n  /**\n   * Converts an ArrayBuffer or string to a Buffer.\n   * @param {ArrayBuffer|string} ab ArrayBuffer to convert\n   * @returns {Buffer}\n   * @private\n   */\n  static convertToBuffer(ab) {\n    if (typeof ab === 'string') ab = Util.str2ab(ab);\n    return Buffer.from(ab);\n  }\n\n  /**\n   * Converts a string to an ArrayBuffer.\n   * @param {string} str String to convert\n   * @returns {ArrayBuffer}\n   * @private\n   */\n  static str2ab(str) {\n    const buffer = new ArrayBuffer(str.length * 2);\n    const view = new Uint16Array(buffer);\n    for (var i = 0, strLen = str.length; i < strLen; i++) view[i] = str.charCodeAt(i);\n    return buffer;\n  }\n\n  /**\n   * Makes an Error from a plain info object.\n   * @param {Object} obj Error info\n   * @param {string} obj.name Error type\n   * @param {string} obj.message Message for the error\n   * @param {string} obj.stack Stack for the error\n   * @returns {Error}\n   * @private\n   */\n  static makeError(obj) {\n    const err = new Error(obj.message);\n    err.name = obj.name;\n    err.stack = obj.stack;\n    return err;\n  }\n\n  /**\n   * Makes a plain error info object from an Error.\n   * @param {Error} err Error to get info from\n   * @returns {Object}\n   * @private\n   */\n  static makePlainError(err) {\n    return {\n      name: err.name,\n      message: err.message,\n      stack: err.stack,\n    };\n  }\n\n  /**\n   * Moves an element in an array *in place*.\n   * @param {Array<*>} array Array to modify\n   * @param {*} element Element to move\n   * @param {number} newIndex Index or offset to move the element to\n   * @param {boolean} [offset=false] Move the element by an offset amount rather than to a set index\n   * @returns {number}\n   * @private\n   */\n  static moveElementInArray(array, element, newIndex, offset = false) {\n    const index = array.indexOf(element);\n    newIndex = (offset ? index : 0) + newIndex;\n    if (newIndex > -1 && newIndex < array.length) {\n      const removedElement = array.splice(index, 1)[0];\n      array.splice(newIndex, 0, removedElement);\n    }\n    return array.indexOf(element);\n  }\n\n  /**\n   * Data that can be resolved to give a string. This can be:\n   * * A string\n   * * An array (joined with a new line delimiter to give a string)\n   * * Any value\n   * @typedef {string|Array|*} StringResolvable\n   */\n\n  /**\n   * Resolves a StringResolvable to a string.\n   * @param {StringResolvable} data The string resolvable to resolve\n   * @returns {string}\n   */\n  static resolveString(data) {\n    if (typeof data === 'string') return data;\n    if (Array.isArray(data)) return data.join('\\n');\n    return String(data);\n  }\n\n  /**\n   * Can be a number, hex string, an RGB array like:\n   * ```js\n   * [255, 0, 255] // purple\n   * ```\n   * or one of the following strings:\n   * - `DEFAULT`\n   * - `WHITE`\n   * - `AQUA`\n   * - `GREEN`\n   * - `BLUE`\n   * - `YELLOW`\n   * - `PURPLE`\n   * - `LUMINOUS_VIVID_PINK`\n   * - `GOLD`\n   * - `ORANGE`\n   * - `RED`\n   * - `GREY`\n   * - `DARKER_GREY`\n   * - `NAVY`\n   * - `DARK_AQUA`\n   * - `DARK_GREEN`\n   * - `DARK_BLUE`\n   * - `DARK_PURPLE`\n   * - `DARK_VIVID_PINK`\n   * - `DARK_GOLD`\n   * - `DARK_ORANGE`\n   * - `DARK_RED`\n   * - `DARK_GREY`\n   * - `LIGHT_GREY`\n   * - `DARK_NAVY`\n   * - `BLURPLE`\n   * - `GREYPLE`\n   * - `DARK_BUT_NOT_BLACK`\n   * - `NOT_QUITE_BLACK`\n   * - `RANDOM`\n   * @typedef {string|number|number[]} ColorResolvable\n   */\n\n  /**\n   * Resolves a ColorResolvable into a color number.\n   * @param {ColorResolvable} color Color to resolve\n   * @returns {number} A color\n   */\n  static resolveColor(color) {\n    if (typeof color === 'string') {\n      if (color === 'RANDOM') return Math.floor(Math.random() * (0xffffff + 1));\n      if (color === 'DEFAULT') return 0;\n      color = Colors[color] || parseInt(color.replace('#', ''), 16);\n    } else if (Array.isArray(color)) {\n      color = (color[0] << 16) + (color[1] << 8) + color[2];\n    }\n\n    if (color < 0 || color > 0xffffff) throw new RangeError('COLOR_RANGE');\n    else if (color && isNaN(color)) throw new TypeError('COLOR_CONVERT');\n\n    return color;\n  }\n\n  /**\n   * Sorts by Discord's position and ID.\n   * @param  {Collection} collection Collection of objects to sort\n   * @returns {Collection}\n   */\n  static discordSort(collection) {\n    return collection.sorted(\n      (a, b) =>\n        a.rawPosition - b.rawPosition ||\n        parseInt(b.id.slice(0, -10)) - parseInt(a.id.slice(0, -10)) ||\n        parseInt(b.id.slice(10)) - parseInt(a.id.slice(10)),\n    );\n  }\n\n  /**\n   * Sets the position of a Channel or Role.\n   * @param {Channel|Role} item Object to set the position of\n   * @param {number} position New position for the object\n   * @param {boolean} relative Whether `position` is relative to its current position\n   * @param {Collection<string, Channel|Role>} sorted A collection of the objects sorted properly\n   * @param {APIRouter} route Route to call PATCH on\n   * @param {string} [reason] Reason for the change\n   * @returns {Promise<Object[]>} Updated item list, with `id` and `position` properties\n   * @private\n   */\n  static setPosition(item, position, relative, sorted, route, reason) {\n    let updatedItems = sorted.array();\n    Util.moveElementInArray(updatedItems, item, position, relative);\n    updatedItems = updatedItems.map((r, i) => ({ id: r.id, position: i }));\n    return route.patch({ data: updatedItems, reason }).then(() => updatedItems);\n  }\n\n  /**\n   * Alternative to Node's `path.basename`, removing query string after the extension if it exists.\n   * @param {string} path Path to get the basename of\n   * @param {string} [ext] File extension to remove\n   * @returns {string} Basename of the path\n   * @private\n   */\n  static basename(path, ext) {\n    let res = parse(path);\n    return ext && res.ext.startsWith(ext) ? res.name : res.base.split('?')[0];\n  }\n\n  /**\n   * Transforms a snowflake from a decimal string to a bit string.\n   * @param  {Snowflake} num Snowflake to be transformed\n   * @returns {string}\n   * @private\n   */\n  static idToBinary(num) {\n    let bin = '';\n    let high = parseInt(num.slice(0, -10)) || 0;\n    let low = parseInt(num.slice(-10));\n    while (low > 0 || high > 0) {\n      bin = String(low & 1) + bin;\n      low = Math.floor(low / 2);\n      if (high > 0) {\n        low += 5000000000 * (high % 2);\n        high = Math.floor(high / 2);\n      }\n    }\n    return bin;\n  }\n\n  /**\n   * Transforms a snowflake from a bit string to a decimal string.\n   * @param  {string} num Bit string to be transformed\n   * @returns {Snowflake}\n   * @private\n   */\n  static binaryToID(num) {\n    let dec = '';\n\n    while (num.length > 50) {\n      const high = parseInt(num.slice(0, -32), 2);\n      const low = parseInt((high % 10).toString(2) + num.slice(-32), 2);\n\n      dec = (low % 10).toString() + dec;\n      num =\n        Math.floor(high / 10).toString(2) +\n        Math.floor(low / 10)\n          .toString(2)\n          .padStart(32, '0');\n    }\n\n    num = parseInt(num, 2);\n    while (num > 0) {\n      dec = (num % 10).toString() + dec;\n      num = Math.floor(num / 10);\n    }\n\n    return dec;\n  }\n\n  /**\n   * Breaks user, role and everyone/here mentions by adding a zero width space after every @ character\n   * @param {string} str The string to sanitize\n   * @returns {string}\n   */\n  static removeMentions(str) {\n    return str.replace(/@/g, '@\\u200b');\n  }\n\n  /**\n   * The content to have all mentions replaced by the equivalent text.\n   * @param {string} str The string to be converted\n   * @param {Message} message The message object to reference\n   * @returns {string}\n   */\n  static cleanContent(str, message) {\n    str = str\n      .replace(/<@!?[0-9]+>/g, input => {\n        const id = input.replace(/<|!|>|@/g, '');\n        if (message.channel.type === 'dm') {\n          const user = message.client.users.cache.get(id);\n          return user ? Util.removeMentions(`@${user.username}`) : input;\n        }\n\n        const member = message.channel.guild.members.cache.get(id);\n        if (member) {\n          return Util.removeMentions(`@${member.displayName}`);\n        } else {\n          const user = message.client.users.cache.get(id);\n          return user ? Util.removeMentions(`@${user.username}`) : input;\n        }\n      })\n      .replace(/<#[0-9]+>/g, input => {\n        const channel = message.client.channels.cache.get(input.replace(/<|#|>/g, ''));\n        return channel ? `#${channel.name}` : input;\n      })\n      .replace(/<@&[0-9]+>/g, input => {\n        if (message.channel.type === 'dm') return input;\n        const role = message.guild.roles.cache.get(input.replace(/<|@|>|&/g, ''));\n        return role ? `@${role.name}` : input;\n      });\n    if (message.client.options.disableMentions === 'everyone') {\n      str = str.replace(/@([^<>@ ]*)/gmsu, (match, target) => {\n        if (target.match(/^[&!]?\\d+$/)) {\n          return `@${target}`;\n        } else {\n          return `@\\u200b${target}`;\n        }\n      });\n    }\n    if (message.client.options.disableMentions === 'all') {\n      return Util.removeMentions(str);\n    } else {\n      return str;\n    }\n  }\n\n  /**\n   * The content to put in a codeblock with all codeblock fences replaced by the equivalent backticks.\n   * @param {string} text The string to be converted\n   * @returns {string}\n   */\n  static cleanCodeBlockContent(text) {\n    return text.replace(/```/g, '`\\u200b``');\n  }\n\n  /**\n   * Creates a Promise that resolves after a specified duration.\n   * @param {number} ms How long to wait before resolving (in milliseconds)\n   * @returns {Promise<void>}\n   * @private\n   */\n  static delayFor(ms) {\n    return new Promise(resolve => {\n      setTimeout(resolve, ms);\n    });\n  }\n}\n\nmodule.exports = Util;\n"]},"metadata":{},"sourceType":"script"}