{"ast":null,"code":"'use strict';\n\nconst BaseManager = require('./BaseManager');\n\nconst Role = require('../structures/Role');\n\nconst Permissions = require('../util/Permissions');\n\nconst {\n  resolveColor\n} = require('../util/Util');\n/**\n * Manages API methods for roles and stores their cache.\n * @extends {BaseManager}\n */\n\n\nclass RoleManager extends BaseManager {\n  constructor(guild, iterable) {\n    super(guild.client, iterable, Role);\n    /**\n     * The guild belonging to this manager\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n  }\n  /**\n   * The role cache of this manager\n   * @type {Collection<Snowflake, Role>}\n   * @name RoleManager#cache\n   */\n\n\n  add(data, cache) {\n    return super.add(data, cache, {\n      extras: [this.guild]\n    });\n  }\n  /**\n   * Obtains one or more roles from Discord, or the role cache if they're already available.\n   * @param {Snowflake} [id] ID or IDs of the role(s)\n   * @param {boolean} [cache=true] Whether to cache the new roles objects if it weren't already\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Role|RoleManager>}\n   * @example\n   * // Fetch all roles from the guild\n   * message.guild.roles.fetch()\n   *   .then(roles => console.log(`There are ${roles.cache.size} roles.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single role\n   * message.guild.roles.fetch('222078108977594368')\n   *   .then(role => console.log(`The role color is: ${role.color}`))\n   *   .catch(console.error);\n   */\n\n\n  async fetch(id) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    } // We cannot fetch a single role, as of this commit's date, Discord API throws with 405\n\n\n    const roles = await this.client.api.guilds(this.guild.id).roles.get();\n\n    for (const role of roles) this.add(role, cache);\n\n    return id ? this.cache.get(id) || null : this;\n  }\n  /**\n   * Data that can be resolved to a Role object. This can be:\n   * * A Role\n   * * A Snowflake\n   * @typedef {Role|Snowflake} RoleResolvable\n   */\n\n  /**\n   * Resolves a RoleResolvable to a Role object.\n   * @method resolve\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Role}\n   */\n\n  /**\n   * Resolves a RoleResolvable to a role ID string.\n   * @method resolveID\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Creates a new role in the guild with given information.\n   * <warn>The position will silently reset to 1 if an invalid one is provided, or none.</warn>\n   * @param {Object} [options] Options\n   * @param {RoleData} [options.data] The data to create the role with\n   * @param {string} [options.reason] Reason for creating this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Create a new role\n   * guild.roles.create()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new role with data and a reason\n   * guild.roles.create({\n   *   data: {\n   *     name: 'Super Cool People',\n   *     color: 'BLUE',\n   *   },\n   *   reason: 'we needed a role for Super Cool People',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  create() {\n    let {\n      data = {},\n      reason\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (data.color) data.color = resolveColor(data.color);\n    if (data.permissions) data.permissions = Permissions.resolve(data.permissions);\n    return this.guild.client.api.guilds(this.guild.id).roles.post({\n      data,\n      reason\n    }).then(r => {\n      const {\n        role\n      } = this.client.actions.GuildRoleCreate.handle({\n        guild_id: this.guild.id,\n        role: r\n      });\n      if (data.position) return role.setPosition(data.position, reason);\n      return role;\n    });\n  }\n  /**\n   * The `@everyone` role of the guild\n   * @type {Role}\n   * @readonly\n   */\n\n\n  get everyone() {\n    return this.cache.get(this.guild.id);\n  }\n  /**\n   * The role with the highest position in the cache\n   * @type {Role}\n   * @readonly\n   */\n\n\n  get highest() {\n    return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());\n  }\n\n}\n\nmodule.exports = RoleManager;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/managers/RoleManager.js"],"names":["BaseManager","require","Role","Permissions","resolveColor","RoleManager","constructor","guild","iterable","client","add","data","cache","extras","fetch","id","force","existing","get","roles","api","guilds","role","create","reason","color","permissions","resolve","post","then","r","actions","GuildRoleCreate","handle","guild_id","position","setPosition","everyone","highest","reduce","prev","comparePositionTo","first","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst BaseManager = require('./BaseManager');\nconst Role = require('../structures/Role');\nconst Permissions = require('../util/Permissions');\nconst { resolveColor } = require('../util/Util');\n\n/**\n * Manages API methods for roles and stores their cache.\n * @extends {BaseManager}\n */\nclass RoleManager extends BaseManager {\n  constructor(guild, iterable) {\n    super(guild.client, iterable, Role);\n    /**\n     * The guild belonging to this manager\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The role cache of this manager\n   * @type {Collection<Snowflake, Role>}\n   * @name RoleManager#cache\n   */\n\n  add(data, cache) {\n    return super.add(data, cache, { extras: [this.guild] });\n  }\n\n  /**\n   * Obtains one or more roles from Discord, or the role cache if they're already available.\n   * @param {Snowflake} [id] ID or IDs of the role(s)\n   * @param {boolean} [cache=true] Whether to cache the new roles objects if it weren't already\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Role|RoleManager>}\n   * @example\n   * // Fetch all roles from the guild\n   * message.guild.roles.fetch()\n   *   .then(roles => console.log(`There are ${roles.cache.size} roles.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single role\n   * message.guild.roles.fetch('222078108977594368')\n   *   .then(role => console.log(`The role color is: ${role.color}`))\n   *   .catch(console.error);\n   */\n  async fetch(id, cache = true, force = false) {\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n\n    // We cannot fetch a single role, as of this commit's date, Discord API throws with 405\n    const roles = await this.client.api.guilds(this.guild.id).roles.get();\n    for (const role of roles) this.add(role, cache);\n    return id ? this.cache.get(id) || null : this;\n  }\n\n  /**\n   * Data that can be resolved to a Role object. This can be:\n   * * A Role\n   * * A Snowflake\n   * @typedef {Role|Snowflake} RoleResolvable\n   */\n\n  /**\n   * Resolves a RoleResolvable to a Role object.\n   * @method resolve\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Role}\n   */\n\n  /**\n   * Resolves a RoleResolvable to a role ID string.\n   * @method resolveID\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Creates a new role in the guild with given information.\n   * <warn>The position will silently reset to 1 if an invalid one is provided, or none.</warn>\n   * @param {Object} [options] Options\n   * @param {RoleData} [options.data] The data to create the role with\n   * @param {string} [options.reason] Reason for creating this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Create a new role\n   * guild.roles.create()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new role with data and a reason\n   * guild.roles.create({\n   *   data: {\n   *     name: 'Super Cool People',\n   *     color: 'BLUE',\n   *   },\n   *   reason: 'we needed a role for Super Cool People',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  create({ data = {}, reason } = {}) {\n    if (data.color) data.color = resolveColor(data.color);\n    if (data.permissions) data.permissions = Permissions.resolve(data.permissions);\n\n    return this.guild.client.api\n      .guilds(this.guild.id)\n      .roles.post({ data, reason })\n      .then(r => {\n        const { role } = this.client.actions.GuildRoleCreate.handle({\n          guild_id: this.guild.id,\n          role: r,\n        });\n        if (data.position) return role.setPosition(data.position, reason);\n        return role;\n      });\n  }\n\n  /**\n   * The `@everyone` role of the guild\n   * @type {Role}\n   * @readonly\n   */\n  get everyone() {\n    return this.cache.get(this.guild.id);\n  }\n\n  /**\n   * The role with the highest position in the cache\n   * @type {Role}\n   * @readonly\n   */\n  get highest() {\n    return this.cache.reduce((prev, role) => (role.comparePositionTo(prev) > 0 ? role : prev), this.cache.first());\n  }\n}\n\nmodule.exports = RoleManager;\n"]},"metadata":{},"sourceType":"script"}