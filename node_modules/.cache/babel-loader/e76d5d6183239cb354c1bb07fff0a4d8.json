{"ast":null,"code":"'use strict';\n\nconst BaseManager = require('./BaseManager');\n\nconst Channel = require('../structures/Channel');\n\nconst {\n  Events\n} = require('../util/Constants');\n/**\n * A manager of channels belonging to a client\n * @extends {BaseManager}\n */\n\n\nclass ChannelManager extends BaseManager {\n  constructor(client, iterable) {\n    super(client, iterable, Channel);\n  }\n  /**\n   * The cache of Channels\n   * @type {Collection<Snowflake, Channel>}\n   * @name ChannelManager#cache\n   */\n\n\n  add(data, guild) {\n    let cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const existing = this.cache.get(data.id);\n\n    if (existing) {\n      if (existing._patch && cache) existing._patch(data);\n      if (guild) guild.channels.add(existing);\n      return existing;\n    }\n\n    const channel = Channel.create(this.client, data, guild);\n\n    if (!channel) {\n      this.client.emit(Events.DEBUG, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);\n      return null;\n    }\n\n    if (cache) this.cache.set(channel.id, channel);\n    return channel;\n  }\n\n  remove(id) {\n    const channel = this.cache.get(id);\n    if (channel.guild) channel.guild.channels.cache.delete(id);\n    this.cache.delete(id);\n  }\n  /**\n   * Data that can be resolved to give a Channel object. This can be:\n   * * A Channel object\n   * * A Snowflake\n   * @typedef {Channel|Snowflake} ChannelResolvable\n   */\n\n  /**\n   * Resolves a ChannelResolvable to a Channel object.\n   * @method resolve\n   * @memberof ChannelManager\n   * @instance\n   * @param {ChannelResolvable} channel The channel resolvable to resolve\n   * @returns {?Channel}\n   */\n\n  /**\n   * Resolves a ChannelResolvable to a channel ID string.\n   * @method resolveID\n   * @memberof ChannelManager\n   * @instance\n   * @param {ChannelResolvable} channel The channel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Obtains a channel from Discord, or the channel cache if it's already available.\n   * @param {Snowflake} id ID of the channel\n   * @param {boolean} [cache=true] Whether to cache the new channel object if it isn't already\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Channel>}\n   * @example\n   * // Fetch a channel by its id\n   * client.channels.fetch('222109930545610754')\n   *   .then(channel => console.log(channel.name))\n   *   .catch(console.error);\n   */\n\n\n  async fetch(id) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.api.channels(id).get();\n    return this.add(data, null, cache);\n  }\n\n}\n\nmodule.exports = ChannelManager;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/managers/ChannelManager.js"],"names":["BaseManager","require","Channel","Events","ChannelManager","constructor","client","iterable","add","data","guild","cache","existing","get","id","_patch","channels","channel","create","emit","DEBUG","type","set","remove","delete","fetch","force","partial","api","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,WAAW,GAAGC,OAAO,CAAC,eAAD,CAA3B;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,uBAAD,CAAvB;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAaF,OAAO,CAAC,mBAAD,CAA1B;AAEA;AACA;AACA;AACA;;;AACA,MAAMG,cAAN,SAA6BJ,WAA7B,CAAyC;AACvCK,EAAAA,WAAW,CAACC,MAAD,EAASC,QAAT,EAAmB;AAC5B,UAAMD,MAAN,EAAcC,QAAd,EAAwBL,OAAxB;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEEM,EAAAA,GAAG,CAACC,IAAD,EAAOC,KAAP,EAA4B;AAAA,QAAdC,KAAc,uEAAN,IAAM;AAC7B,UAAMC,QAAQ,GAAG,KAAKD,KAAL,CAAWE,GAAX,CAAeJ,IAAI,CAACK,EAApB,CAAjB;;AACA,QAAIF,QAAJ,EAAc;AACZ,UAAIA,QAAQ,CAACG,MAAT,IAAmBJ,KAAvB,EAA8BC,QAAQ,CAACG,MAAT,CAAgBN,IAAhB;AAC9B,UAAIC,KAAJ,EAAWA,KAAK,CAACM,QAAN,CAAeR,GAAf,CAAmBI,QAAnB;AACX,aAAOA,QAAP;AACD;;AAED,UAAMK,OAAO,GAAGf,OAAO,CAACgB,MAAR,CAAe,KAAKZ,MAApB,EAA4BG,IAA5B,EAAkCC,KAAlC,CAAhB;;AAEA,QAAI,CAACO,OAAL,EAAc;AACZ,WAAKX,MAAL,CAAYa,IAAZ,CAAiBhB,MAAM,CAACiB,KAAxB,EAAgC,qDAAoDX,IAAI,CAACK,EAAG,IAAGL,IAAI,CAACY,IAAK,EAAzG;AACA,aAAO,IAAP;AACD;;AAED,QAAIV,KAAJ,EAAW,KAAKA,KAAL,CAAWW,GAAX,CAAeL,OAAO,CAACH,EAAvB,EAA2BG,OAA3B;AAEX,WAAOA,OAAP;AACD;;AAEDM,EAAAA,MAAM,CAACT,EAAD,EAAK;AACT,UAAMG,OAAO,GAAG,KAAKN,KAAL,CAAWE,GAAX,CAAeC,EAAf,CAAhB;AACA,QAAIG,OAAO,CAACP,KAAZ,EAAmBO,OAAO,CAACP,KAAR,CAAcM,QAAd,CAAuBL,KAAvB,CAA6Ba,MAA7B,CAAoCV,EAApC;AACnB,SAAKH,KAAL,CAAWa,MAAX,CAAkBV,EAAlB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACa,QAALW,KAAK,CAACX,EAAD,EAAkC;AAAA,QAA7BH,KAA6B,uEAArB,IAAqB;AAAA,QAAfe,KAAe,uEAAP,KAAO;;AAC3C,QAAI,CAACA,KAAL,EAAY;AACV,YAAMd,QAAQ,GAAG,KAAKD,KAAL,CAAWE,GAAX,CAAeC,EAAf,CAAjB;AACA,UAAIF,QAAQ,IAAI,CAACA,QAAQ,CAACe,OAA1B,EAAmC,OAAOf,QAAP;AACpC;;AAED,UAAMH,IAAI,GAAG,MAAM,KAAKH,MAAL,CAAYsB,GAAZ,CAAgBZ,QAAhB,CAAyBF,EAAzB,EAA6BD,GAA7B,EAAnB;AACA,WAAO,KAAKL,GAAL,CAASC,IAAT,EAAe,IAAf,EAAqBE,KAArB,CAAP;AACD;;AAlFsC;;AAqFzCkB,MAAM,CAACC,OAAP,GAAiB1B,cAAjB","sourcesContent":["'use strict';\n\nconst BaseManager = require('./BaseManager');\nconst Channel = require('../structures/Channel');\nconst { Events } = require('../util/Constants');\n\n/**\n * A manager of channels belonging to a client\n * @extends {BaseManager}\n */\nclass ChannelManager extends BaseManager {\n  constructor(client, iterable) {\n    super(client, iterable, Channel);\n  }\n\n  /**\n   * The cache of Channels\n   * @type {Collection<Snowflake, Channel>}\n   * @name ChannelManager#cache\n   */\n\n  add(data, guild, cache = true) {\n    const existing = this.cache.get(data.id);\n    if (existing) {\n      if (existing._patch && cache) existing._patch(data);\n      if (guild) guild.channels.add(existing);\n      return existing;\n    }\n\n    const channel = Channel.create(this.client, data, guild);\n\n    if (!channel) {\n      this.client.emit(Events.DEBUG, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);\n      return null;\n    }\n\n    if (cache) this.cache.set(channel.id, channel);\n\n    return channel;\n  }\n\n  remove(id) {\n    const channel = this.cache.get(id);\n    if (channel.guild) channel.guild.channels.cache.delete(id);\n    this.cache.delete(id);\n  }\n\n  /**\n   * Data that can be resolved to give a Channel object. This can be:\n   * * A Channel object\n   * * A Snowflake\n   * @typedef {Channel|Snowflake} ChannelResolvable\n   */\n\n  /**\n   * Resolves a ChannelResolvable to a Channel object.\n   * @method resolve\n   * @memberof ChannelManager\n   * @instance\n   * @param {ChannelResolvable} channel The channel resolvable to resolve\n   * @returns {?Channel}\n   */\n\n  /**\n   * Resolves a ChannelResolvable to a channel ID string.\n   * @method resolveID\n   * @memberof ChannelManager\n   * @instance\n   * @param {ChannelResolvable} channel The channel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Obtains a channel from Discord, or the channel cache if it's already available.\n   * @param {Snowflake} id ID of the channel\n   * @param {boolean} [cache=true] Whether to cache the new channel object if it isn't already\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Channel>}\n   * @example\n   * // Fetch a channel by its id\n   * client.channels.fetch('222109930545610754')\n   *   .then(channel => console.log(channel.name))\n   *   .catch(console.error);\n   */\n  async fetch(id, cache = true, force = false) {\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.api.channels(id).get();\n    return this.add(data, null, cache);\n  }\n}\n\nmodule.exports = ChannelManager;\n"]},"metadata":{},"sourceType":"script"}