{"ast":null,"code":"'use strict';\n\nconst {\n  TypeError\n} = require('../errors');\n\nconst Collection = require('../util/Collection');\n/**\n * Manages API methods for roles of a GuildMember and stores their cache.\n */\n\n\nclass GuildMemberRoleManager {\n  constructor(member) {\n    /**\n     * The GuildMember this manager belongs to\n     * @type {GuildMember}\n     */\n    this.member = member;\n    /**\n     * The Guild this manager belongs to\n     * @type {Guild}\n     */\n\n    this.guild = member.guild;\n    Object.defineProperty(this, 'client', {\n      value: member.client\n    });\n  }\n  /**\n   * The filtered collection of roles of the member\n   * @type {Collection<Snowflake, Role>}\n   * @private\n   * @readonly\n   */\n\n\n  get _roles() {\n    const everyone = this.guild.roles.everyone;\n    return this.guild.roles.cache.filter(role => this.member._roles.includes(role.id)).set(everyone.id, everyone);\n  }\n  /**\n   * The roles of this member\n   * @type {Collection<Snowflake, Role>}\n   * @readonly\n   */\n\n\n  get cache() {\n    return this._roles;\n  }\n  /**\n   * The role of the member used to hoist them in a separate category in the users list\n   * @type {?Role}\n   * @readonly\n   */\n\n\n  get hoist() {\n    const hoistedRoles = this._roles.filter(role => role.hoist);\n\n    if (!hoistedRoles.size) return null;\n    return hoistedRoles.reduce((prev, role) => !prev || role.comparePositionTo(prev) > 0 ? role : prev);\n  }\n  /**\n   * The role of the member used to set their color\n   * @type {?Role}\n   * @readonly\n   */\n\n\n  get color() {\n    const coloredRoles = this._roles.filter(role => role.color);\n\n    if (!coloredRoles.size) return null;\n    return coloredRoles.reduce((prev, role) => !prev || role.comparePositionTo(prev) > 0 ? role : prev);\n  }\n  /**\n   * The role of the member with the highest position\n   * @type {Role}\n   * @readonly\n   */\n\n\n  get highest() {\n    return this._roles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this._roles.first());\n  }\n  /**\n   * Adds a role (or multiple roles) to the member.\n   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to add\n   * @param {string} [reason] Reason for adding the role(s)\n   * @returns {Promise<GuildMember>}\n   */\n\n\n  async add(roleOrRoles, reason) {\n    if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {\n      roleOrRoles = roleOrRoles.map(r => this.guild.roles.resolve(r));\n\n      if (roleOrRoles.includes(null)) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n\n      const newRoles = [...new Set(roleOrRoles.concat(...this._roles.values()))];\n      return this.set(newRoles, reason);\n    } else {\n      roleOrRoles = this.guild.roles.resolve(roleOrRoles);\n\n      if (roleOrRoles === null) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Role, Snowflake or Array or Collection of Roles or Snowflakes');\n      }\n\n      await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles.id].put({\n        reason\n      });\n\n      const clone = this.member._clone();\n\n      clone._roles = [...this._roles.keys(), roleOrRoles.id];\n      return clone;\n    }\n  }\n  /**\n   * Removes a role (or multiple roles) from the member.\n   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to remove\n   * @param {string} [reason] Reason for removing the role(s)\n   * @returns {Promise<GuildMember>}\n   */\n\n\n  async remove(roleOrRoles, reason) {\n    if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {\n      roleOrRoles = roleOrRoles.map(r => this.guild.roles.resolve(r));\n\n      if (roleOrRoles.includes(null)) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n\n      const newRoles = this._roles.filter(role => !roleOrRoles.includes(role));\n\n      return this.set(newRoles, reason);\n    } else {\n      roleOrRoles = this.guild.roles.resolve(roleOrRoles);\n\n      if (roleOrRoles === null) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n\n      await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles.id].delete({\n        reason\n      });\n\n      const clone = this.member._clone();\n\n      const newRoles = this._roles.filter(role => role.id !== roleOrRoles.id);\n\n      clone._roles = [...newRoles.keys()];\n      return clone;\n    }\n  }\n  /**\n   * Sets the roles applied to the member.\n   * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role IDs to apply\n   * @param {string} [reason] Reason for applying the roles\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Set the member's roles to a single role\n   * guildMember.roles.set(['391156570408615936'])\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Remove all the roles from a member\n   * guildMember.roles.set([])\n   *   .then(member => console.log(`Member roles is now of ${member.roles.cache.size} size`))\n   *   .catch(console.error);\n   */\n\n\n  set(roles, reason) {\n    return this.member.edit({\n      roles\n    }, reason);\n  }\n\n  clone() {\n    const clone = new this.constructor(this.member);\n    clone.member._roles = [...this._roles.keyArray()];\n    return clone;\n  }\n\n}\n\nmodule.exports = GuildMemberRoleManager;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/managers/GuildMemberRoleManager.js"],"names":["TypeError","require","Collection","GuildMemberRoleManager","constructor","member","guild","Object","defineProperty","value","client","_roles","everyone","roles","cache","filter","role","includes","id","set","hoist","hoistedRoles","size","reduce","prev","comparePositionTo","color","coloredRoles","highest","first","add","roleOrRoles","reason","Array","isArray","map","r","resolve","newRoles","Set","concat","values","api","guilds","members","put","clone","_clone","keys","remove","delete","edit","keyArray","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst { TypeError } = require('../errors');\nconst Collection = require('../util/Collection');\n\n/**\n * Manages API methods for roles of a GuildMember and stores their cache.\n */\nclass GuildMemberRoleManager {\n  constructor(member) {\n    /**\n     * The GuildMember this manager belongs to\n     * @type {GuildMember}\n     */\n    this.member = member;\n    /**\n     * The Guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = member.guild;\n    Object.defineProperty(this, 'client', { value: member.client });\n  }\n\n  /**\n   * The filtered collection of roles of the member\n   * @type {Collection<Snowflake, Role>}\n   * @private\n   * @readonly\n   */\n  get _roles() {\n    const everyone = this.guild.roles.everyone;\n    return this.guild.roles.cache.filter(role => this.member._roles.includes(role.id)).set(everyone.id, everyone);\n  }\n\n  /**\n   * The roles of this member\n   * @type {Collection<Snowflake, Role>}\n   * @readonly\n   */\n  get cache() {\n    return this._roles;\n  }\n\n  /**\n   * The role of the member used to hoist them in a separate category in the users list\n   * @type {?Role}\n   * @readonly\n   */\n  get hoist() {\n    const hoistedRoles = this._roles.filter(role => role.hoist);\n    if (!hoistedRoles.size) return null;\n    return hoistedRoles.reduce((prev, role) => (!prev || role.comparePositionTo(prev) > 0 ? role : prev));\n  }\n\n  /**\n   * The role of the member used to set their color\n   * @type {?Role}\n   * @readonly\n   */\n  get color() {\n    const coloredRoles = this._roles.filter(role => role.color);\n    if (!coloredRoles.size) return null;\n    return coloredRoles.reduce((prev, role) => (!prev || role.comparePositionTo(prev) > 0 ? role : prev));\n  }\n\n  /**\n   * The role of the member with the highest position\n   * @type {Role}\n   * @readonly\n   */\n  get highest() {\n    return this._roles.reduce((prev, role) => (role.comparePositionTo(prev) > 0 ? role : prev), this._roles.first());\n  }\n\n  /**\n   * Adds a role (or multiple roles) to the member.\n   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to add\n   * @param {string} [reason] Reason for adding the role(s)\n   * @returns {Promise<GuildMember>}\n   */\n  async add(roleOrRoles, reason) {\n    if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {\n      roleOrRoles = roleOrRoles.map(r => this.guild.roles.resolve(r));\n      if (roleOrRoles.includes(null)) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n\n      const newRoles = [...new Set(roleOrRoles.concat(...this._roles.values()))];\n      return this.set(newRoles, reason);\n    } else {\n      roleOrRoles = this.guild.roles.resolve(roleOrRoles);\n      if (roleOrRoles === null) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Role, Snowflake or Array or Collection of Roles or Snowflakes');\n      }\n\n      await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles.id].put({ reason });\n\n      const clone = this.member._clone();\n      clone._roles = [...this._roles.keys(), roleOrRoles.id];\n      return clone;\n    }\n  }\n\n  /**\n   * Removes a role (or multiple roles) from the member.\n   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to remove\n   * @param {string} [reason] Reason for removing the role(s)\n   * @returns {Promise<GuildMember>}\n   */\n  async remove(roleOrRoles, reason) {\n    if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {\n      roleOrRoles = roleOrRoles.map(r => this.guild.roles.resolve(r));\n      if (roleOrRoles.includes(null)) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n\n      const newRoles = this._roles.filter(role => !roleOrRoles.includes(role));\n      return this.set(newRoles, reason);\n    } else {\n      roleOrRoles = this.guild.roles.resolve(roleOrRoles);\n      if (roleOrRoles === null) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n\n      await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles.id].delete({ reason });\n\n      const clone = this.member._clone();\n      const newRoles = this._roles.filter(role => role.id !== roleOrRoles.id);\n      clone._roles = [...newRoles.keys()];\n      return clone;\n    }\n  }\n\n  /**\n   * Sets the roles applied to the member.\n   * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role IDs to apply\n   * @param {string} [reason] Reason for applying the roles\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Set the member's roles to a single role\n   * guildMember.roles.set(['391156570408615936'])\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Remove all the roles from a member\n   * guildMember.roles.set([])\n   *   .then(member => console.log(`Member roles is now of ${member.roles.cache.size} size`))\n   *   .catch(console.error);\n   */\n  set(roles, reason) {\n    return this.member.edit({ roles }, reason);\n  }\n\n  clone() {\n    const clone = new this.constructor(this.member);\n    clone.member._roles = [...this._roles.keyArray()];\n    return clone;\n  }\n}\n\nmodule.exports = GuildMemberRoleManager;\n"]},"metadata":{},"sourceType":"script"}