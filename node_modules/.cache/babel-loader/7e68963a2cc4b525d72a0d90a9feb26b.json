{"ast":null,"code":"'use strict';\n\nconst BaseManager = require('./BaseManager');\n\nconst {\n  Error,\n  TypeError,\n  RangeError\n} = require('../errors');\n\nconst GuildMember = require('../structures/GuildMember');\n\nconst Collection = require('../util/Collection');\n\nconst {\n  Events,\n  OPCodes\n} = require('../util/Constants');\n\nconst SnowflakeUtil = require('../util/Snowflake');\n/**\n * Manages API methods for GuildMembers and stores their cache.\n * @extends {BaseManager}\n */\n\n\nclass GuildMemberManager extends BaseManager {\n  constructor(guild, iterable) {\n    super(guild.client, iterable, GuildMember);\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n  }\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildMember>}\n   * @name GuildMemberManager#cache\n   */\n\n\n  add(data) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return super.add(data, cache, {\n      id: data.user.id,\n      extras: [this.guild]\n    });\n  }\n  /**\n   * Data that resolves to give a GuildMember object. This can be:\n   * * A GuildMember object\n   * * A User resolvable\n   * @typedef {GuildMember|UserResolvable} GuildMemberResolvable\n   */\n\n  /**\n   * Resolves a GuildMemberResolvable to a GuildMember object.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?GuildMember}\n   */\n\n\n  resolve(member) {\n    const memberResolvable = super.resolve(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveID(member);\n    if (userResolvable) return super.resolve(userResolvable);\n    return null;\n  }\n  /**\n   * Resolves a GuildMemberResolvable to a member ID string.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?Snowflake}\n   */\n\n\n  resolveID(member) {\n    const memberResolvable = super.resolveID(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveID(member);\n    return this.cache.has(userResolvable) ? userResolvable : null;\n  }\n  /**\n   * Options used to fetch a single member from a guild.\n   * @typedef {Object} FetchMemberOptions\n   * @property {UserResolvable} user The user to fetch\n   * @property {boolean} [cache=true] Whether or not to cache the fetched member\n   * @property {boolean} [force=false] Whether to skip the cache check and request the API\n   */\n\n  /**\n   * Options used to fetch multiple members from a guild.\n   * @typedef {Object} FetchMembersOptions\n   * @property {UserResolvable|UserResolvable[]} user The user(s) to fetch\n   * @property {?string} query Limit fetch to members with similar usernames\n   * @property {number} [limit=0] Maximum number of members to request\n   * @property {boolean} [withPresences=false] Whether or not to include the presences\n   * @property {number} [time=120e3] Timeout for receipt of members\n   * @property {?string} nonce Nonce for this request (32 characters max - default to base 16 now timestamp)\n   * @property {boolean} [force=false] Whether to skip the cache check and request the API\n   */\n\n  /**\n   * Fetches member(s) from Discord, even if they're offline.\n   * @param {UserResolvable|FetchMemberOptions|FetchMembersOptions} [options] If a UserResolvable, the user to fetch.\n   * If undefined, fetches all members.\n   * If a query, it limits the results to users with similar usernames.\n   * @returns {Promise<GuildMember>|Promise<Collection<Snowflake, GuildMember>>}\n   * @example\n   * // Fetch all members from a guild\n   * guild.members.fetch()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member\n   * guild.members.fetch('66564597481480192')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member without checking cache\n   * guild.members.fetch({ user, force: true })\n   *   .then(console.log)\n   *   .catch(console.error)\n   * @example\n   * // Fetch a single member without caching\n   * guild.members.fetch({ user, cache: false })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by an array of users including their presences\n   * guild.members.fetch({ user: ['66564597481480192', '191615925336670208'], withPresences: true })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by query\n   * guild.members.fetch({ query: 'hydra', limit: 1 })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  fetch(options) {\n    if (!options) return this._fetchMany();\n    const user = this.client.users.resolveID(options);\n    if (user) return this._fetchSingle({\n      user,\n      cache: true\n    });\n\n    if (options.user) {\n      if (Array.isArray(options.user)) {\n        options.user = options.user.map(u => this.client.users.resolveID(u));\n        return this._fetchMany(options);\n      } else {\n        options.user = this.client.users.resolveID(options.user);\n      }\n\n      if (!options.limit && !options.withPresences) return this._fetchSingle(options);\n    }\n\n    return this._fetchMany(options);\n  }\n  /**\n   * Prunes members from the guild based on how long they have been inactive.\n   * <info>It's recommended to set options.count to `false` for large guilds.</info>\n   * @param {Object} [options] Prune options\n   * @param {number} [options.days=7] Number of days of inactivity required to kick\n   * @param {boolean} [options.dry=false] Get number of users that will be kicked, without actually kicking them\n   * @param {boolean} [options.count=true] Whether or not to return the number of users that have been kicked.\n   * @param {RoleResolvable[]} [options.roles=[]] Array of roles to bypass the \"...and no roles\" constraint when pruning\n   * @param {string} [options.reason] Reason for this prune\n   * @returns {Promise<number|null>} The number of members that were/will be kicked\n   * @example\n   * // See how many members will be pruned\n   * guild.members.prune({ dry: true })\n   *   .then(pruned => console.log(`This will prune ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Actually prune the members\n   * guild.members.prune({ days: 1, reason: 'too many people!' })\n   *   .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Include members with a specified role\n   * guild.members.prune({ days: 7, roles: ['657259391652855808'] })\n   *    .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *    .catch(console.error);\n   */\n\n\n  prune() {\n    let {\n      days = 7,\n      dry = false,\n      count: compute_prune_count = true,\n      roles = [],\n      reason\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (typeof days !== 'number') throw new TypeError('PRUNE_DAYS_TYPE');\n    const query = {\n      days\n    };\n    const resolvedRoles = [];\n\n    for (const role of roles) {\n      const resolvedRole = this.guild.roles.resolveID(role);\n\n      if (!resolvedRole) {\n        return Promise.reject(new TypeError('INVALID_TYPE', 'roles', 'Array of Roles or Snowflakes', true));\n      }\n\n      resolvedRoles.push(resolvedRole);\n    }\n\n    if (resolvedRoles.length) {\n      query.include_roles = dry ? resolvedRoles.join(',') : resolvedRoles;\n    }\n\n    const endpoint = this.client.api.guilds(this.guild.id).prune;\n\n    if (dry) {\n      return endpoint.get({\n        query,\n        reason\n      }).then(data => data.pruned);\n    }\n\n    return endpoint.post({\n      data: { ...query,\n        compute_prune_count\n      },\n      reason\n    }).then(data => data.pruned);\n  }\n  /**\n   * Bans a user from the guild.\n   * @param {UserResolvable} user The user to ban\n   * @param {Object} [options] Options for the ban\n   * @param {number} [options.days=0] Number of days of messages to delete, must be between 0 and 7\n   * @param {string} [options.reason] Reason for banning\n   * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.\n   * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot\n   * be resolved, the user ID will be the result.\n   * @example\n   * // Ban a user by ID (or with a user/guild member object)\n   * guild.members.ban('84484653687267328')\n   *   .then(user => console.log(`Banned ${user.username || user.id || user} from ${guild.name}`))\n   *   .catch(console.error);\n   */\n\n\n  ban(user) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      days: 0\n    };\n    if (options.days) options.delete_message_days = options.days;\n    const id = this.client.users.resolveID(user);\n    if (!id) return Promise.reject(new Error('BAN_RESOLVE_ID', true));\n    return this.client.api.guilds(this.guild.id).bans[id].put({\n      data: options\n    }).then(() => {\n      if (user instanceof GuildMember) return user;\n\n      const _user = this.client.users.resolve(id);\n\n      if (_user) {\n        const member = this.resolve(_user);\n        return member || _user;\n      }\n\n      return id;\n    });\n  }\n  /**\n   * Unbans a user from the guild.\n   * @param {UserResolvable} user The user to unban\n   * @param {string} [reason] Reason for unbanning user\n   * @returns {Promise<User>}\n   * @example\n   * // Unban a user by ID (or with a user/guild member object)\n   * guild.members.unban('84484653687267328')\n   *   .then(user => console.log(`Unbanned ${user.username} from ${guild.name}`))\n   *   .catch(console.error);\n   */\n\n\n  unban(user, reason) {\n    const id = this.client.users.resolveID(user);\n    if (!id) return Promise.reject(new Error('BAN_RESOLVE_ID'));\n    return this.client.api.guilds(this.guild.id).bans[id].delete({\n      reason\n    }).then(() => this.client.users.resolve(user));\n  }\n\n  _fetchSingle(_ref) {\n    let {\n      user,\n      cache,\n      force = false\n    } = _ref;\n\n    if (!force) {\n      const existing = this.cache.get(user);\n      if (existing && !existing.partial) return Promise.resolve(existing);\n    }\n\n    return this.client.api.guilds(this.guild.id).members(user).get().then(data => this.add(data, cache));\n  }\n\n  _fetchMany() {\n    let {\n      limit = 0,\n      withPresences: presences = false,\n      user: user_ids,\n      query,\n      time = 120e3,\n      nonce = SnowflakeUtil.generate(),\n      force = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Promise((resolve, reject) => {\n      if (this.guild.memberCount === this.cache.size && !query && !limit && !presences && !user_ids && !force) {\n        resolve(this.cache);\n        return;\n      }\n\n      if (!query && !user_ids) query = '';\n      if (nonce.length > 32) throw new RangeError('MEMBER_FETCH_NONCE_LENGTH');\n      this.guild.shard.send({\n        op: OPCodes.REQUEST_GUILD_MEMBERS,\n        d: {\n          guild_id: this.guild.id,\n          presences,\n          user_ids,\n          query,\n          nonce,\n          limit\n        }\n      });\n      const fetchedMembers = new Collection();\n      const option = query || limit || presences || user_ids;\n      let i = 0;\n\n      const handler = (members, _, chunk) => {\n        timeout.refresh();\n        if (chunk.nonce !== nonce) return;\n        i++;\n\n        for (const member of members.values()) {\n          if (option) fetchedMembers.set(member.id, member);\n        }\n\n        if (this.guild.memberCount <= this.cache.size || option && members.size < 1000 || limit && fetchedMembers.size >= limit || i === chunk.count) {\n          this.client.clearTimeout(timeout);\n          this.client.removeListener(Events.GUILD_MEMBERS_CHUNK, handler);\n          this.client.decrementMaxListeners();\n          let fetched = option ? fetchedMembers : this.cache;\n          if (user_ids && !Array.isArray(user_ids) && fetched.size) fetched = fetched.first();\n          resolve(fetched);\n        }\n      };\n\n      const timeout = this.client.setTimeout(() => {\n        this.client.removeListener(Events.GUILD_MEMBERS_CHUNK, handler);\n        this.client.decrementMaxListeners();\n        reject(new Error('GUILD_MEMBERS_TIMEOUT'));\n      }, time);\n      this.client.incrementMaxListeners();\n      this.client.on(Events.GUILD_MEMBERS_CHUNK, handler);\n    });\n  }\n\n}\n\nmodule.exports = GuildMemberManager;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/managers/GuildMemberManager.js"],"names":["BaseManager","require","Error","TypeError","RangeError","GuildMember","Collection","Events","OPCodes","SnowflakeUtil","GuildMemberManager","constructor","guild","iterable","client","add","data","cache","id","user","extras","resolve","member","memberResolvable","userResolvable","users","resolveID","has","fetch","options","_fetchMany","_fetchSingle","Array","isArray","map","u","limit","withPresences","prune","days","dry","count","compute_prune_count","roles","reason","query","resolvedRoles","role","resolvedRole","Promise","reject","push","length","include_roles","join","endpoint","api","guilds","get","then","pruned","post","ban","delete_message_days","bans","put","_user","unban","delete","force","existing","partial","members","presences","user_ids","time","nonce","generate","memberCount","size","shard","send","op","REQUEST_GUILD_MEMBERS","d","guild_id","fetchedMembers","option","i","handler","_","chunk","timeout","refresh","values","set","clearTimeout","removeListener","GUILD_MEMBERS_CHUNK","decrementMaxListeners","fetched","first","setTimeout","incrementMaxListeners","on","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst BaseManager = require('./BaseManager');\nconst { Error, TypeError, RangeError } = require('../errors');\nconst GuildMember = require('../structures/GuildMember');\nconst Collection = require('../util/Collection');\nconst { Events, OPCodes } = require('../util/Constants');\nconst SnowflakeUtil = require('../util/Snowflake');\n\n/**\n * Manages API methods for GuildMembers and stores their cache.\n * @extends {BaseManager}\n */\nclass GuildMemberManager extends BaseManager {\n  constructor(guild, iterable) {\n    super(guild.client, iterable, GuildMember);\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildMember>}\n   * @name GuildMemberManager#cache\n   */\n\n  add(data, cache = true) {\n    return super.add(data, cache, { id: data.user.id, extras: [this.guild] });\n  }\n\n  /**\n   * Data that resolves to give a GuildMember object. This can be:\n   * * A GuildMember object\n   * * A User resolvable\n   * @typedef {GuildMember|UserResolvable} GuildMemberResolvable\n   */\n\n  /**\n   * Resolves a GuildMemberResolvable to a GuildMember object.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?GuildMember}\n   */\n  resolve(member) {\n    const memberResolvable = super.resolve(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveID(member);\n    if (userResolvable) return super.resolve(userResolvable);\n    return null;\n  }\n\n  /**\n   * Resolves a GuildMemberResolvable to a member ID string.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?Snowflake}\n   */\n  resolveID(member) {\n    const memberResolvable = super.resolveID(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveID(member);\n    return this.cache.has(userResolvable) ? userResolvable : null;\n  }\n\n  /**\n   * Options used to fetch a single member from a guild.\n   * @typedef {Object} FetchMemberOptions\n   * @property {UserResolvable} user The user to fetch\n   * @property {boolean} [cache=true] Whether or not to cache the fetched member\n   * @property {boolean} [force=false] Whether to skip the cache check and request the API\n   */\n\n  /**\n   * Options used to fetch multiple members from a guild.\n   * @typedef {Object} FetchMembersOptions\n   * @property {UserResolvable|UserResolvable[]} user The user(s) to fetch\n   * @property {?string} query Limit fetch to members with similar usernames\n   * @property {number} [limit=0] Maximum number of members to request\n   * @property {boolean} [withPresences=false] Whether or not to include the presences\n   * @property {number} [time=120e3] Timeout for receipt of members\n   * @property {?string} nonce Nonce for this request (32 characters max - default to base 16 now timestamp)\n   * @property {boolean} [force=false] Whether to skip the cache check and request the API\n   */\n\n  /**\n   * Fetches member(s) from Discord, even if they're offline.\n   * @param {UserResolvable|FetchMemberOptions|FetchMembersOptions} [options] If a UserResolvable, the user to fetch.\n   * If undefined, fetches all members.\n   * If a query, it limits the results to users with similar usernames.\n   * @returns {Promise<GuildMember>|Promise<Collection<Snowflake, GuildMember>>}\n   * @example\n   * // Fetch all members from a guild\n   * guild.members.fetch()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member\n   * guild.members.fetch('66564597481480192')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member without checking cache\n   * guild.members.fetch({ user, force: true })\n   *   .then(console.log)\n   *   .catch(console.error)\n   * @example\n   * // Fetch a single member without caching\n   * guild.members.fetch({ user, cache: false })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by an array of users including their presences\n   * guild.members.fetch({ user: ['66564597481480192', '191615925336670208'], withPresences: true })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by query\n   * guild.members.fetch({ query: 'hydra', limit: 1 })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  fetch(options) {\n    if (!options) return this._fetchMany();\n    const user = this.client.users.resolveID(options);\n    if (user) return this._fetchSingle({ user, cache: true });\n    if (options.user) {\n      if (Array.isArray(options.user)) {\n        options.user = options.user.map(u => this.client.users.resolveID(u));\n        return this._fetchMany(options);\n      } else {\n        options.user = this.client.users.resolveID(options.user);\n      }\n      if (!options.limit && !options.withPresences) return this._fetchSingle(options);\n    }\n    return this._fetchMany(options);\n  }\n\n  /**\n   * Prunes members from the guild based on how long they have been inactive.\n   * <info>It's recommended to set options.count to `false` for large guilds.</info>\n   * @param {Object} [options] Prune options\n   * @param {number} [options.days=7] Number of days of inactivity required to kick\n   * @param {boolean} [options.dry=false] Get number of users that will be kicked, without actually kicking them\n   * @param {boolean} [options.count=true] Whether or not to return the number of users that have been kicked.\n   * @param {RoleResolvable[]} [options.roles=[]] Array of roles to bypass the \"...and no roles\" constraint when pruning\n   * @param {string} [options.reason] Reason for this prune\n   * @returns {Promise<number|null>} The number of members that were/will be kicked\n   * @example\n   * // See how many members will be pruned\n   * guild.members.prune({ dry: true })\n   *   .then(pruned => console.log(`This will prune ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Actually prune the members\n   * guild.members.prune({ days: 1, reason: 'too many people!' })\n   *   .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Include members with a specified role\n   * guild.members.prune({ days: 7, roles: ['657259391652855808'] })\n   *    .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *    .catch(console.error);\n   */\n  prune({ days = 7, dry = false, count: compute_prune_count = true, roles = [], reason } = {}) {\n    if (typeof days !== 'number') throw new TypeError('PRUNE_DAYS_TYPE');\n\n    const query = { days };\n    const resolvedRoles = [];\n\n    for (const role of roles) {\n      const resolvedRole = this.guild.roles.resolveID(role);\n      if (!resolvedRole) {\n        return Promise.reject(new TypeError('INVALID_TYPE', 'roles', 'Array of Roles or Snowflakes', true));\n      }\n      resolvedRoles.push(resolvedRole);\n    }\n\n    if (resolvedRoles.length) {\n      query.include_roles = dry ? resolvedRoles.join(',') : resolvedRoles;\n    }\n\n    const endpoint = this.client.api.guilds(this.guild.id).prune;\n\n    if (dry) {\n      return endpoint.get({ query, reason }).then(data => data.pruned);\n    }\n\n    return endpoint\n      .post({\n        data: { ...query, compute_prune_count },\n        reason,\n      })\n      .then(data => data.pruned);\n  }\n\n  /**\n   * Bans a user from the guild.\n   * @param {UserResolvable} user The user to ban\n   * @param {Object} [options] Options for the ban\n   * @param {number} [options.days=0] Number of days of messages to delete, must be between 0 and 7\n   * @param {string} [options.reason] Reason for banning\n   * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.\n   * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot\n   * be resolved, the user ID will be the result.\n   * @example\n   * // Ban a user by ID (or with a user/guild member object)\n   * guild.members.ban('84484653687267328')\n   *   .then(user => console.log(`Banned ${user.username || user.id || user} from ${guild.name}`))\n   *   .catch(console.error);\n   */\n  ban(user, options = { days: 0 }) {\n    if (options.days) options.delete_message_days = options.days;\n    const id = this.client.users.resolveID(user);\n    if (!id) return Promise.reject(new Error('BAN_RESOLVE_ID', true));\n    return this.client.api\n      .guilds(this.guild.id)\n      .bans[id].put({ data: options })\n      .then(() => {\n        if (user instanceof GuildMember) return user;\n        const _user = this.client.users.resolve(id);\n        if (_user) {\n          const member = this.resolve(_user);\n          return member || _user;\n        }\n        return id;\n      });\n  }\n\n  /**\n   * Unbans a user from the guild.\n   * @param {UserResolvable} user The user to unban\n   * @param {string} [reason] Reason for unbanning user\n   * @returns {Promise<User>}\n   * @example\n   * // Unban a user by ID (or with a user/guild member object)\n   * guild.members.unban('84484653687267328')\n   *   .then(user => console.log(`Unbanned ${user.username} from ${guild.name}`))\n   *   .catch(console.error);\n   */\n  unban(user, reason) {\n    const id = this.client.users.resolveID(user);\n    if (!id) return Promise.reject(new Error('BAN_RESOLVE_ID'));\n    return this.client.api\n      .guilds(this.guild.id)\n      .bans[id].delete({ reason })\n      .then(() => this.client.users.resolve(user));\n  }\n\n  _fetchSingle({ user, cache, force = false }) {\n    if (!force) {\n      const existing = this.cache.get(user);\n      if (existing && !existing.partial) return Promise.resolve(existing);\n    }\n\n    return this.client.api\n      .guilds(this.guild.id)\n      .members(user)\n      .get()\n      .then(data => this.add(data, cache));\n  }\n\n  _fetchMany({\n    limit = 0,\n    withPresences: presences = false,\n    user: user_ids,\n    query,\n    time = 120e3,\n    nonce = SnowflakeUtil.generate(),\n    force = false,\n  } = {}) {\n    return new Promise((resolve, reject) => {\n      if (this.guild.memberCount === this.cache.size && !query && !limit && !presences && !user_ids && !force) {\n        resolve(this.cache);\n        return;\n      }\n      if (!query && !user_ids) query = '';\n      if (nonce.length > 32) throw new RangeError('MEMBER_FETCH_NONCE_LENGTH');\n      this.guild.shard.send({\n        op: OPCodes.REQUEST_GUILD_MEMBERS,\n        d: {\n          guild_id: this.guild.id,\n          presences,\n          user_ids,\n          query,\n          nonce,\n          limit,\n        },\n      });\n      const fetchedMembers = new Collection();\n      const option = query || limit || presences || user_ids;\n      let i = 0;\n      const handler = (members, _, chunk) => {\n        timeout.refresh();\n        if (chunk.nonce !== nonce) return;\n        i++;\n        for (const member of members.values()) {\n          if (option) fetchedMembers.set(member.id, member);\n        }\n        if (\n          this.guild.memberCount <= this.cache.size ||\n          (option && members.size < 1000) ||\n          (limit && fetchedMembers.size >= limit) ||\n          i === chunk.count\n        ) {\n          this.client.clearTimeout(timeout);\n          this.client.removeListener(Events.GUILD_MEMBERS_CHUNK, handler);\n          this.client.decrementMaxListeners();\n          let fetched = option ? fetchedMembers : this.cache;\n          if (user_ids && !Array.isArray(user_ids) && fetched.size) fetched = fetched.first();\n          resolve(fetched);\n        }\n      };\n      const timeout = this.client.setTimeout(() => {\n        this.client.removeListener(Events.GUILD_MEMBERS_CHUNK, handler);\n        this.client.decrementMaxListeners();\n        reject(new Error('GUILD_MEMBERS_TIMEOUT'));\n      }, time);\n      this.client.incrementMaxListeners();\n      this.client.on(Events.GUILD_MEMBERS_CHUNK, handler);\n    });\n  }\n}\n\nmodule.exports = GuildMemberManager;\n"]},"metadata":{},"sourceType":"script"}