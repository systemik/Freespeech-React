{"ast":null,"code":"'use strict';\n\nconst {\n  RangeError\n} = require('../errors');\n/**\n * Data structure that makes it easy to interact with a bitfield.\n */\n\n\nclass BitField {\n  /**\n   * @param {BitFieldResolvable} [bits=0] Bit(s) to read from\n   */\n  constructor(bits) {\n    /**\n     * Bitfield of the packed bits\n     * @type {number}\n     */\n    this.bitfield = this.constructor.resolve(bits);\n  }\n  /**\n   * Checks whether the bitfield has a bit, or any of multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n\n\n  any(bit) {\n    return (this.bitfield & this.constructor.resolve(bit)) !== 0;\n  }\n  /**\n   * Checks if this bitfield equals another\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n\n\n  equals(bit) {\n    return this.bitfield === this.constructor.resolve(bit);\n  }\n  /**\n   * Checks whether the bitfield has a bit, or multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n\n\n  has(bit) {\n    if (Array.isArray(bit)) return bit.every(p => this.has(p));\n    bit = this.constructor.resolve(bit);\n    return (this.bitfield & bit) === bit;\n  }\n  /**\n   * Gets all given bits that are missing from the bitfield.\n   * @param {BitFieldResolvable} bits Bit(s) to check for\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n\n\n  missing(bits) {\n    for (var _len = arguments.length, hasParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      hasParams[_key - 1] = arguments[_key];\n    }\n\n    if (!Array.isArray(bits)) bits = new this.constructor(bits).toArray(false);\n    return bits.filter(p => !this.has(p, ...hasParams));\n  }\n  /**\n   * Freezes these bits, making them immutable.\n   * @returns {Readonly<BitField>} These bits\n   */\n\n\n  freeze() {\n    return Object.freeze(this);\n  }\n  /**\n   * Adds bits to these ones.\n   * @param {...BitFieldResolvable} [bits] Bits to add\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n\n\n  add() {\n    let total = 0;\n\n    for (var _len2 = arguments.length, bits = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      bits[_key2] = arguments[_key2];\n    }\n\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield | total);\n    this.bitfield |= total;\n    return this;\n  }\n  /**\n   * Removes bits from these.\n   * @param {...BitFieldResolvable} [bits] Bits to remove\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n\n\n  remove() {\n    let total = 0;\n\n    for (var _len3 = arguments.length, bits = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      bits[_key3] = arguments[_key3];\n    }\n\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield & ~total);\n    this.bitfield &= ~total;\n    return this;\n  }\n  /**\n   * Gets an object mapping field names to a {@link boolean} indicating whether the\n   * bit is available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {Object}\n   */\n\n\n  serialize() {\n    const serialized = {};\n\n    for (var _len4 = arguments.length, hasParams = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      hasParams[_key4] = arguments[_key4];\n    }\n\n    for (const [flag, bit] of Object.entries(this.constructor.FLAGS)) serialized[flag] = this.has(bit, ...hasParams);\n\n    return serialized;\n  }\n  /**\n   * Gets an {@link Array} of bitfield names based on the bits available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n\n\n  toArray() {\n    for (var _len5 = arguments.length, hasParams = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      hasParams[_key5] = arguments[_key5];\n    }\n\n    return Object.keys(this.constructor.FLAGS).filter(bit => this.has(bit, ...hasParams));\n  }\n\n  toJSON() {\n    return this.bitfield;\n  }\n\n  valueOf() {\n    return this.bitfield;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.toArray();\n  }\n  /**\n   * Data that can be resolved to give a bitfield. This can be:\n   * * A string (see {@link BitField.FLAGS})\n   * * A bit number\n   * * An instance of BitField\n   * * An Array of BitFieldResolvable\n   * @typedef {string|number|BitField|BitFieldResolvable[]} BitFieldResolvable\n   */\n\n  /**\n   * Resolves bitfields to their numeric form.\n   * @param {BitFieldResolvable} [bit=0] - bit(s) to resolve\n   * @returns {number}\n   */\n\n\n  static resolve() {\n    let bit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (typeof bit === 'number' && bit >= 0) return bit;\n    if (bit instanceof BitField) return bit.bitfield;\n    if (Array.isArray(bit)) return bit.map(p => this.resolve(p)).reduce((prev, p) => prev | p, 0);\n    if (typeof bit === 'string' && typeof this.FLAGS[bit] !== 'undefined') return this.FLAGS[bit];\n    const error = new RangeError('BITFIELD_INVALID');\n    error.bit = bit;\n    throw error;\n  }\n\n}\n/**\n * Numeric bitfield flags.\n * <info>Defined in extension classes</info>\n * @type {Object}\n * @abstract\n */\n\n\nBitField.FLAGS = {};\nmodule.exports = BitField;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/util/BitField.js"],"names":["RangeError","require","BitField","constructor","bits","bitfield","resolve","any","bit","equals","has","Array","isArray","every","p","missing","hasParams","toArray","filter","freeze","Object","add","total","isFrozen","remove","serialize","serialized","flag","entries","FLAGS","keys","toJSON","valueOf","Symbol","iterator","map","reduce","prev","error","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst { RangeError } = require('../errors');\n\n/**\n * Data structure that makes it easy to interact with a bitfield.\n */\nclass BitField {\n  /**\n   * @param {BitFieldResolvable} [bits=0] Bit(s) to read from\n   */\n  constructor(bits) {\n    /**\n     * Bitfield of the packed bits\n     * @type {number}\n     */\n    this.bitfield = this.constructor.resolve(bits);\n  }\n\n  /**\n   * Checks whether the bitfield has a bit, or any of multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  any(bit) {\n    return (this.bitfield & this.constructor.resolve(bit)) !== 0;\n  }\n\n  /**\n   * Checks if this bitfield equals another\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  equals(bit) {\n    return this.bitfield === this.constructor.resolve(bit);\n  }\n\n  /**\n   * Checks whether the bitfield has a bit, or multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  has(bit) {\n    if (Array.isArray(bit)) return bit.every(p => this.has(p));\n    bit = this.constructor.resolve(bit);\n    return (this.bitfield & bit) === bit;\n  }\n\n  /**\n   * Gets all given bits that are missing from the bitfield.\n   * @param {BitFieldResolvable} bits Bit(s) to check for\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n  missing(bits, ...hasParams) {\n    if (!Array.isArray(bits)) bits = new this.constructor(bits).toArray(false);\n    return bits.filter(p => !this.has(p, ...hasParams));\n  }\n\n  /**\n   * Freezes these bits, making them immutable.\n   * @returns {Readonly<BitField>} These bits\n   */\n  freeze() {\n    return Object.freeze(this);\n  }\n\n  /**\n   * Adds bits to these ones.\n   * @param {...BitFieldResolvable} [bits] Bits to add\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n  add(...bits) {\n    let total = 0;\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield | total);\n    this.bitfield |= total;\n    return this;\n  }\n\n  /**\n   * Removes bits from these.\n   * @param {...BitFieldResolvable} [bits] Bits to remove\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n  remove(...bits) {\n    let total = 0;\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield & ~total);\n    this.bitfield &= ~total;\n    return this;\n  }\n\n  /**\n   * Gets an object mapping field names to a {@link boolean} indicating whether the\n   * bit is available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {Object}\n   */\n  serialize(...hasParams) {\n    const serialized = {};\n    for (const [flag, bit] of Object.entries(this.constructor.FLAGS)) serialized[flag] = this.has(bit, ...hasParams);\n    return serialized;\n  }\n\n  /**\n   * Gets an {@link Array} of bitfield names based on the bits available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n  toArray(...hasParams) {\n    return Object.keys(this.constructor.FLAGS).filter(bit => this.has(bit, ...hasParams));\n  }\n\n  toJSON() {\n    return this.bitfield;\n  }\n\n  valueOf() {\n    return this.bitfield;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.toArray();\n  }\n\n  /**\n   * Data that can be resolved to give a bitfield. This can be:\n   * * A string (see {@link BitField.FLAGS})\n   * * A bit number\n   * * An instance of BitField\n   * * An Array of BitFieldResolvable\n   * @typedef {string|number|BitField|BitFieldResolvable[]} BitFieldResolvable\n   */\n\n  /**\n   * Resolves bitfields to their numeric form.\n   * @param {BitFieldResolvable} [bit=0] - bit(s) to resolve\n   * @returns {number}\n   */\n  static resolve(bit = 0) {\n    if (typeof bit === 'number' && bit >= 0) return bit;\n    if (bit instanceof BitField) return bit.bitfield;\n    if (Array.isArray(bit)) return bit.map(p => this.resolve(p)).reduce((prev, p) => prev | p, 0);\n    if (typeof bit === 'string' && typeof this.FLAGS[bit] !== 'undefined') return this.FLAGS[bit];\n    const error = new RangeError('BITFIELD_INVALID');\n    error.bit = bit;\n    throw error;\n  }\n}\n\n/**\n * Numeric bitfield flags.\n * <info>Defined in extension classes</info>\n * @type {Object}\n * @abstract\n */\nBitField.FLAGS = {};\n\nmodule.exports = BitField;\n"]},"metadata":{},"sourceType":"script"}