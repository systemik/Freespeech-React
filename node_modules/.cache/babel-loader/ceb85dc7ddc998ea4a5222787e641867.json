{"ast":null,"code":"/**\n * MIT License\n *\n * Copyright (c) 2020 kyranet, discord.js\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n'use strict'; // TODO(kyranet, vladfrangu): replace this with discord.js v13's core AsyncQueue.\n\n/**\n * An async queue that preserves the stack and prevents lock-ups.\n * @private\n */\n\nclass AsyncQueue {\n  constructor() {\n    /**\n     * The promises array.\n     * @type {Array<{promise: Promise<void>, resolve: Function}>}\n     * @private\n     */\n    this.promises = [];\n  }\n  /**\n   * The remaining amount of queued promises\n   * @type {number}\n   */\n\n\n  get remaining() {\n    return this.promises.length;\n  }\n  /**\n   * Waits for last promise and queues a new one.\n   * @returns {Promise<void>}\n   * @example\n   * const queue = new AsyncQueue();\n   * async function request(url, options) {\n   *     await queue.wait();\n   *     try {\n   *         const result = await fetch(url, options);\n   *         // Do some operations with 'result'\n   *     } finally {\n   *         // Remove first entry from the queue and resolve for the next entry\n   *         queue.shift();\n   *     }\n   * }\n   *\n   * request(someUrl1, someOptions1); // Will call fetch() immediately\n   * request(someUrl2, someOptions2); // Will call fetch() after the first finished\n   * request(someUrl3, someOptions3); // Will call fetch() after the second finished\n   */\n\n\n  wait() {\n    const next = this.promises.length ? this.promises[this.promises.length - 1].promise : Promise.resolve();\n    let resolve;\n    const promise = new Promise(res => {\n      resolve = res;\n    });\n    this.promises.push({\n      resolve,\n      promise\n    });\n    return next;\n  }\n  /**\n   * Frees the queue's lock for the next item to process.\n   */\n\n\n  shift() {\n    const deferred = this.promises.shift();\n    if (typeof deferred !== 'undefined') deferred.resolve();\n  }\n\n}\n\nmodule.exports = AsyncQueue;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/rest/AsyncQueue.js"],"names":["AsyncQueue","constructor","promises","remaining","length","wait","next","promise","Promise","resolve","res","push","shift","deferred","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,a,CAEA;;AAEA;AACA;AACA;AACA;;AACA,MAAMA,UAAN,CAAiB;AACfC,EAAAA,WAAW,GAAG;AACZ;AACJ;AACA;AACA;AACA;AACI,SAAKC,QAAL,GAAgB,EAAhB;AACD;AAED;AACF;AACA;AACA;;;AACe,MAATC,SAAS,GAAG;AACd,WAAO,KAAKD,QAAL,CAAcE,MAArB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,IAAI,GAAG;AACL,UAAMC,IAAI,GAAG,KAAKJ,QAAL,CAAcE,MAAd,GAAuB,KAAKF,QAAL,CAAc,KAAKA,QAAL,CAAcE,MAAd,GAAuB,CAArC,EAAwCG,OAA/D,GAAyEC,OAAO,CAACC,OAAR,EAAtF;AACA,QAAIA,OAAJ;AACA,UAAMF,OAAO,GAAG,IAAIC,OAAJ,CAAYE,GAAG,IAAI;AACjCD,MAAAA,OAAO,GAAGC,GAAV;AACD,KAFe,CAAhB;AAIA,SAAKR,QAAL,CAAcS,IAAd,CAAmB;AACjBF,MAAAA,OADiB;AAEjBF,MAAAA;AAFiB,KAAnB;AAKA,WAAOD,IAAP;AACD;AAED;AACF;AACA;;;AACEM,EAAAA,KAAK,GAAG;AACN,UAAMC,QAAQ,GAAG,KAAKX,QAAL,CAAcU,KAAd,EAAjB;AACA,QAAI,OAAOC,QAAP,KAAoB,WAAxB,EAAqCA,QAAQ,CAACJ,OAAT;AACtC;;AA3Dc;;AA8DjBK,MAAM,CAACC,OAAP,GAAiBf,UAAjB","sourcesContent":["/**\n * MIT License\n *\n * Copyright (c) 2020 kyranet, discord.js\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n'use strict';\n\n// TODO(kyranet, vladfrangu): replace this with discord.js v13's core AsyncQueue.\n\n/**\n * An async queue that preserves the stack and prevents lock-ups.\n * @private\n */\nclass AsyncQueue {\n  constructor() {\n    /**\n     * The promises array.\n     * @type {Array<{promise: Promise<void>, resolve: Function}>}\n     * @private\n     */\n    this.promises = [];\n  }\n\n  /**\n   * The remaining amount of queued promises\n   * @type {number}\n   */\n  get remaining() {\n    return this.promises.length;\n  }\n\n  /**\n   * Waits for last promise and queues a new one.\n   * @returns {Promise<void>}\n   * @example\n   * const queue = new AsyncQueue();\n   * async function request(url, options) {\n   *     await queue.wait();\n   *     try {\n   *         const result = await fetch(url, options);\n   *         // Do some operations with 'result'\n   *     } finally {\n   *         // Remove first entry from the queue and resolve for the next entry\n   *         queue.shift();\n   *     }\n   * }\n   *\n   * request(someUrl1, someOptions1); // Will call fetch() immediately\n   * request(someUrl2, someOptions2); // Will call fetch() after the first finished\n   * request(someUrl3, someOptions3); // Will call fetch() after the second finished\n   */\n  wait() {\n    const next = this.promises.length ? this.promises[this.promises.length - 1].promise : Promise.resolve();\n    let resolve;\n    const promise = new Promise(res => {\n      resolve = res;\n    });\n\n    this.promises.push({\n      resolve,\n      promise,\n    });\n\n    return next;\n  }\n\n  /**\n   * Frees the queue's lock for the next item to process.\n   */\n  shift() {\n    const deferred = this.promises.shift();\n    if (typeof deferred !== 'undefined') deferred.resolve();\n  }\n}\n\nmodule.exports = AsyncQueue;\n"]},"metadata":{},"sourceType":"script"}