{"ast":null,"code":"'use strict';\n\nconst Collection = require('../util/Collection');\n\nconst {\n  ChannelTypes\n} = require('../util/Constants');\n\nconst Util = require('../util/Util');\n/**\n * Keeps track of mentions in a {@link Message}.\n */\n\n\nclass MessageMentions {\n  constructor(message, users, roles, everyone, crosspostedChannels) {\n    /**\n     * The client the message is from\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: message.client\n    });\n    /**\n     * The guild the message is in\n     * @type {?Guild}\n     * @readonly\n     */\n\n    Object.defineProperty(this, 'guild', {\n      value: message.guild\n    });\n    /**\n     * The initial message content\n     * @type {string}\n     * @readonly\n     * @private\n     */\n\n    Object.defineProperty(this, '_content', {\n      value: message.content\n    });\n    /**\n     * Whether `@everyone` or `@here` were mentioned\n     * @type {boolean}\n     */\n\n    this.everyone = Boolean(everyone);\n\n    if (users) {\n      if (users instanceof Collection) {\n        /**\n         * Any users that were mentioned\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, User>}\n         */\n        this.users = new Collection(users);\n      } else {\n        this.users = new Collection();\n\n        for (const mention of users) {\n          if (mention.member && message.guild) {\n            message.guild.members.add(Object.assign(mention.member, {\n              user: mention\n            }));\n          }\n\n          const user = message.client.users.add(mention);\n          this.users.set(user.id, user);\n        }\n      }\n    } else {\n      this.users = new Collection();\n    }\n\n    if (roles) {\n      if (roles instanceof Collection) {\n        /**\n         * Any roles that were mentioned\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, Role>}\n         */\n        this.roles = new Collection(roles);\n      } else {\n        this.roles = new Collection();\n\n        for (const mention of roles) {\n          const role = message.channel.guild.roles.cache.get(mention);\n          if (role) this.roles.set(role.id, role);\n        }\n      }\n    } else {\n      this.roles = new Collection();\n    }\n    /**\n     * Cached members for {@link MessageMentions#members}\n     * @type {?Collection<Snowflake, GuildMember>}\n     * @private\n     */\n\n\n    this._members = null;\n    /**\n     * Cached channels for {@link MessageMentions#channels}\n     * @type {?Collection<Snowflake, GuildChannel>}\n     * @private\n     */\n\n    this._channels = null;\n    /**\n     * Crossposted channel data.\n     * @typedef {Object} CrosspostedChannel\n     * @property {string} channelID ID of the mentioned channel\n     * @property {string} guildID ID of the guild that has the channel\n     * @property {string} type Type of the channel\n     * @property {string} name The name of the channel\n     */\n\n    if (crosspostedChannels) {\n      if (crosspostedChannels instanceof Collection) {\n        /**\n         * A collection of crossposted channels\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, CrosspostedChannel>}\n         */\n        this.crosspostedChannels = new Collection(crosspostedChannels);\n      } else {\n        this.crosspostedChannels = new Collection();\n        const channelTypes = Object.keys(ChannelTypes);\n\n        for (const d of crosspostedChannels) {\n          const type = channelTypes[d.type];\n          this.crosspostedChannels.set(d.id, {\n            channelID: d.id,\n            guildID: d.guild_id,\n            type: type ? type.toLowerCase() : 'unknown',\n            name: d.name\n          });\n        }\n      }\n    } else {\n      this.crosspostedChannels = new Collection();\n    }\n  }\n  /**\n   * Any members that were mentioned (only in {@link TextChannel}s)\n   * <info>Order as received from the API, not as they appear in the message content</info>\n   * @type {?Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n\n\n  get members() {\n    if (this._members) return this._members;\n    if (!this.guild) return null;\n    this._members = new Collection();\n    this.users.forEach(user => {\n      const member = this.guild.member(user);\n      if (member) this._members.set(member.user.id, member);\n    });\n    return this._members;\n  }\n  /**\n   * Any channels that were mentioned\n   * <info>Order as they appear first in the message content</info>\n   * @type {Collection<Snowflake, GuildChannel>}\n   * @readonly\n   */\n\n\n  get channels() {\n    if (this._channels) return this._channels;\n    this._channels = new Collection();\n    let matches;\n\n    while ((matches = this.constructor.CHANNELS_PATTERN.exec(this._content)) !== null) {\n      const chan = this.client.channels.cache.get(matches[1]);\n      if (chan) this._channels.set(chan.id, chan);\n    }\n\n    return this._channels;\n  }\n  /**\n   * Checks if a user, guild member, role, or channel is mentioned.\n   * Takes into account user mentions, role mentions, and @everyone/@here mentions.\n   * @param {UserResolvable|RoleResolvable|GuildChannelResolvable} data User/Role/Channel to check\n   * @param {Object} [options] Options\n   * @param {boolean} [options.ignoreDirect=false] - Whether to ignore direct mentions to the item\n   * @param {boolean} [options.ignoreRoles=false] - Whether to ignore role mentions to a guild member\n   * @param {boolean} [options.ignoreEveryone=false] - Whether to ignore everyone/here mentions\n   * @returns {boolean}\n   */\n\n\n  has(data) {\n    let {\n      ignoreDirect = false,\n      ignoreRoles = false,\n      ignoreEveryone = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!ignoreEveryone && this.everyone) return true;\n\n    const GuildMember = require('./GuildMember');\n\n    if (!ignoreRoles && data instanceof GuildMember) {\n      for (const role of this.roles.values()) if (data.roles.cache.has(role.id)) return true;\n    }\n\n    if (!ignoreDirect) {\n      const id = this.client.users.resolveID(data) || this.guild && this.guild.roles.resolveID(data) || this.client.channels.resolveID(data);\n      return this.users.has(id) || this.channels.has(id) || this.roles.has(id);\n    }\n\n    return false;\n  }\n\n  toJSON() {\n    return Util.flatten(this, {\n      members: true,\n      channels: true\n    });\n  }\n\n}\n/**\n * Regular expression that globally matches `@everyone` and `@here`\n * @type {RegExp}\n */\n\n\nMessageMentions.EVERYONE_PATTERN = /@(everyone|here)/g;\n/**\n * Regular expression that globally matches user mentions like `<@81440962496172032>`\n * @type {RegExp}\n */\n\nMessageMentions.USERS_PATTERN = /<@!?(\\d{17,19})>/g;\n/**\n * Regular expression that globally matches role mentions like `<@&297577916114403338>`\n * @type {RegExp}\n */\n\nMessageMentions.ROLES_PATTERN = /<@&(\\d{17,19})>/g;\n/**\n * Regular expression that globally matches channel mentions like `<#222079895583457280>`\n * @type {RegExp}\n */\n\nMessageMentions.CHANNELS_PATTERN = /<#(\\d{17,19})>/g;\nmodule.exports = MessageMentions;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/structures/MessageMentions.js"],"names":["Collection","require","ChannelTypes","Util","MessageMentions","constructor","message","users","roles","everyone","crosspostedChannels","Object","defineProperty","value","client","guild","content","Boolean","mention","member","members","add","assign","user","set","id","role","channel","cache","get","_members","_channels","channelTypes","keys","d","type","channelID","guildID","guild_id","toLowerCase","name","forEach","channels","matches","CHANNELS_PATTERN","exec","_content","chan","has","data","ignoreDirect","ignoreRoles","ignoreEveryone","GuildMember","values","resolveID","toJSON","flatten","EVERYONE_PATTERN","USERS_PATTERN","ROLES_PATTERN","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Collection = require('../util/Collection');\nconst { ChannelTypes } = require('../util/Constants');\nconst Util = require('../util/Util');\n\n/**\n * Keeps track of mentions in a {@link Message}.\n */\nclass MessageMentions {\n  constructor(message, users, roles, everyone, crosspostedChannels) {\n    /**\n     * The client the message is from\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', { value: message.client });\n\n    /**\n     * The guild the message is in\n     * @type {?Guild}\n     * @readonly\n     */\n    Object.defineProperty(this, 'guild', { value: message.guild });\n\n    /**\n     * The initial message content\n     * @type {string}\n     * @readonly\n     * @private\n     */\n    Object.defineProperty(this, '_content', { value: message.content });\n\n    /**\n     * Whether `@everyone` or `@here` were mentioned\n     * @type {boolean}\n     */\n    this.everyone = Boolean(everyone);\n\n    if (users) {\n      if (users instanceof Collection) {\n        /**\n         * Any users that were mentioned\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, User>}\n         */\n        this.users = new Collection(users);\n      } else {\n        this.users = new Collection();\n        for (const mention of users) {\n          if (mention.member && message.guild) {\n            message.guild.members.add(Object.assign(mention.member, { user: mention }));\n          }\n          const user = message.client.users.add(mention);\n          this.users.set(user.id, user);\n        }\n      }\n    } else {\n      this.users = new Collection();\n    }\n\n    if (roles) {\n      if (roles instanceof Collection) {\n        /**\n         * Any roles that were mentioned\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, Role>}\n         */\n        this.roles = new Collection(roles);\n      } else {\n        this.roles = new Collection();\n        for (const mention of roles) {\n          const role = message.channel.guild.roles.cache.get(mention);\n          if (role) this.roles.set(role.id, role);\n        }\n      }\n    } else {\n      this.roles = new Collection();\n    }\n\n    /**\n     * Cached members for {@link MessageMentions#members}\n     * @type {?Collection<Snowflake, GuildMember>}\n     * @private\n     */\n    this._members = null;\n\n    /**\n     * Cached channels for {@link MessageMentions#channels}\n     * @type {?Collection<Snowflake, GuildChannel>}\n     * @private\n     */\n    this._channels = null;\n\n    /**\n     * Crossposted channel data.\n     * @typedef {Object} CrosspostedChannel\n     * @property {string} channelID ID of the mentioned channel\n     * @property {string} guildID ID of the guild that has the channel\n     * @property {string} type Type of the channel\n     * @property {string} name The name of the channel\n     */\n\n    if (crosspostedChannels) {\n      if (crosspostedChannels instanceof Collection) {\n        /**\n         * A collection of crossposted channels\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, CrosspostedChannel>}\n         */\n        this.crosspostedChannels = new Collection(crosspostedChannels);\n      } else {\n        this.crosspostedChannels = new Collection();\n        const channelTypes = Object.keys(ChannelTypes);\n        for (const d of crosspostedChannels) {\n          const type = channelTypes[d.type];\n          this.crosspostedChannels.set(d.id, {\n            channelID: d.id,\n            guildID: d.guild_id,\n            type: type ? type.toLowerCase() : 'unknown',\n            name: d.name,\n          });\n        }\n      }\n    } else {\n      this.crosspostedChannels = new Collection();\n    }\n  }\n\n  /**\n   * Any members that were mentioned (only in {@link TextChannel}s)\n   * <info>Order as received from the API, not as they appear in the message content</info>\n   * @type {?Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    if (this._members) return this._members;\n    if (!this.guild) return null;\n    this._members = new Collection();\n    this.users.forEach(user => {\n      const member = this.guild.member(user);\n      if (member) this._members.set(member.user.id, member);\n    });\n    return this._members;\n  }\n\n  /**\n   * Any channels that were mentioned\n   * <info>Order as they appear first in the message content</info>\n   * @type {Collection<Snowflake, GuildChannel>}\n   * @readonly\n   */\n  get channels() {\n    if (this._channels) return this._channels;\n    this._channels = new Collection();\n    let matches;\n    while ((matches = this.constructor.CHANNELS_PATTERN.exec(this._content)) !== null) {\n      const chan = this.client.channels.cache.get(matches[1]);\n      if (chan) this._channels.set(chan.id, chan);\n    }\n    return this._channels;\n  }\n\n  /**\n   * Checks if a user, guild member, role, or channel is mentioned.\n   * Takes into account user mentions, role mentions, and @everyone/@here mentions.\n   * @param {UserResolvable|RoleResolvable|GuildChannelResolvable} data User/Role/Channel to check\n   * @param {Object} [options] Options\n   * @param {boolean} [options.ignoreDirect=false] - Whether to ignore direct mentions to the item\n   * @param {boolean} [options.ignoreRoles=false] - Whether to ignore role mentions to a guild member\n   * @param {boolean} [options.ignoreEveryone=false] - Whether to ignore everyone/here mentions\n   * @returns {boolean}\n   */\n  has(data, { ignoreDirect = false, ignoreRoles = false, ignoreEveryone = false } = {}) {\n    if (!ignoreEveryone && this.everyone) return true;\n    const GuildMember = require('./GuildMember');\n    if (!ignoreRoles && data instanceof GuildMember) {\n      for (const role of this.roles.values()) if (data.roles.cache.has(role.id)) return true;\n    }\n\n    if (!ignoreDirect) {\n      const id =\n        this.client.users.resolveID(data) ||\n        (this.guild && this.guild.roles.resolveID(data)) ||\n        this.client.channels.resolveID(data);\n\n      return this.users.has(id) || this.channels.has(id) || this.roles.has(id);\n    }\n\n    return false;\n  }\n\n  toJSON() {\n    return Util.flatten(this, {\n      members: true,\n      channels: true,\n    });\n  }\n}\n\n/**\n * Regular expression that globally matches `@everyone` and `@here`\n * @type {RegExp}\n */\nMessageMentions.EVERYONE_PATTERN = /@(everyone|here)/g;\n\n/**\n * Regular expression that globally matches user mentions like `<@81440962496172032>`\n * @type {RegExp}\n */\nMessageMentions.USERS_PATTERN = /<@!?(\\d{17,19})>/g;\n\n/**\n * Regular expression that globally matches role mentions like `<@&297577916114403338>`\n * @type {RegExp}\n */\nMessageMentions.ROLES_PATTERN = /<@&(\\d{17,19})>/g;\n\n/**\n * Regular expression that globally matches channel mentions like `<#222079895583457280>`\n * @type {RegExp}\n */\nMessageMentions.CHANNELS_PATTERN = /<#(\\d{17,19})>/g;\n\nmodule.exports = MessageMentions;\n"]},"metadata":{},"sourceType":"script"}