{"ast":null,"code":"'use strict';\n\nconst {\n  browser\n} = require('./util/Constants');\n\nlet erlpack;\n\ntry {\n  erlpack = require('erlpack');\n  if (!erlpack.pack) erlpack = null;\n} catch {} // eslint-disable-line no-empty\n\n\nlet TextDecoder;\n\nif (browser) {\n  TextDecoder = window.TextDecoder; // eslint-disable-line no-undef\n\n  exports.WebSocket = window.WebSocket; // eslint-disable-line no-undef\n} else {\n  TextDecoder = require('util').TextDecoder;\n  exports.WebSocket = require('ws');\n}\n\nconst ab = new TextDecoder();\nexports.encoding = erlpack ? 'etf' : 'json';\nexports.pack = erlpack ? erlpack.pack : JSON.stringify;\n\nexports.unpack = (data, type) => {\n  if (exports.encoding === 'json' || type === 'json') {\n    if (typeof data !== 'string') {\n      data = ab.decode(data);\n    }\n\n    return JSON.parse(data);\n  }\n\n  if (!Buffer.isBuffer(data)) data = Buffer.from(new Uint8Array(data));\n  return erlpack.unpack(data);\n};\n\nexports.create = function (gateway) {\n  let query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const [g, q] = gateway.split('?');\n  query.encoding = exports.encoding;\n  query = new URLSearchParams(query);\n  if (q) new URLSearchParams(q).forEach((v, k) => query.set(k, v));\n\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  const ws = new exports.WebSocket(`${g}?${query}`, ...args);\n  if (browser) ws.binaryType = 'arraybuffer';\n  return ws;\n};\n\nfor (const state of ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED']) exports[state] = exports.WebSocket[state];","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/WebSocket.js"],"names":["browser","require","erlpack","pack","TextDecoder","window","exports","WebSocket","ab","encoding","JSON","stringify","unpack","data","type","decode","parse","Buffer","isBuffer","from","Uint8Array","create","gateway","query","g","q","split","URLSearchParams","forEach","v","k","set","args","ws","binaryType","state"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAcC,OAAO,CAAC,kBAAD,CAA3B;;AAEA,IAAIC,OAAJ;;AAEA,IAAI;AACFA,EAAAA,OAAO,GAAGD,OAAO,CAAC,SAAD,CAAjB;AACA,MAAI,CAACC,OAAO,CAACC,IAAb,EAAmBD,OAAO,GAAG,IAAV;AACpB,CAHD,CAGE,MAAM,CAAE,C,CAAC;;;AAEX,IAAIE,WAAJ;;AAEA,IAAIJ,OAAJ,EAAa;AACXI,EAAAA,WAAW,GAAGC,MAAM,CAACD,WAArB,CADW,CACuB;;AAClCE,EAAAA,OAAO,CAACC,SAAR,GAAoBF,MAAM,CAACE,SAA3B,CAFW,CAE2B;AACvC,CAHD,MAGO;AACLH,EAAAA,WAAW,GAAGH,OAAO,CAAC,MAAD,CAAP,CAAgBG,WAA9B;AACAE,EAAAA,OAAO,CAACC,SAAR,GAAoBN,OAAO,CAAC,IAAD,CAA3B;AACD;;AAED,MAAMO,EAAE,GAAG,IAAIJ,WAAJ,EAAX;AAEAE,OAAO,CAACG,QAAR,GAAmBP,OAAO,GAAG,KAAH,GAAW,MAArC;AAEAI,OAAO,CAACH,IAAR,GAAeD,OAAO,GAAGA,OAAO,CAACC,IAAX,GAAkBO,IAAI,CAACC,SAA7C;;AAEAL,OAAO,CAACM,MAAR,GAAiB,CAACC,IAAD,EAAOC,IAAP,KAAgB;AAC/B,MAAIR,OAAO,CAACG,QAAR,KAAqB,MAArB,IAA+BK,IAAI,KAAK,MAA5C,EAAoD;AAClD,QAAI,OAAOD,IAAP,KAAgB,QAApB,EAA8B;AAC5BA,MAAAA,IAAI,GAAGL,EAAE,CAACO,MAAH,CAAUF,IAAV,CAAP;AACD;;AACD,WAAOH,IAAI,CAACM,KAAL,CAAWH,IAAX,CAAP;AACD;;AACD,MAAI,CAACI,MAAM,CAACC,QAAP,CAAgBL,IAAhB,CAAL,EAA4BA,IAAI,GAAGI,MAAM,CAACE,IAAP,CAAY,IAAIC,UAAJ,CAAeP,IAAf,CAAZ,CAAP;AAC5B,SAAOX,OAAO,CAACU,MAAR,CAAeC,IAAf,CAAP;AACD,CATD;;AAWAP,OAAO,CAACe,MAAR,GAAiB,UAACC,OAAD,EAAkC;AAAA,MAAxBC,KAAwB,uEAAhB,EAAgB;AACjD,QAAM,CAACC,CAAD,EAAIC,CAAJ,IAASH,OAAO,CAACI,KAAR,CAAc,GAAd,CAAf;AACAH,EAAAA,KAAK,CAACd,QAAN,GAAiBH,OAAO,CAACG,QAAzB;AACAc,EAAAA,KAAK,GAAG,IAAII,eAAJ,CAAoBJ,KAApB,CAAR;AACA,MAAIE,CAAJ,EAAO,IAAIE,eAAJ,CAAoBF,CAApB,EAAuBG,OAAvB,CAA+B,CAACC,CAAD,EAAIC,CAAJ,KAAUP,KAAK,CAACQ,GAAN,CAAUD,CAAV,EAAaD,CAAb,CAAzC;;AAJ0C,oCAATG,IAAS;AAATA,IAAAA,IAAS;AAAA;;AAKjD,QAAMC,EAAE,GAAG,IAAI3B,OAAO,CAACC,SAAZ,CAAuB,GAAEiB,CAAE,IAAGD,KAAM,EAApC,EAAuC,GAAGS,IAA1C,CAAX;AACA,MAAIhC,OAAJ,EAAaiC,EAAE,CAACC,UAAH,GAAgB,aAAhB;AACb,SAAOD,EAAP;AACD,CARD;;AAUA,KAAK,MAAME,KAAX,IAAoB,CAAC,YAAD,EAAe,MAAf,EAAuB,SAAvB,EAAkC,QAAlC,CAApB,EAAiE7B,OAAO,CAAC6B,KAAD,CAAP,GAAiB7B,OAAO,CAACC,SAAR,CAAkB4B,KAAlB,CAAjB","sourcesContent":["'use strict';\n\nconst { browser } = require('./util/Constants');\n\nlet erlpack;\n\ntry {\n  erlpack = require('erlpack');\n  if (!erlpack.pack) erlpack = null;\n} catch {} // eslint-disable-line no-empty\n\nlet TextDecoder;\n\nif (browser) {\n  TextDecoder = window.TextDecoder; // eslint-disable-line no-undef\n  exports.WebSocket = window.WebSocket; // eslint-disable-line no-undef\n} else {\n  TextDecoder = require('util').TextDecoder;\n  exports.WebSocket = require('ws');\n}\n\nconst ab = new TextDecoder();\n\nexports.encoding = erlpack ? 'etf' : 'json';\n\nexports.pack = erlpack ? erlpack.pack : JSON.stringify;\n\nexports.unpack = (data, type) => {\n  if (exports.encoding === 'json' || type === 'json') {\n    if (typeof data !== 'string') {\n      data = ab.decode(data);\n    }\n    return JSON.parse(data);\n  }\n  if (!Buffer.isBuffer(data)) data = Buffer.from(new Uint8Array(data));\n  return erlpack.unpack(data);\n};\n\nexports.create = (gateway, query = {}, ...args) => {\n  const [g, q] = gateway.split('?');\n  query.encoding = exports.encoding;\n  query = new URLSearchParams(query);\n  if (q) new URLSearchParams(q).forEach((v, k) => query.set(k, v));\n  const ws = new exports.WebSocket(`${g}?${query}`, ...args);\n  if (browser) ws.binaryType = 'arraybuffer';\n  return ws;\n};\n\nfor (const state of ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED']) exports[state] = exports.WebSocket[state];\n"]},"metadata":{},"sourceType":"script"}