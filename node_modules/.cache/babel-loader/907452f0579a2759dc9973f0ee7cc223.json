{"ast":null,"code":"'use strict';\n\nconst DataResolver = require('../util/DataResolver');\n\nconst Structures = require('../util/Structures');\n/**\n * Represents the logged in client's Discord user.\n * @extends {User}\n */\n\n\nclass ClientUser extends Structures.get('User') {\n  constructor(client, data) {\n    super(client, data);\n    this._typing = new Map();\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if ('verified' in data) {\n      /**\n       * Whether or not this account has been verified\n       * @type {boolean}\n       */\n      this.verified = data.verified;\n    }\n\n    if ('mfa_enabled' in data) {\n      /**\n       * If the bot's {@link ClientApplication#owner Owner} has MFA enabled on their account\n       * @type {?boolean}\n       */\n      this.mfaEnabled = typeof data.mfa_enabled === 'boolean' ? data.mfa_enabled : null;\n    } else if (typeof this.mfaEnabled === 'undefined') {\n      this.mfaEnabled = null;\n    }\n\n    if (data.token) this.client.token = data.token;\n  }\n  /**\n   * ClientUser's presence\n   * @type {Presence}\n   * @readonly\n   */\n\n\n  get presence() {\n    return this.client.presence;\n  }\n\n  edit(data) {\n    return this.client.api.users('@me').patch({\n      data\n    }).then(newData => {\n      this.client.token = newData.token;\n      const {\n        updated\n      } = this.client.actions.UserUpdate.handle(newData);\n      if (updated) return updated;\n      return this;\n    });\n  }\n  /**\n   * Sets the username of the logged in client.\n   * <info>Changing usernames in Discord is heavily rate limited, with only 2 requests\n   * every hour. Use this sparingly!</info>\n   * @param {string} username The new username\n   * @returns {Promise<ClientUser>}\n   * @example\n   * // Set username\n   * client.user.setUsername('discordjs')\n   *   .then(user => console.log(`My new username is ${user.username}`))\n   *   .catch(console.error);\n   */\n\n\n  setUsername(username) {\n    return this.edit({\n      username\n    });\n  }\n  /**\n   * Sets the avatar of the logged in client.\n   * @param {BufferResolvable|Base64Resolvable} avatar The new avatar\n   * @returns {Promise<ClientUser>}\n   * @example\n   * // Set avatar\n   * client.user.setAvatar('./avatar.png')\n   *   .then(user => console.log(`New avatar set!`))\n   *   .catch(console.error);\n   */\n\n\n  async setAvatar(avatar) {\n    return this.edit({\n      avatar: await DataResolver.resolveImage(avatar)\n    });\n  }\n  /**\n   * Data resembling a raw Discord presence.\n   * @typedef {Object} PresenceData\n   * @property {PresenceStatusData} [status] Status of the user\n   * @property {boolean} [afk] Whether the user is AFK\n   * @property {Object} [activity] Activity the user is playing\n   * @property {string} [activity.name] Name of the activity\n   * @property {ActivityType|number} [activity.type] Type of the activity\n   * @property {string} [activity.url] Twitch / YouTube stream URL\n   * @property {?number|number[]} [shardID] Shard Id(s) to have the activity set on\n   */\n\n  /**\n   * Sets the full presence of the client user.\n   * @param {PresenceData} data Data for the presence\n   * @returns {Promise<Presence>}\n   * @example\n   * // Set the client user's presence\n   * client.user.setPresence({ activity: { name: 'with discord.js' }, status: 'idle' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  setPresence(data) {\n    return this.client.presence.set(data);\n  }\n  /**\n   * A user's status. Must be one of:\n   * * `online`\n   * * `idle`\n   * * `invisible`\n   * * `dnd` (do not disturb)\n   * @typedef {string} PresenceStatusData\n   */\n\n  /**\n   * Sets the status of the client user.\n   * @param {PresenceStatusData} status Status to change to\n   * @param {?number|number[]} [shardID] Shard ID(s) to have the activity set on\n   * @returns {Promise<Presence>}\n   * @example\n   * // Set the client user's status\n   * client.user.setStatus('idle')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  setStatus(status, shardID) {\n    return this.setPresence({\n      status,\n      shardID\n    });\n  }\n  /**\n   * Options for setting an activity.\n   * @typedef ActivityOptions\n   * @type {Object}\n   * @property {string} [url] Twitch / YouTube stream URL\n   * @property {ActivityType|number} [type] Type of the activity\n   * @property {?number|number[]} [shardID] Shard Id(s) to have the activity set on\n   */\n\n  /**\n   * Sets the activity the client user is playing.\n   * @param {string|ActivityOptions} [name] Activity being played, or options for setting the activity\n   * @param {ActivityOptions} [options] Options for setting the activity\n   * @returns {Promise<Presence>}\n   * @example\n   * // Set the client user's activity\n   * client.user.setActivity('discord.js', { type: 'WATCHING' })\n   *   .then(presence => console.log(`Activity set to ${presence.activities[0].name}`))\n   *   .catch(console.error);\n   */\n\n\n  setActivity(name) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!name) return this.setPresence({\n      activity: null,\n      shardID: options.shardID\n    });\n    const activity = Object.assign({}, options, typeof name === 'object' ? name : {\n      name\n    });\n    return this.setPresence({\n      activity,\n      shardID: activity.shardID\n    });\n  }\n  /**\n   * Sets/removes the AFK flag for the client user.\n   * @param {boolean} afk Whether or not the user is AFK\n   * @returns {Promise<Presence>}\n   */\n\n\n  setAFK(afk) {\n    return this.setPresence({\n      afk\n    });\n  }\n\n}\n\nmodule.exports = ClientUser;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/structures/ClientUser.js"],"names":["DataResolver","require","Structures","ClientUser","get","constructor","client","data","_typing","Map","_patch","verified","mfaEnabled","mfa_enabled","token","presence","edit","api","users","patch","then","newData","updated","actions","UserUpdate","handle","setUsername","username","setAvatar","avatar","resolveImage","setPresence","set","setStatus","status","shardID","setActivity","name","options","activity","Object","assign","setAFK","afk","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst DataResolver = require('../util/DataResolver');\nconst Structures = require('../util/Structures');\n\n/**\n * Represents the logged in client's Discord user.\n * @extends {User}\n */\nclass ClientUser extends Structures.get('User') {\n  constructor(client, data) {\n    super(client, data);\n    this._typing = new Map();\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if ('verified' in data) {\n      /**\n       * Whether or not this account has been verified\n       * @type {boolean}\n       */\n      this.verified = data.verified;\n    }\n\n    if ('mfa_enabled' in data) {\n      /**\n       * If the bot's {@link ClientApplication#owner Owner} has MFA enabled on their account\n       * @type {?boolean}\n       */\n      this.mfaEnabled = typeof data.mfa_enabled === 'boolean' ? data.mfa_enabled : null;\n    } else if (typeof this.mfaEnabled === 'undefined') {\n      this.mfaEnabled = null;\n    }\n\n    if (data.token) this.client.token = data.token;\n  }\n\n  /**\n   * ClientUser's presence\n   * @type {Presence}\n   * @readonly\n   */\n  get presence() {\n    return this.client.presence;\n  }\n\n  edit(data) {\n    return this.client.api\n      .users('@me')\n      .patch({ data })\n      .then(newData => {\n        this.client.token = newData.token;\n        const { updated } = this.client.actions.UserUpdate.handle(newData);\n        if (updated) return updated;\n        return this;\n      });\n  }\n\n  /**\n   * Sets the username of the logged in client.\n   * <info>Changing usernames in Discord is heavily rate limited, with only 2 requests\n   * every hour. Use this sparingly!</info>\n   * @param {string} username The new username\n   * @returns {Promise<ClientUser>}\n   * @example\n   * // Set username\n   * client.user.setUsername('discordjs')\n   *   .then(user => console.log(`My new username is ${user.username}`))\n   *   .catch(console.error);\n   */\n  setUsername(username) {\n    return this.edit({ username });\n  }\n\n  /**\n   * Sets the avatar of the logged in client.\n   * @param {BufferResolvable|Base64Resolvable} avatar The new avatar\n   * @returns {Promise<ClientUser>}\n   * @example\n   * // Set avatar\n   * client.user.setAvatar('./avatar.png')\n   *   .then(user => console.log(`New avatar set!`))\n   *   .catch(console.error);\n   */\n  async setAvatar(avatar) {\n    return this.edit({ avatar: await DataResolver.resolveImage(avatar) });\n  }\n\n  /**\n   * Data resembling a raw Discord presence.\n   * @typedef {Object} PresenceData\n   * @property {PresenceStatusData} [status] Status of the user\n   * @property {boolean} [afk] Whether the user is AFK\n   * @property {Object} [activity] Activity the user is playing\n   * @property {string} [activity.name] Name of the activity\n   * @property {ActivityType|number} [activity.type] Type of the activity\n   * @property {string} [activity.url] Twitch / YouTube stream URL\n   * @property {?number|number[]} [shardID] Shard Id(s) to have the activity set on\n   */\n\n  /**\n   * Sets the full presence of the client user.\n   * @param {PresenceData} data Data for the presence\n   * @returns {Promise<Presence>}\n   * @example\n   * // Set the client user's presence\n   * client.user.setPresence({ activity: { name: 'with discord.js' }, status: 'idle' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  setPresence(data) {\n    return this.client.presence.set(data);\n  }\n\n  /**\n   * A user's status. Must be one of:\n   * * `online`\n   * * `idle`\n   * * `invisible`\n   * * `dnd` (do not disturb)\n   * @typedef {string} PresenceStatusData\n   */\n\n  /**\n   * Sets the status of the client user.\n   * @param {PresenceStatusData} status Status to change to\n   * @param {?number|number[]} [shardID] Shard ID(s) to have the activity set on\n   * @returns {Promise<Presence>}\n   * @example\n   * // Set the client user's status\n   * client.user.setStatus('idle')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  setStatus(status, shardID) {\n    return this.setPresence({ status, shardID });\n  }\n\n  /**\n   * Options for setting an activity.\n   * @typedef ActivityOptions\n   * @type {Object}\n   * @property {string} [url] Twitch / YouTube stream URL\n   * @property {ActivityType|number} [type] Type of the activity\n   * @property {?number|number[]} [shardID] Shard Id(s) to have the activity set on\n   */\n\n  /**\n   * Sets the activity the client user is playing.\n   * @param {string|ActivityOptions} [name] Activity being played, or options for setting the activity\n   * @param {ActivityOptions} [options] Options for setting the activity\n   * @returns {Promise<Presence>}\n   * @example\n   * // Set the client user's activity\n   * client.user.setActivity('discord.js', { type: 'WATCHING' })\n   *   .then(presence => console.log(`Activity set to ${presence.activities[0].name}`))\n   *   .catch(console.error);\n   */\n  setActivity(name, options = {}) {\n    if (!name) return this.setPresence({ activity: null, shardID: options.shardID });\n\n    const activity = Object.assign({}, options, typeof name === 'object' ? name : { name });\n    return this.setPresence({ activity, shardID: activity.shardID });\n  }\n\n  /**\n   * Sets/removes the AFK flag for the client user.\n   * @param {boolean} afk Whether or not the user is AFK\n   * @returns {Promise<Presence>}\n   */\n  setAFK(afk) {\n    return this.setPresence({ afk });\n  }\n}\n\nmodule.exports = ClientUser;\n"]},"metadata":{},"sourceType":"script"}