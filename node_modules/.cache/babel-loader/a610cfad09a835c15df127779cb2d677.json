{"ast":null,"code":"'use strict';\n\nconst Base = require('./Base');\n\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\n\nconst {\n  Error\n} = require('../errors');\n\nconst Snowflake = require('../util/Snowflake');\n\nconst UserFlags = require('../util/UserFlags');\n\nlet Structures;\n/**\n * Represents a user on Discord.\n * @implements {TextBasedChannel}\n * @extends {Base}\n */\n\nclass User extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the user\n   */\n  constructor(client, data) {\n    super(client);\n    /**\n     * The ID of the user\n     * @type {Snowflake}\n     */\n\n    this.id = data.id;\n    this.system = null;\n    this.locale = null;\n    this.flags = null;\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    if ('username' in data) {\n      /**\n       * The username of the user\n       * @type {?string}\n       */\n      this.username = data.username;\n    } else if (typeof this.username !== 'string') {\n      this.username = null;\n    }\n\n    if ('bot' in data || typeof this.bot !== 'boolean') {\n      /**\n       * Whether or not the user is a bot\n       * @type {boolean}\n       */\n      this.bot = Boolean(data.bot);\n    }\n\n    if ('discriminator' in data) {\n      /**\n       * A discriminator based on username for the user\n       * @type {?string}\n       */\n      this.discriminator = data.discriminator;\n    } else if (typeof this.discriminator !== 'string') {\n      this.discriminator = null;\n    }\n\n    if ('avatar' in data) {\n      /**\n       * The ID of the user's avatar\n       * @type {?string}\n       */\n      this.avatar = data.avatar;\n    } else if (typeof this.avatar !== 'string') {\n      this.avatar = null;\n    }\n\n    if ('system' in data) {\n      /**\n       * Whether the user is an Official Discord System user (part of the urgent message system)\n       * @type {?boolean}\n       */\n      this.system = Boolean(data.system);\n    }\n\n    if ('locale' in data) {\n      /**\n       * The locale of the user's client (ISO 639-1)\n       * @type {?string}\n       */\n      this.locale = data.locale;\n    }\n\n    if ('public_flags' in data) {\n      /**\n       * The flags for this user\n       * @type {?UserFlags}\n       */\n      this.flags = new UserFlags(data.public_flags);\n    }\n    /**\n     * The ID of the last message sent by the user, if one was sent\n     * @type {?Snowflake}\n     */\n\n\n    this.lastMessageID = null;\n    /**\n     * The ID of the channel for the last message sent by the user, if one was sent\n     * @type {?Snowflake}\n     */\n\n    this.lastMessageChannelID = null;\n  }\n  /**\n   * Whether this User is a partial\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get partial() {\n    return typeof this.username !== 'string';\n  }\n  /**\n   * The timestamp the user was created at\n   * @type {number}\n   * @readonly\n   */\n\n\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n  /**\n   * The time the user was created at\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * The Message object of the last message sent by the user, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n\n\n  get lastMessage() {\n    const channel = this.client.channels.cache.get(this.lastMessageChannelID);\n    return channel && channel.messages.cache.get(this.lastMessageID) || null;\n  }\n  /**\n   * The presence of this user\n   * @type {Presence}\n   * @readonly\n   */\n\n\n  get presence() {\n    for (const guild of this.client.guilds.cache.values()) {\n      if (guild.presences.cache.has(this.id)) return guild.presences.cache.get(this.id);\n    }\n\n    if (!Structures) Structures = require('../util/Structures');\n    const Presence = Structures.get('Presence');\n    return new Presence(this.client, {\n      user: {\n        id: this.id\n      }\n    });\n  }\n  /**\n   * A link to the user's avatar.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n\n\n  avatarURL() {\n    let {\n      format,\n      size,\n      dynamic\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.avatar) return null;\n    return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size, dynamic);\n  }\n  /**\n   * A link to the user's default avatar\n   * @type {string}\n   * @readonly\n   */\n\n\n  get defaultAvatarURL() {\n    return this.client.rest.cdn.DefaultAvatar(this.discriminator % 5);\n  }\n  /**\n   * A link to the user's avatar if they have one.\n   * Otherwise a link to their default avatar will be returned.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {string}\n   */\n\n\n  displayAvatarURL(options) {\n    return this.avatarURL(options) || this.defaultAvatarURL;\n  }\n  /**\n   * The Discord \"tag\" (e.g. `hydrabolt#0001`) for this user\n   * @type {?string}\n   * @readonly\n   */\n\n\n  get tag() {\n    return typeof this.username === 'string' ? `${this.username}#${this.discriminator}` : null;\n  }\n  /**\n   * Checks whether the user is typing in a channel.\n   * @param {ChannelResolvable} channel The channel to check in\n   * @returns {boolean}\n   */\n\n\n  typingIn(channel) {\n    channel = this.client.channels.resolve(channel);\n    return channel._typing.has(this.id);\n  }\n  /**\n   * Gets the time that the user started typing.\n   * @param {ChannelResolvable} channel The channel to get the time in\n   * @returns {?Date}\n   */\n\n\n  typingSinceIn(channel) {\n    channel = this.client.channels.resolve(channel);\n    return channel._typing.has(this.id) ? new Date(channel._typing.get(this.id).since) : null;\n  }\n  /**\n   * Gets the amount of time the user has been typing in a channel for (in milliseconds), or -1 if they're not typing.\n   * @param {ChannelResolvable} channel The channel to get the time in\n   * @returns {number}\n   */\n\n\n  typingDurationIn(channel) {\n    channel = this.client.channels.resolve(channel);\n    return channel._typing.has(this.id) ? channel._typing.get(this.id).elapsedTime : -1;\n  }\n  /**\n   * The DM between the client's user and this user\n   * @type {?DMChannel}\n   * @readonly\n   */\n\n\n  get dmChannel() {\n    return this.client.channels.cache.find(c => c.type === 'dm' && c.recipient.id === this.id) || null;\n  }\n  /**\n   * Creates a DM channel between the client and the user.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<DMChannel>}\n   */\n\n\n  async createDM() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (!force) {\n      const {\n        dmChannel\n      } = this;\n      if (dmChannel && !dmChannel.partial) return dmChannel;\n    }\n\n    const data = await this.client.api.users(this.client.user.id).channels.post({\n      data: {\n        recipient_id: this.id\n      }\n    });\n    return this.client.actions.ChannelCreate.handle(data).channel;\n  }\n  /**\n   * Deletes a DM channel (if one exists) between the client and the user. Resolves with the channel if successful.\n   * @returns {Promise<DMChannel>}\n   */\n\n\n  async deleteDM() {\n    const {\n      dmChannel\n    } = this;\n    if (!dmChannel) throw new Error('USER_NO_DMCHANNEL');\n    const data = await this.client.api.channels(dmChannel.id).delete();\n    return this.client.actions.ChannelDelete.handle(data).channel;\n  }\n  /**\n   * Checks if the user is equal to another. It compares ID, username, discriminator, avatar, and bot flags.\n   * It is recommended to compare equality by using `user.id === user2.id` unless you want to compare all properties.\n   * @param {User} user User to compare with\n   * @returns {boolean}\n   */\n\n\n  equals(user) {\n    let equal = user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.avatar === user.avatar;\n    return equal;\n  }\n  /**\n   * Fetches this user's flags.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the AP\n   * @returns {Promise<UserFlags>}\n   */\n\n\n  async fetchFlags() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.flags && !force) return this.flags;\n    const data = await this.client.api.users(this.id).get();\n\n    this._patch(data);\n\n    return this.flags;\n  }\n  /**\n   * Fetches this user.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the AP\n   * @returns {Promise<User>}\n   */\n\n\n  fetch() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this.client.users.fetch(this.id, true, force);\n  }\n  /**\n   * When concatenated with a string, this automatically returns the user's mention instead of the User object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789012345678>!\n   * console.log(`Hello from ${user}!`);\n   */\n\n\n  toString() {\n    return `<@${this.id}>`;\n  }\n\n  toJSON() {\n    for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n      props[_key] = arguments[_key];\n    }\n\n    const json = super.toJSON({\n      createdTimestamp: true,\n      defaultAvatarURL: true,\n      tag: true,\n      lastMessage: false,\n      lastMessageID: false\n    }, ...props);\n    json.avatarURL = this.avatarURL();\n    json.displayAvatarURL = this.displayAvatarURL();\n    return json;\n  } // These are here only for documentation purposes - they are implemented by TextBasedChannel\n\n  /* eslint-disable no-empty-function */\n\n\n  send() {}\n\n}\n\nTextBasedChannel.applyToClass(User);\nmodule.exports = User;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/structures/User.js"],"names":["Base","require","TextBasedChannel","Error","Snowflake","UserFlags","Structures","User","constructor","client","data","id","system","locale","flags","_patch","username","bot","Boolean","discriminator","avatar","public_flags","lastMessageID","lastMessageChannelID","partial","createdTimestamp","deconstruct","timestamp","createdAt","Date","lastMessage","channel","channels","cache","get","messages","presence","guild","guilds","values","presences","has","Presence","user","avatarURL","format","size","dynamic","rest","cdn","Avatar","defaultAvatarURL","DefaultAvatar","displayAvatarURL","options","tag","typingIn","resolve","_typing","typingSinceIn","since","typingDurationIn","elapsedTime","dmChannel","find","c","type","recipient","createDM","force","api","users","post","recipient_id","actions","ChannelCreate","handle","deleteDM","delete","ChannelDelete","equals","equal","fetchFlags","fetch","toString","toJSON","props","json","send","applyToClass","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Base = require('./Base');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst { Error } = require('../errors');\nconst Snowflake = require('../util/Snowflake');\nconst UserFlags = require('../util/UserFlags');\n\nlet Structures;\n\n/**\n * Represents a user on Discord.\n * @implements {TextBasedChannel}\n * @extends {Base}\n */\nclass User extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the user\n   */\n  constructor(client, data) {\n    super(client);\n\n    /**\n     * The ID of the user\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    this.system = null;\n    this.locale = null;\n    this.flags = null;\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    if ('username' in data) {\n      /**\n       * The username of the user\n       * @type {?string}\n       */\n      this.username = data.username;\n    } else if (typeof this.username !== 'string') {\n      this.username = null;\n    }\n\n    if ('bot' in data || typeof this.bot !== 'boolean') {\n      /**\n       * Whether or not the user is a bot\n       * @type {boolean}\n       */\n      this.bot = Boolean(data.bot);\n    }\n\n    if ('discriminator' in data) {\n      /**\n       * A discriminator based on username for the user\n       * @type {?string}\n       */\n      this.discriminator = data.discriminator;\n    } else if (typeof this.discriminator !== 'string') {\n      this.discriminator = null;\n    }\n\n    if ('avatar' in data) {\n      /**\n       * The ID of the user's avatar\n       * @type {?string}\n       */\n      this.avatar = data.avatar;\n    } else if (typeof this.avatar !== 'string') {\n      this.avatar = null;\n    }\n\n    if ('system' in data) {\n      /**\n       * Whether the user is an Official Discord System user (part of the urgent message system)\n       * @type {?boolean}\n       */\n      this.system = Boolean(data.system);\n    }\n\n    if ('locale' in data) {\n      /**\n       * The locale of the user's client (ISO 639-1)\n       * @type {?string}\n       */\n      this.locale = data.locale;\n    }\n\n    if ('public_flags' in data) {\n      /**\n       * The flags for this user\n       * @type {?UserFlags}\n       */\n      this.flags = new UserFlags(data.public_flags);\n    }\n\n    /**\n     * The ID of the last message sent by the user, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageID = null;\n\n    /**\n     * The ID of the channel for the last message sent by the user, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageChannelID = null;\n  }\n\n  /**\n   * Whether this User is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return typeof this.username !== 'string';\n  }\n\n  /**\n   * The timestamp the user was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n\n  /**\n   * The time the user was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The Message object of the last message sent by the user, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n  get lastMessage() {\n    const channel = this.client.channels.cache.get(this.lastMessageChannelID);\n    return (channel && channel.messages.cache.get(this.lastMessageID)) || null;\n  }\n\n  /**\n   * The presence of this user\n   * @type {Presence}\n   * @readonly\n   */\n  get presence() {\n    for (const guild of this.client.guilds.cache.values()) {\n      if (guild.presences.cache.has(this.id)) return guild.presences.cache.get(this.id);\n    }\n    if (!Structures) Structures = require('../util/Structures');\n    const Presence = Structures.get('Presence');\n    return new Presence(this.client, { user: { id: this.id } });\n  }\n\n  /**\n   * A link to the user's avatar.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n  avatarURL({ format, size, dynamic } = {}) {\n    if (!this.avatar) return null;\n    return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size, dynamic);\n  }\n\n  /**\n   * A link to the user's default avatar\n   * @type {string}\n   * @readonly\n   */\n  get defaultAvatarURL() {\n    return this.client.rest.cdn.DefaultAvatar(this.discriminator % 5);\n  }\n\n  /**\n   * A link to the user's avatar if they have one.\n   * Otherwise a link to their default avatar will be returned.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {string}\n   */\n  displayAvatarURL(options) {\n    return this.avatarURL(options) || this.defaultAvatarURL;\n  }\n\n  /**\n   * The Discord \"tag\" (e.g. `hydrabolt#0001`) for this user\n   * @type {?string}\n   * @readonly\n   */\n  get tag() {\n    return typeof this.username === 'string' ? `${this.username}#${this.discriminator}` : null;\n  }\n\n  /**\n   * Checks whether the user is typing in a channel.\n   * @param {ChannelResolvable} channel The channel to check in\n   * @returns {boolean}\n   */\n  typingIn(channel) {\n    channel = this.client.channels.resolve(channel);\n    return channel._typing.has(this.id);\n  }\n\n  /**\n   * Gets the time that the user started typing.\n   * @param {ChannelResolvable} channel The channel to get the time in\n   * @returns {?Date}\n   */\n  typingSinceIn(channel) {\n    channel = this.client.channels.resolve(channel);\n    return channel._typing.has(this.id) ? new Date(channel._typing.get(this.id).since) : null;\n  }\n\n  /**\n   * Gets the amount of time the user has been typing in a channel for (in milliseconds), or -1 if they're not typing.\n   * @param {ChannelResolvable} channel The channel to get the time in\n   * @returns {number}\n   */\n  typingDurationIn(channel) {\n    channel = this.client.channels.resolve(channel);\n    return channel._typing.has(this.id) ? channel._typing.get(this.id).elapsedTime : -1;\n  }\n\n  /**\n   * The DM between the client's user and this user\n   * @type {?DMChannel}\n   * @readonly\n   */\n  get dmChannel() {\n    return this.client.channels.cache.find(c => c.type === 'dm' && c.recipient.id === this.id) || null;\n  }\n\n  /**\n   * Creates a DM channel between the client and the user.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<DMChannel>}\n   */\n  async createDM(force = false) {\n    if (!force) {\n      const { dmChannel } = this;\n      if (dmChannel && !dmChannel.partial) return dmChannel;\n    }\n\n    const data = await this.client.api.users(this.client.user.id).channels.post({\n      data: {\n        recipient_id: this.id,\n      },\n    });\n    return this.client.actions.ChannelCreate.handle(data).channel;\n  }\n\n  /**\n   * Deletes a DM channel (if one exists) between the client and the user. Resolves with the channel if successful.\n   * @returns {Promise<DMChannel>}\n   */\n  async deleteDM() {\n    const { dmChannel } = this;\n    if (!dmChannel) throw new Error('USER_NO_DMCHANNEL');\n    const data = await this.client.api.channels(dmChannel.id).delete();\n    return this.client.actions.ChannelDelete.handle(data).channel;\n  }\n\n  /**\n   * Checks if the user is equal to another. It compares ID, username, discriminator, avatar, and bot flags.\n   * It is recommended to compare equality by using `user.id === user2.id` unless you want to compare all properties.\n   * @param {User} user User to compare with\n   * @returns {boolean}\n   */\n  equals(user) {\n    let equal =\n      user &&\n      this.id === user.id &&\n      this.username === user.username &&\n      this.discriminator === user.discriminator &&\n      this.avatar === user.avatar;\n\n    return equal;\n  }\n\n  /**\n   * Fetches this user's flags.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the AP\n   * @returns {Promise<UserFlags>}\n   */\n  async fetchFlags(force = false) {\n    if (this.flags && !force) return this.flags;\n    const data = await this.client.api.users(this.id).get();\n    this._patch(data);\n    return this.flags;\n  }\n\n  /**\n   * Fetches this user.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the AP\n   * @returns {Promise<User>}\n   */\n  fetch(force = false) {\n    return this.client.users.fetch(this.id, true, force);\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the user's mention instead of the User object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789012345678>!\n   * console.log(`Hello from ${user}!`);\n   */\n  toString() {\n    return `<@${this.id}>`;\n  }\n\n  toJSON(...props) {\n    const json = super.toJSON(\n      {\n        createdTimestamp: true,\n        defaultAvatarURL: true,\n        tag: true,\n        lastMessage: false,\n        lastMessageID: false,\n      },\n      ...props,\n    );\n    json.avatarURL = this.avatarURL();\n    json.displayAvatarURL = this.displayAvatarURL();\n    return json;\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  send() {}\n}\n\nTextBasedChannel.applyToClass(User);\n\nmodule.exports = User;\n"]},"metadata":{},"sourceType":"script"}