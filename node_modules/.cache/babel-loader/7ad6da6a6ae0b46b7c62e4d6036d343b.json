{"ast":null,"code":"'use strict';\n\nconst Channel = require('./Channel');\n\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\n\nconst MessageManager = require('../managers/MessageManager');\n/**\n * Represents a direct message channel between two users.\n * @extends {Channel}\n * @implements {TextBasedChannel}\n */\n\n\nclass DMChannel extends Channel {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the DM channel\n   */\n  constructor(client, data) {\n    super(client, data); // Override the channel type so partials have a known type\n\n    this.type = 'dm';\n    /**\n     * A manager of the messages belonging to this channel\n     * @type {MessageManager}\n     */\n\n    this.messages = new MessageManager(this);\n    this._typing = new Map();\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if (data.recipients) {\n      /**\n       * The recipient on the other end of the DM\n       * @type {User}\n       */\n      this.recipient = this.client.users.add(data.recipients[0]);\n    }\n    /**\n     * The ID of the last message in the channel, if one was sent\n     * @type {?Snowflake}\n     */\n\n\n    this.lastMessageID = data.last_message_id;\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n\n    this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;\n  }\n  /**\n   * Whether this DMChannel is a partial\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get partial() {\n    return typeof this.lastMessageID === 'undefined';\n  }\n  /**\n   * Fetch this DMChannel.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<DMChannel>}\n   */\n\n\n  fetch() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this.recipient.createDM(force);\n  }\n  /**\n   * When concatenated with a string, this automatically returns the recipient's mention instead of the\n   * DMChannel object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789012345678>!\n   * console.log(`Hello from ${channel}!`);\n   */\n\n\n  toString() {\n    return this.recipient.toString();\n  } // These are here only for documentation purposes - they are implemented by TextBasedChannel\n\n  /* eslint-disable no-empty-function */\n\n\n  get lastMessage() {}\n\n  get lastPinAt() {}\n\n  send() {}\n\n  startTyping() {}\n\n  stopTyping() {}\n\n  get typing() {}\n\n  get typingCount() {}\n\n  createMessageCollector() {}\n\n  awaitMessages() {} // Doesn't work on DM channels; bulkDelete() {}\n\n\n}\n\nTextBasedChannel.applyToClass(DMChannel, true, ['bulkDelete']);\nmodule.exports = DMChannel;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/structures/DMChannel.js"],"names":["Channel","require","TextBasedChannel","MessageManager","DMChannel","constructor","client","data","type","messages","_typing","Map","_patch","recipients","recipient","users","add","lastMessageID","last_message_id","lastPinTimestamp","last_pin_timestamp","Date","getTime","partial","fetch","force","createDM","toString","lastMessage","lastPinAt","send","startTyping","stopTyping","typing","typingCount","createMessageCollector","awaitMessages","applyToClass","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,+BAAD,CAAhC;;AACA,MAAME,cAAc,GAAGF,OAAO,CAAC,4BAAD,CAA9B;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAMG,SAAN,SAAwBJ,OAAxB,CAAgC;AAC9B;AACF;AACA;AACA;AACEK,EAAAA,WAAW,CAACC,MAAD,EAASC,IAAT,EAAe;AACxB,UAAMD,MAAN,EAAcC,IAAd,EADwB,CAExB;;AACA,SAAKC,IAAL,GAAY,IAAZ;AACA;AACJ;AACA;AACA;;AACI,SAAKC,QAAL,GAAgB,IAAIN,cAAJ,CAAmB,IAAnB,CAAhB;AACA,SAAKO,OAAL,GAAe,IAAIC,GAAJ,EAAf;AACD;;AAEDC,EAAAA,MAAM,CAACL,IAAD,EAAO;AACX,UAAMK,MAAN,CAAaL,IAAb;;AAEA,QAAIA,IAAI,CAACM,UAAT,EAAqB;AACnB;AACN;AACA;AACA;AACM,WAAKC,SAAL,GAAiB,KAAKR,MAAL,CAAYS,KAAZ,CAAkBC,GAAlB,CAAsBT,IAAI,CAACM,UAAL,CAAgB,CAAhB,CAAtB,CAAjB;AACD;AAED;AACJ;AACA;AACA;;;AACI,SAAKI,aAAL,GAAqBV,IAAI,CAACW,eAA1B;AAEA;AACJ;AACA;AACA;;AACI,SAAKC,gBAAL,GAAwBZ,IAAI,CAACa,kBAAL,GAA0B,IAAIC,IAAJ,CAASd,IAAI,CAACa,kBAAd,EAAkCE,OAAlC,EAA1B,GAAwE,IAAhG;AACD;AAED;AACF;AACA;AACA;AACA;;;AACa,MAAPC,OAAO,GAAG;AACZ,WAAO,OAAO,KAAKN,aAAZ,KAA8B,WAArC;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEO,EAAAA,KAAK,GAAgB;AAAA,QAAfC,KAAe,uEAAP,KAAO;AACnB,WAAO,KAAKX,SAAL,CAAeY,QAAf,CAAwBD,KAAxB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEE,EAAAA,QAAQ,GAAG;AACT,WAAO,KAAKb,SAAL,CAAea,QAAf,EAAP;AACD,GArE6B,CAuE9B;;AACA;;;AACe,MAAXC,WAAW,GAAG,CAAE;;AACP,MAATC,SAAS,GAAG,CAAE;;AAClBC,EAAAA,IAAI,GAAG,CAAE;;AACTC,EAAAA,WAAW,GAAG,CAAE;;AAChBC,EAAAA,UAAU,GAAG,CAAE;;AACL,MAANC,MAAM,GAAG,CAAE;;AACA,MAAXC,WAAW,GAAG,CAAE;;AACpBC,EAAAA,sBAAsB,GAAG,CAAE;;AAC3BC,EAAAA,aAAa,GAAG,CAAE,CAjFY,CAkF9B;;;AAlF8B;;AAqFhClC,gBAAgB,CAACmC,YAAjB,CAA8BjC,SAA9B,EAAyC,IAAzC,EAA+C,CAAC,YAAD,CAA/C;AAEAkC,MAAM,CAACC,OAAP,GAAiBnC,SAAjB","sourcesContent":["'use strict';\n\nconst Channel = require('./Channel');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst MessageManager = require('../managers/MessageManager');\n\n/**\n * Represents a direct message channel between two users.\n * @extends {Channel}\n * @implements {TextBasedChannel}\n */\nclass DMChannel extends Channel {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the DM channel\n   */\n  constructor(client, data) {\n    super(client, data);\n    // Override the channel type so partials have a known type\n    this.type = 'dm';\n    /**\n     * A manager of the messages belonging to this channel\n     * @type {MessageManager}\n     */\n    this.messages = new MessageManager(this);\n    this._typing = new Map();\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if (data.recipients) {\n      /**\n       * The recipient on the other end of the DM\n       * @type {User}\n       */\n      this.recipient = this.client.users.add(data.recipients[0]);\n    }\n\n    /**\n     * The ID of the last message in the channel, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageID = data.last_message_id;\n\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n    this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;\n  }\n\n  /**\n   * Whether this DMChannel is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return typeof this.lastMessageID === 'undefined';\n  }\n\n  /**\n   * Fetch this DMChannel.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<DMChannel>}\n   */\n  fetch(force = false) {\n    return this.recipient.createDM(force);\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the recipient's mention instead of the\n   * DMChannel object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789012345678>!\n   * console.log(`Hello from ${channel}!`);\n   */\n  toString() {\n    return this.recipient.toString();\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  get lastMessage() {}\n  get lastPinAt() {}\n  send() {}\n  startTyping() {}\n  stopTyping() {}\n  get typing() {}\n  get typingCount() {}\n  createMessageCollector() {}\n  awaitMessages() {}\n  // Doesn't work on DM channels; bulkDelete() {}\n}\n\nTextBasedChannel.applyToClass(DMChannel, true, ['bulkDelete']);\n\nmodule.exports = DMChannel;\n"]},"metadata":{},"sourceType":"script"}