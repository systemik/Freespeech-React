{"ast":null,"code":"'use strict';\n\nconst BaseManager = require('./BaseManager');\n\nconst Guild = require('../structures/Guild');\n\nconst GuildChannel = require('../structures/GuildChannel');\n\nconst GuildEmoji = require('../structures/GuildEmoji');\n\nconst GuildMember = require('../structures/GuildMember');\n\nconst Invite = require('../structures/Invite');\n\nconst Role = require('../structures/Role');\n\nconst {\n  ChannelTypes,\n  Events,\n  VerificationLevels,\n  DefaultMessageNotifications,\n  ExplicitContentFilterLevels\n} = require('../util/Constants');\n\nconst DataResolver = require('../util/DataResolver');\n\nconst Permissions = require('../util/Permissions');\n\nconst {\n  resolveColor\n} = require('../util/Util');\n/**\n * Manages API methods for Guilds and stores their cache.\n * @extends {BaseManager}\n */\n\n\nclass GuildManager extends BaseManager {\n  constructor(client, iterable) {\n    super(client, iterable, Guild);\n  }\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, Guild>}\n   * @name GuildManager#cache\n   */\n\n  /**\n   * Data that resolves to give a Guild object. This can be:\n   * * A Guild object\n   * * A GuildChannel object\n   * * A GuildEmoji object\n   * * A Role object\n   * * A Snowflake\n   * * An Invite object\n   * @typedef {Guild|GuildChannel|GuildMember|GuildEmoji|Role|Snowflake|Invite} GuildResolvable\n   */\n\n  /**\n   * Partial data for a Role.\n   * @typedef {Object} PartialRoleData\n   * @property {number} [id] The ID for this role, used to set channel overrides,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable|number} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   */\n\n  /**\n   * Partial overwrite data.\n   * @typedef {Object} PartialOverwriteData\n   * @property {number|Snowflake} id The Role or User ID for this overwrite\n   * @property {string} [type] The type of this overwrite\n   * @property {PermissionResolvable} [allow] The permissions to allow\n   * @property {PermissionResolvable} [deny] The permissions to deny\n   */\n\n  /**\n   * Partial data for a Channel.\n   * @typedef {Object} PartialChannelData\n   * @property {number} [id] The ID for this channel, used to set its parent,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {number} [parentID] The parent ID for this channel\n   * @property {string} [type] The type of the channel\n   * @property {string} name The name of the channel\n   * @property {string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the channel\n   * @property {PartialOverwriteData} [permissionOverwrites]\n   * Overwrites of the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user of the channel in seconds\n   */\n\n  /**\n   * Resolves a GuildResolvable to a Guild object.\n   * @method resolve\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Guild}\n   */\n\n\n  resolve(guild) {\n    if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {\n      return super.resolve(guild.guild);\n    }\n\n    return super.resolve(guild);\n  }\n  /**\n   * Resolves a GuildResolvable to a Guild ID string.\n   * @method resolveID\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Snowflake}\n   */\n\n\n  resolveID(guild) {\n    if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {\n      return super.resolveID(guild.guild.id);\n    }\n\n    return super.resolveID(guild);\n  }\n  /**\n   * Creates a guild.\n   * <warn>This is only available to bots in fewer than 10 guilds.</warn>\n   * @param {string} name The name of the guild\n   * @param {Object} [options] Options for the creating\n   * @param {number} [options.afkChannelID] The ID of the AFK channel\n   * @param {number} [options.afkTimeout] The AFK timeout in seconds\n   * @param {PartialChannelData[]} [options.channels] The channels for this guild\n   * @param {DefaultMessageNotifications} [options.defaultMessageNotifications] The default message notifications\n   * for the guild\n   * @param {ExplicitContentFilterLevel} [options.explicitContentFilter] The explicit content filter level for the guild\n   * @param {BufferResolvable|Base64Resolvable} [options.icon=null] The icon for the guild\n   * @param {string} [options.region] The region for the server, defaults to the closest one available\n   * @param {PartialRoleData[]} [options.roles] The roles for this guild,\n   * the first element of this array is used to change properties of the guild's everyone role.\n   * @param {number} [options.systemChannelID] The ID of the system channel\n   * @param {VerificationLevel} [options.verificationLevel] The verification level for the guild\n   * @returns {Promise<Guild>} The guild that was created\n   */\n\n\n  async create(name) {\n    let {\n      afkChannelID,\n      afkTimeout,\n      channels = [],\n      defaultMessageNotifications,\n      explicitContentFilter,\n      icon = null,\n      region,\n      roles = [],\n      systemChannelID,\n      verificationLevel\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    icon = await DataResolver.resolveImage(icon);\n\n    if (typeof verificationLevel !== 'undefined' && typeof verificationLevel !== 'number') {\n      verificationLevel = VerificationLevels.indexOf(verificationLevel);\n    }\n\n    if (typeof defaultMessageNotifications !== 'undefined' && typeof defaultMessageNotifications !== 'number') {\n      defaultMessageNotifications = DefaultMessageNotifications.indexOf(defaultMessageNotifications);\n    }\n\n    if (typeof explicitContentFilter !== 'undefined' && typeof explicitContentFilter !== 'number') {\n      explicitContentFilter = ExplicitContentFilterLevels.indexOf(explicitContentFilter);\n    }\n\n    for (const channel of channels) {\n      if (channel.type) channel.type = ChannelTypes[channel.type.toUpperCase()];\n      channel.parent_id = channel.parentID;\n      delete channel.parentID;\n      if (!channel.permissionOverwrites) continue;\n\n      for (const overwrite of channel.permissionOverwrites) {\n        if (overwrite.allow) overwrite.allow = Permissions.resolve(overwrite.allow);\n        if (overwrite.deny) overwrite.deny = Permissions.resolve(overwrite.deny);\n      }\n\n      channel.permission_overwrites = channel.permissionOverwrites;\n      delete channel.permissionOverwrites;\n    }\n\n    for (const role of roles) {\n      if (role.color) role.color = resolveColor(role.color);\n      if (role.permissions) role.permissions = Permissions.resolve(role.permissions);\n    }\n\n    return new Promise((resolve, reject) => this.client.api.guilds.post({\n      data: {\n        name,\n        region,\n        icon,\n        verification_level: verificationLevel,\n        default_message_notifications: defaultMessageNotifications,\n        explicit_content_filter: explicitContentFilter,\n        roles,\n        channels,\n        afk_channel_id: afkChannelID,\n        afk_timeout: afkTimeout,\n        system_channel_id: systemChannelID\n      }\n    }).then(data => {\n      if (this.client.guilds.cache.has(data.id)) return resolve(this.client.guilds.cache.get(data.id));\n\n      const handleGuild = guild => {\n        if (guild.id === data.id) {\n          this.client.clearTimeout(timeout);\n          this.client.removeListener(Events.GUILD_CREATE, handleGuild);\n          this.client.decrementMaxListeners();\n          resolve(guild);\n        }\n      };\n\n      this.client.incrementMaxListeners();\n      this.client.on(Events.GUILD_CREATE, handleGuild);\n      const timeout = this.client.setTimeout(() => {\n        this.client.removeListener(Events.GUILD_CREATE, handleGuild);\n        this.client.decrementMaxListeners();\n        resolve(this.client.guilds.add(data));\n      }, 10000);\n      return undefined;\n    }, reject));\n  }\n  /**\n   * Obtains a guild from Discord, or the guild cache if it's already available.\n   * @param {Snowflake} id ID of the guild\n   * @param {boolean} [cache=true] Whether to cache the new guild object if it isn't already\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Guild>}\n   * @example\n   * // Fetch a guild by its id\n   * client.guilds.fetch('222078108977594368')\n   *   .then(guild => console.log(guild.name))\n   *   .catch(console.error);\n   */\n\n\n  async fetch(id) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n\n    const data = await this.client.api.guilds(id).get({\n      query: {\n        with_counts: true\n      }\n    });\n    return this.add(data, cache);\n  }\n\n}\n\nmodule.exports = GuildManager;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/managers/GuildManager.js"],"names":["BaseManager","require","Guild","GuildChannel","GuildEmoji","GuildMember","Invite","Role","ChannelTypes","Events","VerificationLevels","DefaultMessageNotifications","ExplicitContentFilterLevels","DataResolver","Permissions","resolveColor","GuildManager","constructor","client","iterable","resolve","guild","resolveID","id","create","name","afkChannelID","afkTimeout","channels","defaultMessageNotifications","explicitContentFilter","icon","region","roles","systemChannelID","verificationLevel","resolveImage","indexOf","channel","type","toUpperCase","parent_id","parentID","permissionOverwrites","overwrite","allow","deny","permission_overwrites","role","color","permissions","Promise","reject","api","guilds","post","data","verification_level","default_message_notifications","explicit_content_filter","afk_channel_id","afk_timeout","system_channel_id","then","cache","has","get","handleGuild","clearTimeout","timeout","removeListener","GUILD_CREATE","decrementMaxListeners","incrementMaxListeners","on","setTimeout","add","undefined","fetch","force","existing","query","with_counts","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst BaseManager = require('./BaseManager');\nconst Guild = require('../structures/Guild');\nconst GuildChannel = require('../structures/GuildChannel');\nconst GuildEmoji = require('../structures/GuildEmoji');\nconst GuildMember = require('../structures/GuildMember');\nconst Invite = require('../structures/Invite');\nconst Role = require('../structures/Role');\nconst {\n  ChannelTypes,\n  Events,\n  VerificationLevels,\n  DefaultMessageNotifications,\n  ExplicitContentFilterLevels,\n} = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst Permissions = require('../util/Permissions');\nconst { resolveColor } = require('../util/Util');\n\n/**\n * Manages API methods for Guilds and stores their cache.\n * @extends {BaseManager}\n */\nclass GuildManager extends BaseManager {\n  constructor(client, iterable) {\n    super(client, iterable, Guild);\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, Guild>}\n   * @name GuildManager#cache\n   */\n\n  /**\n   * Data that resolves to give a Guild object. This can be:\n   * * A Guild object\n   * * A GuildChannel object\n   * * A GuildEmoji object\n   * * A Role object\n   * * A Snowflake\n   * * An Invite object\n   * @typedef {Guild|GuildChannel|GuildMember|GuildEmoji|Role|Snowflake|Invite} GuildResolvable\n   */\n\n  /**\n   * Partial data for a Role.\n   * @typedef {Object} PartialRoleData\n   * @property {number} [id] The ID for this role, used to set channel overrides,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable|number} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   */\n\n  /**\n   * Partial overwrite data.\n   * @typedef {Object} PartialOverwriteData\n   * @property {number|Snowflake} id The Role or User ID for this overwrite\n   * @property {string} [type] The type of this overwrite\n   * @property {PermissionResolvable} [allow] The permissions to allow\n   * @property {PermissionResolvable} [deny] The permissions to deny\n   */\n\n  /**\n   * Partial data for a Channel.\n   * @typedef {Object} PartialChannelData\n   * @property {number} [id] The ID for this channel, used to set its parent,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {number} [parentID] The parent ID for this channel\n   * @property {string} [type] The type of the channel\n   * @property {string} name The name of the channel\n   * @property {string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the channel\n   * @property {PartialOverwriteData} [permissionOverwrites]\n   * Overwrites of the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user of the channel in seconds\n   */\n\n  /**\n   * Resolves a GuildResolvable to a Guild object.\n   * @method resolve\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Guild}\n   */\n  resolve(guild) {\n    if (\n      guild instanceof GuildChannel ||\n      guild instanceof GuildMember ||\n      guild instanceof GuildEmoji ||\n      guild instanceof Role ||\n      (guild instanceof Invite && guild.guild)\n    ) {\n      return super.resolve(guild.guild);\n    }\n    return super.resolve(guild);\n  }\n\n  /**\n   * Resolves a GuildResolvable to a Guild ID string.\n   * @method resolveID\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Snowflake}\n   */\n  resolveID(guild) {\n    if (\n      guild instanceof GuildChannel ||\n      guild instanceof GuildMember ||\n      guild instanceof GuildEmoji ||\n      guild instanceof Role ||\n      (guild instanceof Invite && guild.guild)\n    ) {\n      return super.resolveID(guild.guild.id);\n    }\n    return super.resolveID(guild);\n  }\n\n  /**\n   * Creates a guild.\n   * <warn>This is only available to bots in fewer than 10 guilds.</warn>\n   * @param {string} name The name of the guild\n   * @param {Object} [options] Options for the creating\n   * @param {number} [options.afkChannelID] The ID of the AFK channel\n   * @param {number} [options.afkTimeout] The AFK timeout in seconds\n   * @param {PartialChannelData[]} [options.channels] The channels for this guild\n   * @param {DefaultMessageNotifications} [options.defaultMessageNotifications] The default message notifications\n   * for the guild\n   * @param {ExplicitContentFilterLevel} [options.explicitContentFilter] The explicit content filter level for the guild\n   * @param {BufferResolvable|Base64Resolvable} [options.icon=null] The icon for the guild\n   * @param {string} [options.region] The region for the server, defaults to the closest one available\n   * @param {PartialRoleData[]} [options.roles] The roles for this guild,\n   * the first element of this array is used to change properties of the guild's everyone role.\n   * @param {number} [options.systemChannelID] The ID of the system channel\n   * @param {VerificationLevel} [options.verificationLevel] The verification level for the guild\n   * @returns {Promise<Guild>} The guild that was created\n   */\n  async create(\n    name,\n    {\n      afkChannelID,\n      afkTimeout,\n      channels = [],\n      defaultMessageNotifications,\n      explicitContentFilter,\n      icon = null,\n      region,\n      roles = [],\n      systemChannelID,\n      verificationLevel,\n    } = {},\n  ) {\n    icon = await DataResolver.resolveImage(icon);\n    if (typeof verificationLevel !== 'undefined' && typeof verificationLevel !== 'number') {\n      verificationLevel = VerificationLevels.indexOf(verificationLevel);\n    }\n    if (typeof defaultMessageNotifications !== 'undefined' && typeof defaultMessageNotifications !== 'number') {\n      defaultMessageNotifications = DefaultMessageNotifications.indexOf(defaultMessageNotifications);\n    }\n    if (typeof explicitContentFilter !== 'undefined' && typeof explicitContentFilter !== 'number') {\n      explicitContentFilter = ExplicitContentFilterLevels.indexOf(explicitContentFilter);\n    }\n    for (const channel of channels) {\n      if (channel.type) channel.type = ChannelTypes[channel.type.toUpperCase()];\n      channel.parent_id = channel.parentID;\n      delete channel.parentID;\n      if (!channel.permissionOverwrites) continue;\n      for (const overwrite of channel.permissionOverwrites) {\n        if (overwrite.allow) overwrite.allow = Permissions.resolve(overwrite.allow);\n        if (overwrite.deny) overwrite.deny = Permissions.resolve(overwrite.deny);\n      }\n      channel.permission_overwrites = channel.permissionOverwrites;\n      delete channel.permissionOverwrites;\n    }\n    for (const role of roles) {\n      if (role.color) role.color = resolveColor(role.color);\n      if (role.permissions) role.permissions = Permissions.resolve(role.permissions);\n    }\n    return new Promise((resolve, reject) =>\n      this.client.api.guilds\n        .post({\n          data: {\n            name,\n            region,\n            icon,\n            verification_level: verificationLevel,\n            default_message_notifications: defaultMessageNotifications,\n            explicit_content_filter: explicitContentFilter,\n            roles,\n            channels,\n            afk_channel_id: afkChannelID,\n            afk_timeout: afkTimeout,\n            system_channel_id: systemChannelID,\n          },\n        })\n        .then(data => {\n          if (this.client.guilds.cache.has(data.id)) return resolve(this.client.guilds.cache.get(data.id));\n\n          const handleGuild = guild => {\n            if (guild.id === data.id) {\n              this.client.clearTimeout(timeout);\n              this.client.removeListener(Events.GUILD_CREATE, handleGuild);\n              this.client.decrementMaxListeners();\n              resolve(guild);\n            }\n          };\n          this.client.incrementMaxListeners();\n          this.client.on(Events.GUILD_CREATE, handleGuild);\n\n          const timeout = this.client.setTimeout(() => {\n            this.client.removeListener(Events.GUILD_CREATE, handleGuild);\n            this.client.decrementMaxListeners();\n            resolve(this.client.guilds.add(data));\n          }, 10000);\n          return undefined;\n        }, reject),\n    );\n  }\n\n  /**\n   * Obtains a guild from Discord, or the guild cache if it's already available.\n   * @param {Snowflake} id ID of the guild\n   * @param {boolean} [cache=true] Whether to cache the new guild object if it isn't already\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Guild>}\n   * @example\n   * // Fetch a guild by its id\n   * client.guilds.fetch('222078108977594368')\n   *   .then(guild => console.log(guild.name))\n   *   .catch(console.error);\n   */\n  async fetch(id, cache = true, force = false) {\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n\n    const data = await this.client.api.guilds(id).get({ query: { with_counts: true } });\n    return this.add(data, cache);\n  }\n}\n\nmodule.exports = GuildManager;\n"]},"metadata":{},"sourceType":"script"}