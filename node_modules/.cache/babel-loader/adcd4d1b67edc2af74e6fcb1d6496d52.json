{"ast":null,"code":"'use strict';\n\nconst GuildChannel = require('./GuildChannel');\n\nconst {\n  Error\n} = require('../errors');\n\nconst Collection = require('../util/Collection');\n\nconst {\n  browser\n} = require('../util/Constants');\n\nconst Permissions = require('../util/Permissions');\n/**\n * Represents a guild voice channel on Discord.\n * @extends {GuildChannel}\n */\n\n\nclass VoiceChannel extends GuildChannel {\n  _patch(data) {\n    super._patch(data);\n    /**\n     * The bitrate of this voice channel\n     * @type {number}\n     */\n\n\n    this.bitrate = data.bitrate;\n    /**\n     * The maximum amount of users allowed in this channel - 0 means unlimited.\n     * @type {number}\n     */\n\n    this.userLimit = data.user_limit;\n  }\n  /**\n   * The members in this voice channel\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n\n\n  get members() {\n    const coll = new Collection();\n\n    for (const state of this.guild.voiceStates.cache.values()) {\n      if (state.channelID === this.id && state.member) {\n        coll.set(state.id, state.member);\n      }\n    }\n\n    return coll;\n  }\n  /**\n   * Checks if the voice channel is full\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get full() {\n    return this.userLimit > 0 && this.members.size >= this.userLimit;\n  }\n  /**\n   * Whether the channel is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get deletable() {\n    return super.deletable && this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false);\n  }\n  /**\n   * Whether the channel is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get editable() {\n    return this.manageable && this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false);\n  }\n  /**\n   * Whether the channel is joinable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get joinable() {\n    if (browser) return false;\n    if (!this.viewable) return false;\n    if (!this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false)) return false;\n    if (this.full && !this.permissionsFor(this.client.user).has(Permissions.FLAGS.MOVE_MEMBERS, false)) return false;\n    return true;\n  }\n  /**\n   * Checks if the client has permission to send audio to the voice channel\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get speakable() {\n    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.SPEAK, false);\n  }\n  /**\n   * Sets the bitrate of the channel.\n   * @param {number} bitrate The new bitrate\n   * @param {string} [reason] Reason for changing the channel's bitrate\n   * @returns {Promise<VoiceChannel>}\n   * @example\n   * // Set the bitrate of a voice channel\n   * voiceChannel.setBitrate(48000)\n   *   .then(vc => console.log(`Set bitrate to ${vc.bitrate}bps for ${vc.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setBitrate(bitrate, reason) {\n    return this.edit({\n      bitrate\n    }, reason);\n  }\n  /**\n   * Sets the user limit of the channel.\n   * @param {number} userLimit The new user limit\n   * @param {string} [reason] Reason for changing the user limit\n   * @returns {Promise<VoiceChannel>}\n   * @example\n   * // Set the user limit of a voice channel\n   * voiceChannel.setUserLimit(42)\n   *   .then(vc => console.log(`Set user limit to ${vc.userLimit} for ${vc.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setUserLimit(userLimit, reason) {\n    return this.edit({\n      userLimit\n    }, reason);\n  }\n  /**\n   * Attempts to join this voice channel.\n   * @returns {Promise<VoiceConnection>}\n   * @example\n   * // Join a voice channel\n   * voiceChannel.join()\n   *   .then(connection => console.log('Connected!'))\n   *   .catch(console.error);\n   */\n\n\n  join() {\n    if (browser) return Promise.reject(new Error('VOICE_NO_BROWSER'));\n    return this.client.voice.joinChannel(this);\n  }\n  /**\n   * Leaves this voice channel.\n   * @example\n   * // Leave a voice channel\n   * voiceChannel.leave();\n   */\n\n\n  leave() {\n    if (browser) return;\n    const connection = this.client.voice.connections.get(this.guild.id);\n    if (connection && connection.channel.id === this.id) connection.disconnect();\n  }\n\n}\n\nmodule.exports = VoiceChannel;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/structures/VoiceChannel.js"],"names":["GuildChannel","require","Error","Collection","browser","Permissions","VoiceChannel","_patch","data","bitrate","userLimit","user_limit","members","coll","state","guild","voiceStates","cache","values","channelID","id","member","set","full","size","deletable","permissionsFor","client","user","has","FLAGS","CONNECT","editable","manageable","joinable","viewable","MOVE_MEMBERS","speakable","SPEAK","setBitrate","reason","edit","setUserLimit","join","Promise","reject","voice","joinChannel","leave","connection","connections","get","channel","disconnect","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst GuildChannel = require('./GuildChannel');\nconst { Error } = require('../errors');\nconst Collection = require('../util/Collection');\nconst { browser } = require('../util/Constants');\nconst Permissions = require('../util/Permissions');\n\n/**\n * Represents a guild voice channel on Discord.\n * @extends {GuildChannel}\n */\nclass VoiceChannel extends GuildChannel {\n  _patch(data) {\n    super._patch(data);\n    /**\n     * The bitrate of this voice channel\n     * @type {number}\n     */\n    this.bitrate = data.bitrate;\n\n    /**\n     * The maximum amount of users allowed in this channel - 0 means unlimited.\n     * @type {number}\n     */\n    this.userLimit = data.user_limit;\n  }\n\n  /**\n   * The members in this voice channel\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    const coll = new Collection();\n    for (const state of this.guild.voiceStates.cache.values()) {\n      if (state.channelID === this.id && state.member) {\n        coll.set(state.id, state.member);\n      }\n    }\n    return coll;\n  }\n\n  /**\n   * Checks if the voice channel is full\n   * @type {boolean}\n   * @readonly\n   */\n  get full() {\n    return this.userLimit > 0 && this.members.size >= this.userLimit;\n  }\n\n  /**\n   * Whether the channel is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    return super.deletable && this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false);\n  }\n\n  /**\n   * Whether the channel is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    return this.manageable && this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false);\n  }\n\n  /**\n   * Whether the channel is joinable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get joinable() {\n    if (browser) return false;\n    if (!this.viewable) return false;\n    if (!this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false)) return false;\n    if (this.full && !this.permissionsFor(this.client.user).has(Permissions.FLAGS.MOVE_MEMBERS, false)) return false;\n    return true;\n  }\n\n  /**\n   * Checks if the client has permission to send audio to the voice channel\n   * @type {boolean}\n   * @readonly\n   */\n  get speakable() {\n    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.SPEAK, false);\n  }\n\n  /**\n   * Sets the bitrate of the channel.\n   * @param {number} bitrate The new bitrate\n   * @param {string} [reason] Reason for changing the channel's bitrate\n   * @returns {Promise<VoiceChannel>}\n   * @example\n   * // Set the bitrate of a voice channel\n   * voiceChannel.setBitrate(48000)\n   *   .then(vc => console.log(`Set bitrate to ${vc.bitrate}bps for ${vc.name}`))\n   *   .catch(console.error);\n   */\n  setBitrate(bitrate, reason) {\n    return this.edit({ bitrate }, reason);\n  }\n\n  /**\n   * Sets the user limit of the channel.\n   * @param {number} userLimit The new user limit\n   * @param {string} [reason] Reason for changing the user limit\n   * @returns {Promise<VoiceChannel>}\n   * @example\n   * // Set the user limit of a voice channel\n   * voiceChannel.setUserLimit(42)\n   *   .then(vc => console.log(`Set user limit to ${vc.userLimit} for ${vc.name}`))\n   *   .catch(console.error);\n   */\n  setUserLimit(userLimit, reason) {\n    return this.edit({ userLimit }, reason);\n  }\n\n  /**\n   * Attempts to join this voice channel.\n   * @returns {Promise<VoiceConnection>}\n   * @example\n   * // Join a voice channel\n   * voiceChannel.join()\n   *   .then(connection => console.log('Connected!'))\n   *   .catch(console.error);\n   */\n  join() {\n    if (browser) return Promise.reject(new Error('VOICE_NO_BROWSER'));\n    return this.client.voice.joinChannel(this);\n  }\n\n  /**\n   * Leaves this voice channel.\n   * @example\n   * // Leave a voice channel\n   * voiceChannel.leave();\n   */\n  leave() {\n    if (browser) return;\n    const connection = this.client.voice.connections.get(this.guild.id);\n    if (connection && connection.channel.id === this.id) connection.disconnect();\n  }\n}\n\nmodule.exports = VoiceChannel;\n"]},"metadata":{},"sourceType":"script"}