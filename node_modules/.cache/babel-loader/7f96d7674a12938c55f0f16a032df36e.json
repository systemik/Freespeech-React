{"ast":null,"code":"'use strict';\n\nconst BaseManager = require('./BaseManager');\n\nconst {\n  TypeError\n} = require('../errors');\n\nconst Message = require('../structures/Message');\n\nconst Collection = require('../util/Collection');\n\nconst LimitedCollection = require('../util/LimitedCollection');\n/**\n * Manages API methods for Messages and holds their cache.\n * @extends {BaseManager}\n */\n\n\nclass MessageManager extends BaseManager {\n  constructor(channel, iterable) {\n    super(channel.client, iterable, Message, LimitedCollection, channel.client.options.messageCacheMaxSize);\n    /**\n     * The channel that the messages belong to\n     * @type {TextBasedChannel}\n     */\n\n    this.channel = channel;\n  }\n  /**\n   * The cache of Messages\n   * @type {Collection<Snowflake, Message>}\n   * @name MessageManager#cache\n   */\n\n\n  add(data, cache) {\n    return super.add(data, cache, {\n      extras: [this.channel]\n    });\n  }\n  /**\n   * The parameters to pass in when requesting previous messages from a channel. `around`, `before` and\n   * `after` are mutually exclusive. All the parameters are optional.\n   * @typedef {Object} ChannelLogsQueryOptions\n   * @property {number} [limit=50] Number of messages to acquire\n   * @property {Snowflake} [before] ID of a message to get the messages that were posted before it\n   * @property {Snowflake} [after] ID of a message to get the messages that were posted after it\n   * @property {Snowflake} [around] ID of a message to get the messages that were posted around it\n   */\n\n  /**\n   * Gets a message, or messages, from this channel.\n   * <info>The returned Collection does not contain reaction users of the messages if they were not cached.\n   * Those need to be fetched separately in such a case.</info>\n   * @param {Snowflake|ChannelLogsQueryOptions} [message] The ID of the message to fetch, or query parameters.\n   * @param {boolean} [cache=true] Whether to cache the message(s)\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Message>|Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Get message\n   * channel.messages.fetch('99539446449315840')\n   *   .then(message => console.log(message.content))\n   *   .catch(console.error);\n   * @example\n   * // Get messages\n   * channel.messages.fetch({ limit: 10 })\n   *   .then(messages => console.log(`Received ${messages.size} messages`))\n   *   .catch(console.error);\n   * @example\n   * // Get messages and filter by user ID\n   * channel.messages.fetch()\n   *   .then(messages => console.log(`${messages.filter(m => m.author.id === '84484653687267328').size} messages`))\n   *   .catch(console.error);\n   */\n\n\n  fetch(message) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return typeof message === 'string' ? this._fetchId(message, cache, force) : this._fetchMany(message, cache);\n  }\n  /**\n   * Fetches the pinned messages of this channel and returns a collection of them.\n   * <info>The returned Collection does not contain any reaction data of the messages.\n   * Those need to be fetched separately.</info>\n   * @param {boolean} [cache=true] Whether to cache the message(s)\n   * @returns {Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Get pinned messages\n   * channel.messages.fetchPinned()\n   *   .then(messages => console.log(`Received ${messages.size} messages`))\n   *   .catch(console.error);\n   */\n\n\n  fetchPinned() {\n    let cache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return this.client.api.channels[this.channel.id].pins.get().then(data => {\n      const messages = new Collection();\n\n      for (const message of data) messages.set(message.id, this.add(message, cache));\n\n      return messages;\n    });\n  }\n  /**\n   * Data that can be resolved to a Message object. This can be:\n   * * A Message\n   * * A Snowflake\n   * @typedef {Message|Snowflake} MessageResolvable\n   */\n\n  /**\n   * Resolves a MessageResolvable to a Message object.\n   * @method resolve\n   * @memberof MessageManager\n   * @instance\n   * @param {MessageResolvable} message The message resolvable to resolve\n   * @returns {?Message}\n   */\n\n  /**\n   * Resolves a MessageResolvable to a Message ID string.\n   * @method resolveID\n   * @memberof MessageManager\n   * @instance\n   * @param {MessageResolvable} message The message resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Deletes a message, even if it's not cached.\n   * @param {MessageResolvable} message The message to delete\n   * @param {string} [reason] Reason for deleting this message, if it does not belong to the client user\n   * @returns {Promise<void>}\n   */\n\n\n  async delete(message, reason) {\n    message = this.resolveID(message);\n    if (!message) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n    await this.client.api.channels(this.channel.id).messages(message).delete({\n      reason\n    });\n  }\n\n  async _fetchId(messageID, cache, force) {\n    if (!force) {\n      const existing = this.cache.get(messageID);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.api.channels[this.channel.id].messages[messageID].get();\n    return this.add(data, cache);\n  }\n\n  async _fetchMany() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let cache = arguments.length > 1 ? arguments[1] : undefined;\n    const data = await this.client.api.channels[this.channel.id].messages.get({\n      query: options\n    });\n    const messages = new Collection();\n\n    for (const message of data) messages.set(message.id, this.add(message, cache));\n\n    return messages;\n  }\n\n}\n\nmodule.exports = MessageManager;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/managers/MessageManager.js"],"names":["BaseManager","require","TypeError","Message","Collection","LimitedCollection","MessageManager","constructor","channel","iterable","client","options","messageCacheMaxSize","add","data","cache","extras","fetch","message","force","_fetchId","_fetchMany","fetchPinned","api","channels","id","pins","get","then","messages","set","delete","reason","resolveID","messageID","existing","partial","query","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst BaseManager = require('./BaseManager');\nconst { TypeError } = require('../errors');\nconst Message = require('../structures/Message');\nconst Collection = require('../util/Collection');\nconst LimitedCollection = require('../util/LimitedCollection');\n\n/**\n * Manages API methods for Messages and holds their cache.\n * @extends {BaseManager}\n */\nclass MessageManager extends BaseManager {\n  constructor(channel, iterable) {\n    super(channel.client, iterable, Message, LimitedCollection, channel.client.options.messageCacheMaxSize);\n    /**\n     * The channel that the messages belong to\n     * @type {TextBasedChannel}\n     */\n    this.channel = channel;\n  }\n\n  /**\n   * The cache of Messages\n   * @type {Collection<Snowflake, Message>}\n   * @name MessageManager#cache\n   */\n\n  add(data, cache) {\n    return super.add(data, cache, { extras: [this.channel] });\n  }\n\n  /**\n   * The parameters to pass in when requesting previous messages from a channel. `around`, `before` and\n   * `after` are mutually exclusive. All the parameters are optional.\n   * @typedef {Object} ChannelLogsQueryOptions\n   * @property {number} [limit=50] Number of messages to acquire\n   * @property {Snowflake} [before] ID of a message to get the messages that were posted before it\n   * @property {Snowflake} [after] ID of a message to get the messages that were posted after it\n   * @property {Snowflake} [around] ID of a message to get the messages that were posted around it\n   */\n\n  /**\n   * Gets a message, or messages, from this channel.\n   * <info>The returned Collection does not contain reaction users of the messages if they were not cached.\n   * Those need to be fetched separately in such a case.</info>\n   * @param {Snowflake|ChannelLogsQueryOptions} [message] The ID of the message to fetch, or query parameters.\n   * @param {boolean} [cache=true] Whether to cache the message(s)\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Message>|Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Get message\n   * channel.messages.fetch('99539446449315840')\n   *   .then(message => console.log(message.content))\n   *   .catch(console.error);\n   * @example\n   * // Get messages\n   * channel.messages.fetch({ limit: 10 })\n   *   .then(messages => console.log(`Received ${messages.size} messages`))\n   *   .catch(console.error);\n   * @example\n   * // Get messages and filter by user ID\n   * channel.messages.fetch()\n   *   .then(messages => console.log(`${messages.filter(m => m.author.id === '84484653687267328').size} messages`))\n   *   .catch(console.error);\n   */\n  fetch(message, cache = true, force = false) {\n    return typeof message === 'string' ? this._fetchId(message, cache, force) : this._fetchMany(message, cache);\n  }\n\n  /**\n   * Fetches the pinned messages of this channel and returns a collection of them.\n   * <info>The returned Collection does not contain any reaction data of the messages.\n   * Those need to be fetched separately.</info>\n   * @param {boolean} [cache=true] Whether to cache the message(s)\n   * @returns {Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Get pinned messages\n   * channel.messages.fetchPinned()\n   *   .then(messages => console.log(`Received ${messages.size} messages`))\n   *   .catch(console.error);\n   */\n  fetchPinned(cache = true) {\n    return this.client.api.channels[this.channel.id].pins.get().then(data => {\n      const messages = new Collection();\n      for (const message of data) messages.set(message.id, this.add(message, cache));\n      return messages;\n    });\n  }\n\n  /**\n   * Data that can be resolved to a Message object. This can be:\n   * * A Message\n   * * A Snowflake\n   * @typedef {Message|Snowflake} MessageResolvable\n   */\n\n  /**\n   * Resolves a MessageResolvable to a Message object.\n   * @method resolve\n   * @memberof MessageManager\n   * @instance\n   * @param {MessageResolvable} message The message resolvable to resolve\n   * @returns {?Message}\n   */\n\n  /**\n   * Resolves a MessageResolvable to a Message ID string.\n   * @method resolveID\n   * @memberof MessageManager\n   * @instance\n   * @param {MessageResolvable} message The message resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Deletes a message, even if it's not cached.\n   * @param {MessageResolvable} message The message to delete\n   * @param {string} [reason] Reason for deleting this message, if it does not belong to the client user\n   * @returns {Promise<void>}\n   */\n  async delete(message, reason) {\n    message = this.resolveID(message);\n    if (!message) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n\n    await this.client.api.channels(this.channel.id).messages(message).delete({ reason });\n  }\n\n  async _fetchId(messageID, cache, force) {\n    if (!force) {\n      const existing = this.cache.get(messageID);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.api.channels[this.channel.id].messages[messageID].get();\n    return this.add(data, cache);\n  }\n\n  async _fetchMany(options = {}, cache) {\n    const data = await this.client.api.channels[this.channel.id].messages.get({ query: options });\n    const messages = new Collection();\n    for (const message of data) messages.set(message.id, this.add(message, cache));\n    return messages;\n  }\n}\n\nmodule.exports = MessageManager;\n"]},"metadata":{},"sourceType":"script"}