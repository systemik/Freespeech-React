{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst WebSocketShard = require('./WebSocketShard');\n\nconst PacketHandlers = require('./handlers');\n\nconst {\n  Error: DJSError\n} = require('../../errors');\n\nconst Collection = require('../../util/Collection');\n\nconst {\n  Events,\n  ShardEvents,\n  Status,\n  WSCodes,\n  WSEvents\n} = require('../../util/Constants');\n\nconst Util = require('../../util/Util');\n\nconst BeforeReadyWhitelist = [WSEvents.READY, WSEvents.RESUMED, WSEvents.GUILD_CREATE, WSEvents.GUILD_DELETE, WSEvents.GUILD_MEMBERS_CHUNK, WSEvents.GUILD_MEMBER_ADD, WSEvents.GUILD_MEMBER_REMOVE];\nconst UNRECOVERABLE_CLOSE_CODES = Object.keys(WSCodes).slice(1).map(Number);\nconst UNRESUMABLE_CLOSE_CODES = [1000, 4006, 4007];\n/**\n * The WebSocket manager for this client.\n * <info>This class forwards raw dispatch events,\n * read more about it here {@link https://discord.com/developers/docs/topics/gateway}</info>\n * @extends EventEmitter\n */\n\nclass WebSocketManager extends EventEmitter {\n  constructor(client) {\n    super();\n    /**\n     * The client that instantiated this WebSocketManager\n     * @type {Client}\n     * @readonly\n     * @name WebSocketManager#client\n     */\n\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n    /**\n     * The gateway this manager uses\n     * @type {?string}\n     */\n\n    this.gateway = null;\n    /**\n     * The amount of shards this manager handles\n     * @private\n     * @type {number}\n     */\n\n    this.totalShards = this.client.options.shards.length;\n    /**\n     * A collection of all shards this manager handles\n     * @type {Collection<number, WebSocketShard>}\n     */\n\n    this.shards = new Collection();\n    /**\n     * An array of shards to be connected or that need to reconnect\n     * @type {Set<WebSocketShard>}\n     * @private\n     * @name WebSocketManager#shardQueue\n     */\n\n    Object.defineProperty(this, 'shardQueue', {\n      value: new Set(),\n      writable: true\n    });\n    /**\n     * An array of queued events before this WebSocketManager became ready\n     * @type {object[]}\n     * @private\n     * @name WebSocketManager#packetQueue\n     */\n\n    Object.defineProperty(this, 'packetQueue', {\n      value: []\n    });\n    /**\n     * The current status of this WebSocketManager\n     * @type {number}\n     */\n\n    this.status = Status.IDLE;\n    /**\n     * If this manager was destroyed. It will prevent shards from reconnecting\n     * @type {boolean}\n     * @private\n     */\n\n    this.destroyed = false;\n    /**\n     * If this manager is currently reconnecting one or multiple shards\n     * @type {boolean}\n     * @private\n     */\n\n    this.reconnecting = false;\n    /**\n     * The current session limit of the client\n     * @private\n     * @type {?Object}\n     * @property {number} total Total number of identifies available\n     * @property {number} remaining Number of identifies remaining\n     * @property {number} reset_after Number of milliseconds after which the limit resets\n     */\n\n    this.sessionStartLimit = null;\n  }\n  /**\n   * The average ping of all WebSocketShards\n   * @type {number}\n   * @readonly\n   */\n\n\n  get ping() {\n    const sum = this.shards.reduce((a, b) => a + b.ping, 0);\n    return sum / this.shards.size;\n  }\n  /**\n   * Emits a debug message.\n   * @param {string} message The debug message\n   * @param {?WebSocketShard} [shard] The shard that emitted this message, if any\n   * @private\n   */\n\n\n  debug(message, shard) {\n    this.client.emit(Events.DEBUG, `[WS => ${shard ? `Shard ${shard.id}` : 'Manager'}] ${message}`);\n  }\n  /**\n   * Connects this manager to the gateway.\n   * @private\n   */\n\n\n  async connect() {\n    const invalidToken = new DJSError(WSCodes[4004]);\n    const {\n      url: gatewayURL,\n      shards: recommendedShards,\n      session_start_limit: sessionStartLimit\n    } = await this.client.api.gateway.bot.get().catch(error => {\n      throw error.httpStatus === 401 ? invalidToken : error;\n    });\n    this.sessionStartLimit = sessionStartLimit;\n    const {\n      total,\n      remaining,\n      reset_after\n    } = sessionStartLimit;\n    this.debug(`Fetched Gateway Information\n    URL: ${gatewayURL}\n    Recommended Shards: ${recommendedShards}`);\n    this.debug(`Session Limit Information\n    Total: ${total}\n    Remaining: ${remaining}`);\n    this.gateway = `${gatewayURL}/`;\n    let {\n      shards\n    } = this.client.options;\n\n    if (shards === 'auto') {\n      this.debug(`Using the recommended shard count provided by Discord: ${recommendedShards}`);\n      this.totalShards = this.client.options.shardCount = recommendedShards;\n      shards = this.client.options.shards = Array.from({\n        length: recommendedShards\n      }, (_, i) => i);\n    }\n\n    this.totalShards = shards.length;\n    this.debug(`Spawning shards: ${shards.join(', ')}`);\n    this.shardQueue = new Set(shards.map(id => new WebSocketShard(this, id)));\n    await this._handleSessionLimit(remaining, reset_after);\n    return this.createShards();\n  }\n  /**\n   * Handles the creation of a shard.\n   * @returns {Promise<boolean>}\n   * @private\n   */\n\n\n  async createShards() {\n    // If we don't have any shards to handle, return\n    if (!this.shardQueue.size) return false;\n    const [shard] = this.shardQueue;\n    this.shardQueue.delete(shard);\n\n    if (!shard.eventsAttached) {\n      shard.on(ShardEvents.ALL_READY, unavailableGuilds => {\n        /**\n         * Emitted when a shard turns ready.\n         * @event Client#shardReady\n         * @param {number} id The shard ID that turned ready\n         * @param {?Set<string>} unavailableGuilds Set of unavailable guild IDs, if any\n         */\n        this.client.emit(Events.SHARD_READY, shard.id, unavailableGuilds);\n        if (!this.shardQueue.size) this.reconnecting = false;\n        this.checkShardsReady();\n      });\n      shard.on(ShardEvents.CLOSE, event => {\n        if (event.code === 1000 ? this.destroyed : UNRECOVERABLE_CLOSE_CODES.includes(event.code)) {\n          /**\n           * Emitted when a shard's WebSocket disconnects and will no longer reconnect.\n           * @event Client#shardDisconnect\n           * @param {CloseEvent} event The WebSocket close event\n           * @param {number} id The shard ID that disconnected\n           */\n          this.client.emit(Events.SHARD_DISCONNECT, event, shard.id);\n          this.debug(WSCodes[event.code], shard);\n          return;\n        }\n\n        if (UNRESUMABLE_CLOSE_CODES.includes(event.code)) {\n          // These event codes cannot be resumed\n          shard.sessionID = null;\n        }\n        /**\n         * Emitted when a shard is attempting to reconnect or re-identify.\n         * @event Client#shardReconnecting\n         * @param {number} id The shard ID that is attempting to reconnect\n         */\n\n\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n        this.shardQueue.add(shard);\n\n        if (shard.sessionID) {\n          this.debug(`Session ID is present, attempting an immediate reconnect...`, shard);\n          this.reconnect(true);\n        } else {\n          shard.destroy({\n            reset: true,\n            emit: false,\n            log: false\n          });\n          this.reconnect();\n        }\n      });\n      shard.on(ShardEvents.INVALID_SESSION, () => {\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n      });\n      shard.on(ShardEvents.DESTROYED, () => {\n        this.debug('Shard was destroyed but no WebSocket connection was present! Reconnecting...', shard);\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n        this.shardQueue.add(shard);\n        this.reconnect();\n      });\n      shard.eventsAttached = true;\n    }\n\n    this.shards.set(shard.id, shard);\n\n    try {\n      await shard.connect();\n    } catch (error) {\n      if (error && error.code && UNRECOVERABLE_CLOSE_CODES.includes(error.code)) {\n        throw new DJSError(WSCodes[error.code]); // Undefined if session is invalid, error event for regular closes\n      } else if (!error || error.code) {\n        this.debug('Failed to connect to the gateway, requeueing...', shard);\n        this.shardQueue.add(shard);\n      } else {\n        throw error;\n      }\n    } // If we have more shards, add a 5s delay\n\n\n    if (this.shardQueue.size) {\n      this.debug(`Shard Queue Size: ${this.shardQueue.size}; continuing in 5 seconds...`);\n      await Util.delayFor(5000);\n      await this._handleSessionLimit();\n      return this.createShards();\n    }\n\n    return true;\n  }\n  /**\n   * Handles reconnects for this manager.\n   * @param {boolean} [skipLimit=false] IF this reconnect should skip checking the session limit\n   * @private\n   * @returns {Promise<boolean>}\n   */\n\n\n  async reconnect() {\n    let skipLimit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.reconnecting || this.status !== Status.READY) return false;\n    this.reconnecting = true;\n\n    try {\n      if (!skipLimit) await this._handleSessionLimit();\n      await this.createShards();\n    } catch (error) {\n      this.debug(`Couldn't reconnect or fetch information about the gateway. ${error}`);\n\n      if (error.httpStatus !== 401) {\n        this.debug(`Possible network error occurred. Retrying in 5s...`);\n        await Util.delayFor(5000);\n        this.reconnecting = false;\n        return this.reconnect();\n      } // If we get an error at this point, it means we cannot reconnect anymore\n\n\n      if (this.client.listenerCount(Events.INVALIDATED)) {\n        /**\n         * Emitted when the client's session becomes invalidated.\n         * You are expected to handle closing the process gracefully and preventing a boot loop\n         * if you are listening to this event.\n         * @event Client#invalidated\n         */\n        this.client.emit(Events.INVALIDATED); // Destroy just the shards. This means you have to handle the cleanup yourself\n\n        this.destroy();\n      } else {\n        this.client.destroy();\n      }\n    } finally {\n      this.reconnecting = false;\n    }\n\n    return true;\n  }\n  /**\n   * Broadcasts a packet to every shard this manager handles.\n   * @param {Object} packet The packet to send\n   * @private\n   */\n\n\n  broadcast(packet) {\n    for (const shard of this.shards.values()) shard.send(packet);\n  }\n  /**\n   * Destroys this manager and all its shards.\n   * @private\n   */\n\n\n  destroy() {\n    if (this.destroyed) return;\n    this.debug(`Manager was destroyed. Called by:\\n${new Error('MANAGER_DESTROYED').stack}`);\n    this.destroyed = true;\n    this.shardQueue.clear();\n\n    for (const shard of this.shards.values()) shard.destroy({\n      closeCode: 1000,\n      reset: true,\n      emit: false,\n      log: false\n    });\n  }\n  /**\n   * Handles the timeout required if we cannot identify anymore.\n   * @param {number} [remaining] The amount of remaining identify sessions that can be done today\n   * @param {number} [resetAfter] The amount of time in which the identify counter resets\n   * @private\n   */\n\n\n  async _handleSessionLimit(remaining, resetAfter) {\n    if (typeof remaining === 'undefined' && typeof resetAfter === 'undefined') {\n      const {\n        session_start_limit\n      } = await this.client.api.gateway.bot.get();\n      this.sessionStartLimit = session_start_limit;\n      remaining = session_start_limit.remaining;\n      resetAfter = session_start_limit.reset_after;\n      this.debug(`Session Limit Information\n    Total: ${session_start_limit.total}\n    Remaining: ${remaining}`);\n    }\n\n    if (!remaining) {\n      this.debug(`Exceeded identify threshold. Will attempt a connection in ${resetAfter}ms`);\n      await Util.delayFor(resetAfter);\n    }\n  }\n  /**\n   * Processes a packet and queues it if this WebSocketManager is not ready.\n   * @param {Object} [packet] The packet to be handled\n   * @param {WebSocketShard} [shard] The shard that will handle this packet\n   * @returns {boolean}\n   * @private\n   */\n\n\n  handlePacket(packet, shard) {\n    if (packet && this.status !== Status.READY) {\n      if (!BeforeReadyWhitelist.includes(packet.t)) {\n        this.packetQueue.push({\n          packet,\n          shard\n        });\n        return false;\n      }\n    }\n\n    if (this.packetQueue.length) {\n      const item = this.packetQueue.shift();\n      this.client.setImmediate(() => {\n        this.handlePacket(item.packet, item.shard);\n      });\n    }\n\n    if (packet && PacketHandlers[packet.t]) {\n      PacketHandlers[packet.t](this.client, packet, shard);\n    }\n\n    return true;\n  }\n  /**\n   * Checks whether the client is ready to be marked as ready.\n   * @private\n   */\n\n\n  async checkShardsReady() {\n    if (this.status === Status.READY) return;\n\n    if (this.shards.size !== this.totalShards || this.shards.some(s => s.status !== Status.READY)) {\n      return;\n    }\n\n    this.status = Status.NEARLY;\n\n    if (this.client.options.fetchAllMembers) {\n      try {\n        const promises = this.client.guilds.cache.map(guild => {\n          if (guild.available) return guild.members.fetch(); // Return empty promise if guild is unavailable\n\n          return Promise.resolve();\n        });\n        await Promise.all(promises);\n      } catch (err) {\n        this.debug(`Failed to fetch all members before ready! ${err}\\n${err.stack}`);\n      }\n    }\n\n    this.triggerClientReady();\n  }\n  /**\n   * Causes the client to be marked as ready and emits the ready event.\n   * @private\n   */\n\n\n  triggerClientReady() {\n    this.status = Status.READY;\n    this.client.readyAt = new Date();\n    /**\n     * Emitted when the client becomes ready to start working.\n     * @event Client#ready\n     */\n\n    this.client.emit(Events.CLIENT_READY);\n    this.handlePacket();\n  }\n\n}\n\nmodule.exports = WebSocketManager;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/client/websocket/WebSocketManager.js"],"names":["EventEmitter","require","WebSocketShard","PacketHandlers","Error","DJSError","Collection","Events","ShardEvents","Status","WSCodes","WSEvents","Util","BeforeReadyWhitelist","READY","RESUMED","GUILD_CREATE","GUILD_DELETE","GUILD_MEMBERS_CHUNK","GUILD_MEMBER_ADD","GUILD_MEMBER_REMOVE","UNRECOVERABLE_CLOSE_CODES","Object","keys","slice","map","Number","UNRESUMABLE_CLOSE_CODES","WebSocketManager","constructor","client","defineProperty","value","gateway","totalShards","options","shards","length","Set","writable","status","IDLE","destroyed","reconnecting","sessionStartLimit","ping","sum","reduce","a","b","size","debug","message","shard","emit","DEBUG","id","connect","invalidToken","url","gatewayURL","recommendedShards","session_start_limit","api","bot","get","catch","error","httpStatus","total","remaining","reset_after","shardCount","Array","from","_","i","join","shardQueue","_handleSessionLimit","createShards","delete","eventsAttached","on","ALL_READY","unavailableGuilds","SHARD_READY","checkShardsReady","CLOSE","event","code","includes","SHARD_DISCONNECT","sessionID","SHARD_RECONNECTING","add","reconnect","destroy","reset","log","INVALID_SESSION","DESTROYED","set","delayFor","skipLimit","listenerCount","INVALIDATED","broadcast","packet","values","send","stack","clear","closeCode","resetAfter","handlePacket","t","packetQueue","push","item","shift","setImmediate","some","s","NEARLY","fetchAllMembers","promises","guilds","cache","guild","available","members","fetch","Promise","resolve","all","err","triggerClientReady","readyAt","Date","CLIENT_READY","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst WebSocketShard = require('./WebSocketShard');\nconst PacketHandlers = require('./handlers');\nconst { Error: DJSError } = require('../../errors');\nconst Collection = require('../../util/Collection');\nconst { Events, ShardEvents, Status, WSCodes, WSEvents } = require('../../util/Constants');\nconst Util = require('../../util/Util');\n\nconst BeforeReadyWhitelist = [\n  WSEvents.READY,\n  WSEvents.RESUMED,\n  WSEvents.GUILD_CREATE,\n  WSEvents.GUILD_DELETE,\n  WSEvents.GUILD_MEMBERS_CHUNK,\n  WSEvents.GUILD_MEMBER_ADD,\n  WSEvents.GUILD_MEMBER_REMOVE,\n];\n\nconst UNRECOVERABLE_CLOSE_CODES = Object.keys(WSCodes).slice(1).map(Number);\nconst UNRESUMABLE_CLOSE_CODES = [1000, 4006, 4007];\n\n/**\n * The WebSocket manager for this client.\n * <info>This class forwards raw dispatch events,\n * read more about it here {@link https://discord.com/developers/docs/topics/gateway}</info>\n * @extends EventEmitter\n */\nclass WebSocketManager extends EventEmitter {\n  constructor(client) {\n    super();\n\n    /**\n     * The client that instantiated this WebSocketManager\n     * @type {Client}\n     * @readonly\n     * @name WebSocketManager#client\n     */\n    Object.defineProperty(this, 'client', { value: client });\n\n    /**\n     * The gateway this manager uses\n     * @type {?string}\n     */\n    this.gateway = null;\n\n    /**\n     * The amount of shards this manager handles\n     * @private\n     * @type {number}\n     */\n    this.totalShards = this.client.options.shards.length;\n\n    /**\n     * A collection of all shards this manager handles\n     * @type {Collection<number, WebSocketShard>}\n     */\n    this.shards = new Collection();\n\n    /**\n     * An array of shards to be connected or that need to reconnect\n     * @type {Set<WebSocketShard>}\n     * @private\n     * @name WebSocketManager#shardQueue\n     */\n    Object.defineProperty(this, 'shardQueue', { value: new Set(), writable: true });\n\n    /**\n     * An array of queued events before this WebSocketManager became ready\n     * @type {object[]}\n     * @private\n     * @name WebSocketManager#packetQueue\n     */\n    Object.defineProperty(this, 'packetQueue', { value: [] });\n\n    /**\n     * The current status of this WebSocketManager\n     * @type {number}\n     */\n    this.status = Status.IDLE;\n\n    /**\n     * If this manager was destroyed. It will prevent shards from reconnecting\n     * @type {boolean}\n     * @private\n     */\n    this.destroyed = false;\n\n    /**\n     * If this manager is currently reconnecting one or multiple shards\n     * @type {boolean}\n     * @private\n     */\n    this.reconnecting = false;\n\n    /**\n     * The current session limit of the client\n     * @private\n     * @type {?Object}\n     * @property {number} total Total number of identifies available\n     * @property {number} remaining Number of identifies remaining\n     * @property {number} reset_after Number of milliseconds after which the limit resets\n     */\n    this.sessionStartLimit = null;\n  }\n\n  /**\n   * The average ping of all WebSocketShards\n   * @type {number}\n   * @readonly\n   */\n  get ping() {\n    const sum = this.shards.reduce((a, b) => a + b.ping, 0);\n    return sum / this.shards.size;\n  }\n\n  /**\n   * Emits a debug message.\n   * @param {string} message The debug message\n   * @param {?WebSocketShard} [shard] The shard that emitted this message, if any\n   * @private\n   */\n  debug(message, shard) {\n    this.client.emit(Events.DEBUG, `[WS => ${shard ? `Shard ${shard.id}` : 'Manager'}] ${message}`);\n  }\n\n  /**\n   * Connects this manager to the gateway.\n   * @private\n   */\n  async connect() {\n    const invalidToken = new DJSError(WSCodes[4004]);\n    const {\n      url: gatewayURL,\n      shards: recommendedShards,\n      session_start_limit: sessionStartLimit,\n    } = await this.client.api.gateway.bot.get().catch(error => {\n      throw error.httpStatus === 401 ? invalidToken : error;\n    });\n\n    this.sessionStartLimit = sessionStartLimit;\n\n    const { total, remaining, reset_after } = sessionStartLimit;\n\n    this.debug(`Fetched Gateway Information\n    URL: ${gatewayURL}\n    Recommended Shards: ${recommendedShards}`);\n\n    this.debug(`Session Limit Information\n    Total: ${total}\n    Remaining: ${remaining}`);\n\n    this.gateway = `${gatewayURL}/`;\n\n    let { shards } = this.client.options;\n\n    if (shards === 'auto') {\n      this.debug(`Using the recommended shard count provided by Discord: ${recommendedShards}`);\n      this.totalShards = this.client.options.shardCount = recommendedShards;\n      shards = this.client.options.shards = Array.from({ length: recommendedShards }, (_, i) => i);\n    }\n\n    this.totalShards = shards.length;\n    this.debug(`Spawning shards: ${shards.join(', ')}`);\n    this.shardQueue = new Set(shards.map(id => new WebSocketShard(this, id)));\n\n    await this._handleSessionLimit(remaining, reset_after);\n\n    return this.createShards();\n  }\n\n  /**\n   * Handles the creation of a shard.\n   * @returns {Promise<boolean>}\n   * @private\n   */\n  async createShards() {\n    // If we don't have any shards to handle, return\n    if (!this.shardQueue.size) return false;\n\n    const [shard] = this.shardQueue;\n\n    this.shardQueue.delete(shard);\n\n    if (!shard.eventsAttached) {\n      shard.on(ShardEvents.ALL_READY, unavailableGuilds => {\n        /**\n         * Emitted when a shard turns ready.\n         * @event Client#shardReady\n         * @param {number} id The shard ID that turned ready\n         * @param {?Set<string>} unavailableGuilds Set of unavailable guild IDs, if any\n         */\n        this.client.emit(Events.SHARD_READY, shard.id, unavailableGuilds);\n\n        if (!this.shardQueue.size) this.reconnecting = false;\n        this.checkShardsReady();\n      });\n\n      shard.on(ShardEvents.CLOSE, event => {\n        if (event.code === 1000 ? this.destroyed : UNRECOVERABLE_CLOSE_CODES.includes(event.code)) {\n          /**\n           * Emitted when a shard's WebSocket disconnects and will no longer reconnect.\n           * @event Client#shardDisconnect\n           * @param {CloseEvent} event The WebSocket close event\n           * @param {number} id The shard ID that disconnected\n           */\n          this.client.emit(Events.SHARD_DISCONNECT, event, shard.id);\n          this.debug(WSCodes[event.code], shard);\n          return;\n        }\n\n        if (UNRESUMABLE_CLOSE_CODES.includes(event.code)) {\n          // These event codes cannot be resumed\n          shard.sessionID = null;\n        }\n\n        /**\n         * Emitted when a shard is attempting to reconnect or re-identify.\n         * @event Client#shardReconnecting\n         * @param {number} id The shard ID that is attempting to reconnect\n         */\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n\n        this.shardQueue.add(shard);\n\n        if (shard.sessionID) {\n          this.debug(`Session ID is present, attempting an immediate reconnect...`, shard);\n          this.reconnect(true);\n        } else {\n          shard.destroy({ reset: true, emit: false, log: false });\n          this.reconnect();\n        }\n      });\n\n      shard.on(ShardEvents.INVALID_SESSION, () => {\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n      });\n\n      shard.on(ShardEvents.DESTROYED, () => {\n        this.debug('Shard was destroyed but no WebSocket connection was present! Reconnecting...', shard);\n\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n\n        this.shardQueue.add(shard);\n        this.reconnect();\n      });\n\n      shard.eventsAttached = true;\n    }\n\n    this.shards.set(shard.id, shard);\n\n    try {\n      await shard.connect();\n    } catch (error) {\n      if (error && error.code && UNRECOVERABLE_CLOSE_CODES.includes(error.code)) {\n        throw new DJSError(WSCodes[error.code]);\n        // Undefined if session is invalid, error event for regular closes\n      } else if (!error || error.code) {\n        this.debug('Failed to connect to the gateway, requeueing...', shard);\n        this.shardQueue.add(shard);\n      } else {\n        throw error;\n      }\n    }\n    // If we have more shards, add a 5s delay\n    if (this.shardQueue.size) {\n      this.debug(`Shard Queue Size: ${this.shardQueue.size}; continuing in 5 seconds...`);\n      await Util.delayFor(5000);\n      await this._handleSessionLimit();\n      return this.createShards();\n    }\n\n    return true;\n  }\n\n  /**\n   * Handles reconnects for this manager.\n   * @param {boolean} [skipLimit=false] IF this reconnect should skip checking the session limit\n   * @private\n   * @returns {Promise<boolean>}\n   */\n  async reconnect(skipLimit = false) {\n    if (this.reconnecting || this.status !== Status.READY) return false;\n    this.reconnecting = true;\n    try {\n      if (!skipLimit) await this._handleSessionLimit();\n      await this.createShards();\n    } catch (error) {\n      this.debug(`Couldn't reconnect or fetch information about the gateway. ${error}`);\n      if (error.httpStatus !== 401) {\n        this.debug(`Possible network error occurred. Retrying in 5s...`);\n        await Util.delayFor(5000);\n        this.reconnecting = false;\n        return this.reconnect();\n      }\n      // If we get an error at this point, it means we cannot reconnect anymore\n      if (this.client.listenerCount(Events.INVALIDATED)) {\n        /**\n         * Emitted when the client's session becomes invalidated.\n         * You are expected to handle closing the process gracefully and preventing a boot loop\n         * if you are listening to this event.\n         * @event Client#invalidated\n         */\n        this.client.emit(Events.INVALIDATED);\n        // Destroy just the shards. This means you have to handle the cleanup yourself\n        this.destroy();\n      } else {\n        this.client.destroy();\n      }\n    } finally {\n      this.reconnecting = false;\n    }\n    return true;\n  }\n\n  /**\n   * Broadcasts a packet to every shard this manager handles.\n   * @param {Object} packet The packet to send\n   * @private\n   */\n  broadcast(packet) {\n    for (const shard of this.shards.values()) shard.send(packet);\n  }\n\n  /**\n   * Destroys this manager and all its shards.\n   * @private\n   */\n  destroy() {\n    if (this.destroyed) return;\n    this.debug(`Manager was destroyed. Called by:\\n${new Error('MANAGER_DESTROYED').stack}`);\n    this.destroyed = true;\n    this.shardQueue.clear();\n    for (const shard of this.shards.values()) shard.destroy({ closeCode: 1000, reset: true, emit: false, log: false });\n  }\n\n  /**\n   * Handles the timeout required if we cannot identify anymore.\n   * @param {number} [remaining] The amount of remaining identify sessions that can be done today\n   * @param {number} [resetAfter] The amount of time in which the identify counter resets\n   * @private\n   */\n  async _handleSessionLimit(remaining, resetAfter) {\n    if (typeof remaining === 'undefined' && typeof resetAfter === 'undefined') {\n      const { session_start_limit } = await this.client.api.gateway.bot.get();\n      this.sessionStartLimit = session_start_limit;\n      remaining = session_start_limit.remaining;\n      resetAfter = session_start_limit.reset_after;\n      this.debug(`Session Limit Information\n    Total: ${session_start_limit.total}\n    Remaining: ${remaining}`);\n    }\n    if (!remaining) {\n      this.debug(`Exceeded identify threshold. Will attempt a connection in ${resetAfter}ms`);\n      await Util.delayFor(resetAfter);\n    }\n  }\n\n  /**\n   * Processes a packet and queues it if this WebSocketManager is not ready.\n   * @param {Object} [packet] The packet to be handled\n   * @param {WebSocketShard} [shard] The shard that will handle this packet\n   * @returns {boolean}\n   * @private\n   */\n  handlePacket(packet, shard) {\n    if (packet && this.status !== Status.READY) {\n      if (!BeforeReadyWhitelist.includes(packet.t)) {\n        this.packetQueue.push({ packet, shard });\n        return false;\n      }\n    }\n\n    if (this.packetQueue.length) {\n      const item = this.packetQueue.shift();\n      this.client.setImmediate(() => {\n        this.handlePacket(item.packet, item.shard);\n      });\n    }\n\n    if (packet && PacketHandlers[packet.t]) {\n      PacketHandlers[packet.t](this.client, packet, shard);\n    }\n\n    return true;\n  }\n\n  /**\n   * Checks whether the client is ready to be marked as ready.\n   * @private\n   */\n  async checkShardsReady() {\n    if (this.status === Status.READY) return;\n    if (this.shards.size !== this.totalShards || this.shards.some(s => s.status !== Status.READY)) {\n      return;\n    }\n\n    this.status = Status.NEARLY;\n\n    if (this.client.options.fetchAllMembers) {\n      try {\n        const promises = this.client.guilds.cache.map(guild => {\n          if (guild.available) return guild.members.fetch();\n          // Return empty promise if guild is unavailable\n          return Promise.resolve();\n        });\n        await Promise.all(promises);\n      } catch (err) {\n        this.debug(`Failed to fetch all members before ready! ${err}\\n${err.stack}`);\n      }\n    }\n\n    this.triggerClientReady();\n  }\n\n  /**\n   * Causes the client to be marked as ready and emits the ready event.\n   * @private\n   */\n  triggerClientReady() {\n    this.status = Status.READY;\n\n    this.client.readyAt = new Date();\n\n    /**\n     * Emitted when the client becomes ready to start working.\n     * @event Client#ready\n     */\n    this.client.emit(Events.CLIENT_READY);\n\n    this.handlePacket();\n  }\n}\n\nmodule.exports = WebSocketManager;\n"]},"metadata":{},"sourceType":"script"}