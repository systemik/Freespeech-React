{"ast":null,"code":"'use strict';\n\nconst AsyncQueue = require('./AsyncQueue');\n\nconst DiscordAPIError = require('./DiscordAPIError');\n\nconst HTTPError = require('./HTTPError');\n\nconst {\n  Events: {\n    RATE_LIMIT\n  },\n  browser\n} = require('../util/Constants');\n\nconst Util = require('../util/Util');\n\nfunction parseResponse(res) {\n  if (res.headers.get('content-type').startsWith('application/json')) return res.json();\n  if (browser) return res.blob();\n  return res.buffer();\n}\n\nfunction getAPIOffset(serverDate) {\n  return new Date(serverDate).getTime() - Date.now();\n}\n\nfunction calculateReset(reset, serverDate) {\n  return new Date(Number(reset) * 1000).getTime() - getAPIOffset(serverDate);\n}\n\nclass RequestHandler {\n  constructor(manager) {\n    this.manager = manager;\n    this.queue = new AsyncQueue();\n    this.reset = -1;\n    this.remaining = -1;\n    this.limit = -1;\n    this.retryAfter = -1;\n  }\n\n  async push(request) {\n    await this.queue.wait();\n\n    try {\n      return await this.execute(request);\n    } finally {\n      this.queue.shift();\n    }\n  }\n\n  get limited() {\n    return Boolean(this.manager.globalTimeout) || this.remaining <= 0 && Date.now() < this.reset;\n  }\n\n  get _inactive() {\n    return this.queue.remaining === 0 && !this.limited;\n  }\n\n  async execute(request) {\n    // After calculations and requests have been done, pre-emptively stop further requests\n    if (this.limited) {\n      const timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now();\n\n      if (this.manager.client.listenerCount(RATE_LIMIT)) {\n        /**\n         * Emitted when the client hits a rate limit while making a request\n         * @event Client#rateLimit\n         * @param {Object} rateLimitInfo Object containing the rate limit info\n         * @param {number} rateLimitInfo.timeout Timeout in ms\n         * @param {number} rateLimitInfo.limit Number of requests that can be made to this endpoint\n         * @param {string} rateLimitInfo.method HTTP method used for request that triggered this event\n         * @param {string} rateLimitInfo.path Path used for request that triggered this event\n         * @param {string} rateLimitInfo.route Route used for request that triggered this event\n         */\n        this.manager.client.emit(RATE_LIMIT, {\n          timeout,\n          limit: this.limit,\n          method: request.method,\n          path: request.path,\n          route: request.route\n        });\n      }\n\n      if (this.manager.globalTimeout) {\n        await this.manager.globalTimeout;\n      } else {\n        // Wait for the timeout to expire in order to avoid an actual 429\n        await Util.delayFor(timeout);\n      }\n    } // Perform the request\n\n\n    let res;\n\n    try {\n      res = await request.make();\n    } catch (error) {\n      // Retry the specified number of times for request abortions\n      if (request.retries === this.manager.client.options.retryLimit) {\n        throw new HTTPError(error.message, error.constructor.name, error.status, request.method, request.path);\n      }\n\n      request.retries++;\n      return this.execute(request);\n    }\n\n    if (res && res.headers) {\n      const serverDate = res.headers.get('date');\n      const limit = res.headers.get('x-ratelimit-limit');\n      const remaining = res.headers.get('x-ratelimit-remaining');\n      const reset = res.headers.get('x-ratelimit-reset');\n      const retryAfter = res.headers.get('retry-after');\n      this.limit = limit ? Number(limit) : Infinity;\n      this.remaining = remaining ? Number(remaining) : 1;\n      this.reset = reset ? calculateReset(reset, serverDate) : Date.now();\n      this.retryAfter = retryAfter ? Number(retryAfter) : -1; // https://github.com/discordapp/discord-api-docs/issues/182\n\n      if (request.route.includes('reactions')) {\n        this.reset = new Date(serverDate).getTime() - getAPIOffset(serverDate) + 250;\n      } // Handle global ratelimit\n\n\n      if (res.headers.get('x-ratelimit-global')) {\n        // Set the manager's global timeout as the promise for other requests to \"wait\"\n        this.manager.globalTimeout = Util.delayFor(this.retryAfter); // Wait for the global timeout to resolve before continuing\n\n        await this.manager.globalTimeout; // Clean up global timeout\n\n        this.manager.globalTimeout = null;\n      }\n    } // Handle 2xx and 3xx responses\n\n\n    if (res.ok) {\n      // Nothing wrong with the request, proceed with the next one\n      return parseResponse(res);\n    } // Handle 4xx responses\n\n\n    if (res.status >= 400 && res.status < 500) {\n      // Handle ratelimited requests\n      if (res.status === 429) {\n        // A ratelimit was hit - this should never happen\n        this.manager.client.emit('debug', `429 hit on route ${request.route}`);\n        await Util.delayFor(this.retryAfter);\n        return this.execute(request);\n      } // Handle possible malformed requests\n\n\n      let data;\n\n      try {\n        data = await parseResponse(res);\n      } catch (err) {\n        throw new HTTPError(err.message, err.constructor.name, err.status, request.method, request.path);\n      }\n\n      throw new DiscordAPIError(request.path, data, request.method, res.status);\n    } // Handle 5xx responses\n\n\n    if (res.status >= 500 && res.status < 600) {\n      // Retry the specified number of times for possible serverside issues\n      if (request.retries === this.manager.client.options.retryLimit) {\n        throw new HTTPError(res.statusText, res.constructor.name, res.status, request.method, request.path);\n      }\n\n      request.retries++;\n      return this.execute(request);\n    } // Fallback in the rare case a status code outside the range 200..=599 is returned\n\n\n    return null;\n  }\n\n}\n\nmodule.exports = RequestHandler;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/rest/RequestHandler.js"],"names":["AsyncQueue","require","DiscordAPIError","HTTPError","Events","RATE_LIMIT","browser","Util","parseResponse","res","headers","get","startsWith","json","blob","buffer","getAPIOffset","serverDate","Date","getTime","now","calculateReset","reset","Number","RequestHandler","constructor","manager","queue","remaining","limit","retryAfter","push","request","wait","execute","shift","limited","Boolean","globalTimeout","_inactive","timeout","client","options","restTimeOffset","listenerCount","emit","method","path","route","delayFor","make","error","retries","retryLimit","message","name","status","Infinity","includes","ok","data","err","statusText","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst AsyncQueue = require('./AsyncQueue');\nconst DiscordAPIError = require('./DiscordAPIError');\nconst HTTPError = require('./HTTPError');\nconst {\n  Events: { RATE_LIMIT },\n  browser,\n} = require('../util/Constants');\nconst Util = require('../util/Util');\n\nfunction parseResponse(res) {\n  if (res.headers.get('content-type').startsWith('application/json')) return res.json();\n  if (browser) return res.blob();\n  return res.buffer();\n}\n\nfunction getAPIOffset(serverDate) {\n  return new Date(serverDate).getTime() - Date.now();\n}\n\nfunction calculateReset(reset, serverDate) {\n  return new Date(Number(reset) * 1000).getTime() - getAPIOffset(serverDate);\n}\n\nclass RequestHandler {\n  constructor(manager) {\n    this.manager = manager;\n    this.queue = new AsyncQueue();\n    this.reset = -1;\n    this.remaining = -1;\n    this.limit = -1;\n    this.retryAfter = -1;\n  }\n\n  async push(request) {\n    await this.queue.wait();\n    try {\n      return await this.execute(request);\n    } finally {\n      this.queue.shift();\n    }\n  }\n\n  get limited() {\n    return Boolean(this.manager.globalTimeout) || (this.remaining <= 0 && Date.now() < this.reset);\n  }\n\n  get _inactive() {\n    return this.queue.remaining === 0 && !this.limited;\n  }\n\n  async execute(request) {\n    // After calculations and requests have been done, pre-emptively stop further requests\n    if (this.limited) {\n      const timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now();\n\n      if (this.manager.client.listenerCount(RATE_LIMIT)) {\n        /**\n         * Emitted when the client hits a rate limit while making a request\n         * @event Client#rateLimit\n         * @param {Object} rateLimitInfo Object containing the rate limit info\n         * @param {number} rateLimitInfo.timeout Timeout in ms\n         * @param {number} rateLimitInfo.limit Number of requests that can be made to this endpoint\n         * @param {string} rateLimitInfo.method HTTP method used for request that triggered this event\n         * @param {string} rateLimitInfo.path Path used for request that triggered this event\n         * @param {string} rateLimitInfo.route Route used for request that triggered this event\n         */\n        this.manager.client.emit(RATE_LIMIT, {\n          timeout,\n          limit: this.limit,\n          method: request.method,\n          path: request.path,\n          route: request.route,\n        });\n      }\n\n      if (this.manager.globalTimeout) {\n        await this.manager.globalTimeout;\n      } else {\n        // Wait for the timeout to expire in order to avoid an actual 429\n        await Util.delayFor(timeout);\n      }\n    }\n\n    // Perform the request\n    let res;\n    try {\n      res = await request.make();\n    } catch (error) {\n      // Retry the specified number of times for request abortions\n      if (request.retries === this.manager.client.options.retryLimit) {\n        throw new HTTPError(error.message, error.constructor.name, error.status, request.method, request.path);\n      }\n\n      request.retries++;\n      return this.execute(request);\n    }\n\n    if (res && res.headers) {\n      const serverDate = res.headers.get('date');\n      const limit = res.headers.get('x-ratelimit-limit');\n      const remaining = res.headers.get('x-ratelimit-remaining');\n      const reset = res.headers.get('x-ratelimit-reset');\n      const retryAfter = res.headers.get('retry-after');\n\n      this.limit = limit ? Number(limit) : Infinity;\n      this.remaining = remaining ? Number(remaining) : 1;\n      this.reset = reset ? calculateReset(reset, serverDate) : Date.now();\n      this.retryAfter = retryAfter ? Number(retryAfter) : -1;\n\n      // https://github.com/discordapp/discord-api-docs/issues/182\n      if (request.route.includes('reactions')) {\n        this.reset = new Date(serverDate).getTime() - getAPIOffset(serverDate) + 250;\n      }\n\n      // Handle global ratelimit\n      if (res.headers.get('x-ratelimit-global')) {\n        // Set the manager's global timeout as the promise for other requests to \"wait\"\n        this.manager.globalTimeout = Util.delayFor(this.retryAfter);\n\n        // Wait for the global timeout to resolve before continuing\n        await this.manager.globalTimeout;\n\n        // Clean up global timeout\n        this.manager.globalTimeout = null;\n      }\n    }\n\n    // Handle 2xx and 3xx responses\n    if (res.ok) {\n      // Nothing wrong with the request, proceed with the next one\n      return parseResponse(res);\n    }\n\n    // Handle 4xx responses\n    if (res.status >= 400 && res.status < 500) {\n      // Handle ratelimited requests\n      if (res.status === 429) {\n        // A ratelimit was hit - this should never happen\n        this.manager.client.emit('debug', `429 hit on route ${request.route}`);\n        await Util.delayFor(this.retryAfter);\n        return this.execute(request);\n      }\n\n      // Handle possible malformed requests\n      let data;\n      try {\n        data = await parseResponse(res);\n      } catch (err) {\n        throw new HTTPError(err.message, err.constructor.name, err.status, request.method, request.path);\n      }\n\n      throw new DiscordAPIError(request.path, data, request.method, res.status);\n    }\n\n    // Handle 5xx responses\n    if (res.status >= 500 && res.status < 600) {\n      // Retry the specified number of times for possible serverside issues\n      if (request.retries === this.manager.client.options.retryLimit) {\n        throw new HTTPError(res.statusText, res.constructor.name, res.status, request.method, request.path);\n      }\n\n      request.retries++;\n      return this.execute(request);\n    }\n\n    // Fallback in the rare case a status code outside the range 200..=599 is returned\n    return null;\n  }\n}\n\nmodule.exports = RequestHandler;\n"]},"metadata":{},"sourceType":"script"}