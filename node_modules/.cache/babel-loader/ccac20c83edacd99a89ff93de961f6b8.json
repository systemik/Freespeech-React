{"ast":null,"code":"'use strict';\n\nconst BaseClient = require('./BaseClient');\n\nconst ActionsManager = require('./actions/ActionsManager');\n\nconst ClientVoiceManager = require('./voice/ClientVoiceManager');\n\nconst WebSocketManager = require('./websocket/WebSocketManager');\n\nconst {\n  Error,\n  TypeError,\n  RangeError\n} = require('../errors');\n\nconst ChannelManager = require('../managers/ChannelManager');\n\nconst GuildEmojiManager = require('../managers/GuildEmojiManager');\n\nconst GuildManager = require('../managers/GuildManager');\n\nconst UserManager = require('../managers/UserManager');\n\nconst ShardClientUtil = require('../sharding/ShardClientUtil');\n\nconst ClientApplication = require('../structures/ClientApplication');\n\nconst GuildPreview = require('../structures/GuildPreview');\n\nconst GuildTemplate = require('../structures/GuildTemplate');\n\nconst Invite = require('../structures/Invite');\n\nconst VoiceRegion = require('../structures/VoiceRegion');\n\nconst Webhook = require('../structures/Webhook');\n\nconst Collection = require('../util/Collection');\n\nconst {\n  Events,\n  browser,\n  DefaultOptions\n} = require('../util/Constants');\n\nconst DataResolver = require('../util/DataResolver');\n\nconst Intents = require('../util/Intents');\n\nconst Permissions = require('../util/Permissions');\n\nconst Structures = require('../util/Structures');\n/**\n * The main hub for interacting with the Discord API, and the starting point for any bot.\n * @extends {BaseClient}\n */\n\n\nclass Client extends BaseClient {\n  /**\n   * @param {ClientOptions} [options] Options for the client\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(Object.assign({\n      _tokenType: 'Bot'\n    }, options)); // Obtain shard details from environment or if present, worker threads\n\n    let data = process.env;\n\n    try {\n      // Test if worker threads module is present and used\n      data = require('worker_threads').workerData || data;\n    } catch {// Do nothing\n    }\n\n    if (this.options.shards === DefaultOptions.shards) {\n      if ('SHARDS' in data) {\n        this.options.shards = JSON.parse(data.SHARDS);\n      }\n    }\n\n    if (this.options.shardCount === DefaultOptions.shardCount) {\n      if ('SHARD_COUNT' in data) {\n        this.options.shardCount = Number(data.SHARD_COUNT);\n      } else if (Array.isArray(this.options.shards)) {\n        this.options.shardCount = this.options.shards.length;\n      }\n    }\n\n    const typeofShards = typeof this.options.shards;\n\n    if (typeofShards === 'undefined' && typeof this.options.shardCount === 'number') {\n      this.options.shards = Array.from({\n        length: this.options.shardCount\n      }, (_, i) => i);\n    }\n\n    if (typeofShards === 'number') this.options.shards = [this.options.shards];\n\n    if (Array.isArray(this.options.shards)) {\n      this.options.shards = [...new Set(this.options.shards.filter(item => !isNaN(item) && item >= 0 && item < Infinity && item === (item | 0)))];\n    }\n\n    this._validateOptions();\n    /**\n     * The WebSocket manager of the client\n     * @type {WebSocketManager}\n     */\n\n\n    this.ws = new WebSocketManager(this);\n    /**\n     * The action manager of the client\n     * @type {ActionsManager}\n     * @private\n     */\n\n    this.actions = new ActionsManager(this);\n    /**\n     * The voice manager of the client (`null` in browsers)\n     * @type {?ClientVoiceManager}\n     */\n\n    this.voice = !browser ? new ClientVoiceManager(this) : null;\n    /**\n     * Shard helpers for the client (only if the process was spawned from a {@link ShardingManager})\n     * @type {?ShardClientUtil}\n     */\n\n    this.shard = !browser && process.env.SHARDING_MANAGER ? ShardClientUtil.singleton(this, process.env.SHARDING_MANAGER_MODE) : null;\n    /**\n     * All of the {@link User} objects that have been cached at any point, mapped by their IDs\n     * @type {UserManager}\n     */\n\n    this.users = new UserManager(this);\n    /**\n     * All of the guilds the client is currently handling, mapped by their IDs -\n     * as long as sharding isn't being used, this will be *every* guild the bot is a member of\n     * @type {GuildManager}\n     */\n\n    this.guilds = new GuildManager(this);\n    /**\n     * All of the {@link Channel}s that the client is currently handling, mapped by their IDs -\n     * as long as sharding isn't being used, this will be *every* channel in *every* guild the bot\n     * is a member of. Note that DM channels will not be initially cached, and thus not be present\n     * in the Manager without their explicit fetching or use.\n     * @type {ChannelManager}\n     */\n\n    this.channels = new ChannelManager(this);\n    const ClientPresence = Structures.get('ClientPresence');\n    /**\n     * The presence of the Client\n     * @private\n     * @type {ClientPresence}\n     */\n\n    this.presence = new ClientPresence(this);\n    Object.defineProperty(this, 'token', {\n      writable: true\n    });\n\n    if (!browser && !this.token && 'DISCORD_TOKEN' in process.env) {\n      /**\n       * Authorization token for the logged in bot.\n       * If present, this defaults to `process.env.DISCORD_TOKEN` when instantiating the client\n       * <warn>This should be kept private at all times.</warn>\n       * @type {?string}\n       */\n      this.token = process.env.DISCORD_TOKEN;\n    } else {\n      this.token = null;\n    }\n    /**\n     * User that the client is logged in as\n     * @type {?ClientUser}\n     */\n\n\n    this.user = null;\n    /**\n     * Time at which the client was last regarded as being in the `READY` state\n     * (each time the client disconnects and successfully reconnects, this will be overwritten)\n     * @type {?Date}\n     */\n\n    this.readyAt = null;\n\n    if (this.options.messageSweepInterval > 0) {\n      this.setInterval(this.sweepMessages.bind(this), this.options.messageSweepInterval * 1000);\n    }\n  }\n  /**\n   * All custom emojis that the client has access to, mapped by their IDs\n   * @type {GuildEmojiManager}\n   * @readonly\n   */\n\n\n  get emojis() {\n    const emojis = new GuildEmojiManager({\n      client: this\n    });\n\n    for (const guild of this.guilds.cache.values()) {\n      if (guild.available) for (const emoji of guild.emojis.cache.values()) emojis.cache.set(emoji.id, emoji);\n    }\n\n    return emojis;\n  }\n  /**\n   * Timestamp of the time the client was last `READY` at\n   * @type {?number}\n   * @readonly\n   */\n\n\n  get readyTimestamp() {\n    return this.readyAt ? this.readyAt.getTime() : null;\n  }\n  /**\n   * How long it has been since the client last entered the `READY` state in milliseconds\n   * @type {?number}\n   * @readonly\n   */\n\n\n  get uptime() {\n    return this.readyAt ? Date.now() - this.readyAt : null;\n  }\n  /**\n   * Logs the client in, establishing a websocket connection to Discord.\n   * @param {string} [token=this.token] Token of the account to log in with\n   * @returns {Promise<string>} Token of the account used\n   * @example\n   * client.login('my token');\n   */\n\n\n  async login() {\n    let token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.token;\n    if (!token || typeof token !== 'string') throw new Error('TOKEN_INVALID');\n    this.token = token = token.replace(/^(Bot|Bearer)\\s*/i, '');\n    this.emit(Events.DEBUG, `Provided token: ${token.split('.').map((val, i) => i > 1 ? val.replace(/./g, '*') : val).join('.')}`);\n\n    if (this.options.presence) {\n      this.options.ws.presence = await this.presence._parse(this.options.presence);\n    }\n\n    this.emit(Events.DEBUG, 'Preparing to connect to the gateway...');\n\n    try {\n      await this.ws.connect();\n      return this.token;\n    } catch (error) {\n      this.destroy();\n      throw error;\n    }\n  }\n  /**\n   * Logs out, terminates the connection to Discord, and destroys the client.\n   * @returns {void}\n   */\n\n\n  destroy() {\n    super.destroy();\n    this.ws.destroy();\n    this.token = null;\n  }\n  /**\n   * Obtains an invite from Discord.\n   * @param {InviteResolvable} invite Invite code or URL\n   * @returns {Promise<Invite>}\n   * @example\n   * client.fetchInvite('https://discord.gg/bRCvFy9')\n   *   .then(invite => console.log(`Obtained invite with code: ${invite.code}`))\n   *   .catch(console.error);\n   */\n\n\n  fetchInvite(invite) {\n    const code = DataResolver.resolveInviteCode(invite);\n    return this.api.invites(code).get({\n      query: {\n        with_counts: true\n      }\n    }).then(data => new Invite(this, data));\n  }\n  /**\n   * Obtains a template from Discord.\n   * @param {GuildTemplateResolvable} template Template code or URL\n   * @returns {Promise<GuildTemplate>}\n   * @example\n   * client.fetchGuildTemplate('https://discord.new/FKvmczH2HyUf')\n   *   .then(template => console.log(`Obtained template with code: ${template.code}`))\n   *   .catch(console.error);\n   */\n\n\n  fetchGuildTemplate(template) {\n    const code = DataResolver.resolveGuildTemplateCode(template);\n    return this.api.guilds.templates(code).get().then(data => new GuildTemplate(this, data));\n  }\n  /**\n   * Obtains a webhook from Discord.\n   * @param {Snowflake} id ID of the webhook\n   * @param {string} [token] Token for the webhook\n   * @returns {Promise<Webhook>}\n   * @example\n   * client.fetchWebhook('id', 'token')\n   *   .then(webhook => console.log(`Obtained webhook with name: ${webhook.name}`))\n   *   .catch(console.error);\n   */\n\n\n  fetchWebhook(id, token) {\n    return this.api.webhooks(id, token).get().then(data => new Webhook(this, data));\n  }\n  /**\n   * Obtains the available voice regions from Discord.\n   * @returns {Promise<Collection<string, VoiceRegion>>}\n   * @example\n   * client.fetchVoiceRegions()\n   *   .then(regions => console.log(`Available regions are: ${regions.map(region => region.name).join(', ')}`))\n   *   .catch(console.error);\n   */\n\n\n  fetchVoiceRegions() {\n    return this.api.voice.regions.get().then(res => {\n      const regions = new Collection();\n\n      for (const region of res) regions.set(region.id, new VoiceRegion(region));\n\n      return regions;\n    });\n  }\n  /**\n   * Sweeps all text-based channels' messages and removes the ones older than the max message lifetime.\n   * If the message has been edited, the time of the edit is used rather than the time of the original message.\n   * @param {number} [lifetime=this.options.messageCacheLifetime] Messages that are older than this (in seconds)\n   * will be removed from the caches. The default is based on {@link ClientOptions#messageCacheLifetime}\n   * @returns {number} Amount of messages that were removed from the caches,\n   * or -1 if the message cache lifetime is unlimited\n   * @example\n   * // Remove all messages older than 1800 seconds from the messages cache\n   * const amount = client.sweepMessages(1800);\n   * console.log(`Successfully removed ${amount} messages from the cache.`);\n   */\n\n\n  sweepMessages() {\n    let lifetime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.messageCacheLifetime;\n\n    if (typeof lifetime !== 'number' || isNaN(lifetime)) {\n      throw new TypeError('INVALID_TYPE', 'lifetime', 'number');\n    }\n\n    if (lifetime <= 0) {\n      this.emit(Events.DEBUG, \"Didn't sweep messages - lifetime is unlimited\");\n      return -1;\n    }\n\n    const lifetimeMs = lifetime * 1000;\n    const now = Date.now();\n    let channels = 0;\n    let messages = 0;\n\n    for (const channel of this.channels.cache.values()) {\n      if (!channel.messages) continue;\n      channels++;\n      messages += channel.messages.cache.sweep(message => now - (message.editedTimestamp || message.createdTimestamp) > lifetimeMs);\n    }\n\n    this.emit(Events.DEBUG, `Swept ${messages} messages older than ${lifetime} seconds in ${channels} text-based channels`);\n    return messages;\n  }\n  /**\n   * Obtains the OAuth Application of this bot from Discord.\n   * @returns {Promise<ClientApplication>}\n   */\n\n\n  fetchApplication() {\n    return this.api.oauth2.applications('@me').get().then(app => new ClientApplication(this, app));\n  }\n  /**\n   * Obtains a guild preview from Discord, available for all guilds the bot is in and all Discoverable guilds.\n   * @param {GuildResolvable} guild The guild to fetch the preview for\n   * @returns {Promise<GuildPreview>}\n   */\n\n\n  fetchGuildPreview(guild) {\n    const id = this.guilds.resolveID(guild);\n    if (!id) throw new TypeError('INVALID_TYPE', 'guild', 'GuildResolvable');\n    return this.api.guilds(id).preview.get().then(data => new GuildPreview(this, data));\n  }\n  /**\n   * Generates a link that can be used to invite the bot to a guild.\n   * @param {InviteGenerationOptions|PermissionResolvable} [options] Permissions to request\n   * @returns {Promise<string>}\n   * @example\n   * client.generateInvite({\n   *   permissions: ['SEND_MESSAGES', 'MANAGE_GUILD', 'MENTION_EVERYONE'],\n   * })\n   *   .then(link => console.log(`Generated bot invite link: ${link}`))\n   *   .catch(console.error);\n   */\n\n\n  async generateInvite() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (Array.isArray(options) || ['string', 'number'].includes(typeof options) || options instanceof Permissions) {\n      process.emitWarning('Client#generateInvite: Generate invite with an options object instead of a PermissionResolvable', 'DeprecationWarning');\n      options = {\n        permissions: options\n      };\n    }\n\n    const application = await this.fetchApplication();\n    const query = new URLSearchParams({\n      client_id: application.id,\n      permissions: Permissions.resolve(options.permissions),\n      scope: 'bot'\n    });\n\n    if (typeof options.disableGuildSelect === 'boolean') {\n      query.set('disable_guild_select', options.disableGuildSelect.toString());\n    }\n\n    if (typeof options.guild !== 'undefined') {\n      const guildID = this.guilds.resolveID(options.guild);\n      if (!guildID) throw new TypeError('INVALID_TYPE', 'options.guild', 'GuildResolvable');\n      query.set('guild_id', guildID);\n    }\n\n    return `${this.options.http.api}${this.api.oauth2.authorize}?${query}`;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      readyAt: false\n    });\n  }\n  /**\n   * Calls {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval} on a script\n   * with the client as `this`.\n   * @param {string} script Script to eval\n   * @returns {*}\n   * @private\n   */\n\n\n  _eval(script) {\n    return eval(script);\n  }\n  /**\n   * Validates the client options.\n   * @param {ClientOptions} [options=this.options] Options to validate\n   * @private\n   */\n\n\n  _validateOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options;\n\n    if (typeof options.ws.intents !== 'undefined') {\n      options.ws.intents = Intents.resolve(options.ws.intents);\n    }\n\n    if (typeof options.shardCount !== 'number' || isNaN(options.shardCount) || options.shardCount < 1) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'shardCount', 'a number greater than or equal to 1');\n    }\n\n    if (options.shards && !(options.shards === 'auto' || Array.isArray(options.shards))) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'shards', \"'auto', a number or array of numbers\");\n    }\n\n    if (options.shards && !options.shards.length) throw new RangeError('CLIENT_INVALID_PROVIDED_SHARDS');\n\n    if (typeof options.messageCacheMaxSize !== 'number' || isNaN(options.messageCacheMaxSize)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'messageCacheMaxSize', 'a number');\n    }\n\n    if (typeof options.messageCacheLifetime !== 'number' || isNaN(options.messageCacheLifetime)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'The messageCacheLifetime', 'a number');\n    }\n\n    if (typeof options.messageSweepInterval !== 'number' || isNaN(options.messageSweepInterval)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'messageSweepInterval', 'a number');\n    }\n\n    if (typeof options.messageEditHistoryMaxSize !== 'number' || isNaN(options.messageEditHistoryMaxSize) || options.messageEditHistoryMaxSize < -1) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'messageEditHistoryMaxSize', 'a number greater than or equal to -1');\n    }\n\n    if (typeof options.fetchAllMembers !== 'boolean') {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'fetchAllMembers', 'a boolean');\n    }\n\n    if (typeof options.disableMentions !== 'string') {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'disableMentions', 'a string');\n    }\n\n    if (!Array.isArray(options.partials)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'partials', 'an Array');\n    }\n\n    if (typeof options.restWsBridgeTimeout !== 'number' || isNaN(options.restWsBridgeTimeout)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'restWsBridgeTimeout', 'a number');\n    }\n\n    if (typeof options.restRequestTimeout !== 'number' || isNaN(options.restRequestTimeout)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'restRequestTimeout', 'a number');\n    }\n\n    if (typeof options.restSweepInterval !== 'number' || isNaN(options.restSweepInterval)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'restSweepInterval', 'a number');\n    }\n\n    if (typeof options.retryLimit !== 'number' || isNaN(options.retryLimit)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'retryLimit', 'a number');\n    }\n  }\n\n}\n\nmodule.exports = Client;\n/**\n * Options for {@link Client#generateInvite}.\n * @typedef {Object} InviteGenerationOptions\n * @property {PermissionResolvable} [permissions] Permissions to request\n * @property {GuildResolvable} [guild] Guild to preselect\n * @property {boolean} [disableGuildSelect] Whether to disable the guild selection\n */\n\n/**\n * Emitted for general warnings.\n * @event Client#warn\n * @param {string} info The warning\n */\n\n/**\n * Emitted for general debugging information.\n * @event Client#debug\n * @param {string} info The debug information\n */","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/client/Client.js"],"names":["BaseClient","require","ActionsManager","ClientVoiceManager","WebSocketManager","Error","TypeError","RangeError","ChannelManager","GuildEmojiManager","GuildManager","UserManager","ShardClientUtil","ClientApplication","GuildPreview","GuildTemplate","Invite","VoiceRegion","Webhook","Collection","Events","browser","DefaultOptions","DataResolver","Intents","Permissions","Structures","Client","constructor","options","Object","assign","_tokenType","data","process","env","workerData","shards","JSON","parse","SHARDS","shardCount","Number","SHARD_COUNT","Array","isArray","length","typeofShards","from","_","i","Set","filter","item","isNaN","Infinity","_validateOptions","ws","actions","voice","shard","SHARDING_MANAGER","singleton","SHARDING_MANAGER_MODE","users","guilds","channels","ClientPresence","get","presence","defineProperty","writable","token","DISCORD_TOKEN","user","readyAt","messageSweepInterval","setInterval","sweepMessages","bind","emojis","client","guild","cache","values","available","emoji","set","id","readyTimestamp","getTime","uptime","Date","now","login","replace","emit","DEBUG","split","map","val","join","_parse","connect","error","destroy","fetchInvite","invite","code","resolveInviteCode","api","invites","query","with_counts","then","fetchGuildTemplate","template","resolveGuildTemplateCode","templates","fetchWebhook","webhooks","fetchVoiceRegions","regions","res","region","lifetime","messageCacheLifetime","lifetimeMs","messages","channel","sweep","message","editedTimestamp","createdTimestamp","fetchApplication","oauth2","applications","app","fetchGuildPreview","resolveID","preview","generateInvite","includes","emitWarning","permissions","application","URLSearchParams","client_id","resolve","scope","disableGuildSelect","toString","guildID","http","authorize","toJSON","_eval","script","eval","intents","messageCacheMaxSize","messageEditHistoryMaxSize","fetchAllMembers","disableMentions","partials","restWsBridgeTimeout","restRequestTimeout","restSweepInterval","retryLimit","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst BaseClient = require('./BaseClient');\nconst ActionsManager = require('./actions/ActionsManager');\nconst ClientVoiceManager = require('./voice/ClientVoiceManager');\nconst WebSocketManager = require('./websocket/WebSocketManager');\nconst { Error, TypeError, RangeError } = require('../errors');\nconst ChannelManager = require('../managers/ChannelManager');\nconst GuildEmojiManager = require('../managers/GuildEmojiManager');\nconst GuildManager = require('../managers/GuildManager');\nconst UserManager = require('../managers/UserManager');\nconst ShardClientUtil = require('../sharding/ShardClientUtil');\nconst ClientApplication = require('../structures/ClientApplication');\nconst GuildPreview = require('../structures/GuildPreview');\nconst GuildTemplate = require('../structures/GuildTemplate');\nconst Invite = require('../structures/Invite');\nconst VoiceRegion = require('../structures/VoiceRegion');\nconst Webhook = require('../structures/Webhook');\nconst Collection = require('../util/Collection');\nconst { Events, browser, DefaultOptions } = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst Intents = require('../util/Intents');\nconst Permissions = require('../util/Permissions');\nconst Structures = require('../util/Structures');\n\n/**\n * The main hub for interacting with the Discord API, and the starting point for any bot.\n * @extends {BaseClient}\n */\nclass Client extends BaseClient {\n  /**\n   * @param {ClientOptions} [options] Options for the client\n   */\n  constructor(options = {}) {\n    super(Object.assign({ _tokenType: 'Bot' }, options));\n\n    // Obtain shard details from environment or if present, worker threads\n    let data = process.env;\n    try {\n      // Test if worker threads module is present and used\n      data = require('worker_threads').workerData || data;\n    } catch {\n      // Do nothing\n    }\n\n    if (this.options.shards === DefaultOptions.shards) {\n      if ('SHARDS' in data) {\n        this.options.shards = JSON.parse(data.SHARDS);\n      }\n    }\n\n    if (this.options.shardCount === DefaultOptions.shardCount) {\n      if ('SHARD_COUNT' in data) {\n        this.options.shardCount = Number(data.SHARD_COUNT);\n      } else if (Array.isArray(this.options.shards)) {\n        this.options.shardCount = this.options.shards.length;\n      }\n    }\n\n    const typeofShards = typeof this.options.shards;\n\n    if (typeofShards === 'undefined' && typeof this.options.shardCount === 'number') {\n      this.options.shards = Array.from({ length: this.options.shardCount }, (_, i) => i);\n    }\n\n    if (typeofShards === 'number') this.options.shards = [this.options.shards];\n\n    if (Array.isArray(this.options.shards)) {\n      this.options.shards = [\n        ...new Set(\n          this.options.shards.filter(item => !isNaN(item) && item >= 0 && item < Infinity && item === (item | 0)),\n        ),\n      ];\n    }\n\n    this._validateOptions();\n\n    /**\n     * The WebSocket manager of the client\n     * @type {WebSocketManager}\n     */\n    this.ws = new WebSocketManager(this);\n\n    /**\n     * The action manager of the client\n     * @type {ActionsManager}\n     * @private\n     */\n    this.actions = new ActionsManager(this);\n\n    /**\n     * The voice manager of the client (`null` in browsers)\n     * @type {?ClientVoiceManager}\n     */\n    this.voice = !browser ? new ClientVoiceManager(this) : null;\n\n    /**\n     * Shard helpers for the client (only if the process was spawned from a {@link ShardingManager})\n     * @type {?ShardClientUtil}\n     */\n    this.shard =\n      !browser && process.env.SHARDING_MANAGER\n        ? ShardClientUtil.singleton(this, process.env.SHARDING_MANAGER_MODE)\n        : null;\n\n    /**\n     * All of the {@link User} objects that have been cached at any point, mapped by their IDs\n     * @type {UserManager}\n     */\n    this.users = new UserManager(this);\n\n    /**\n     * All of the guilds the client is currently handling, mapped by their IDs -\n     * as long as sharding isn't being used, this will be *every* guild the bot is a member of\n     * @type {GuildManager}\n     */\n    this.guilds = new GuildManager(this);\n\n    /**\n     * All of the {@link Channel}s that the client is currently handling, mapped by their IDs -\n     * as long as sharding isn't being used, this will be *every* channel in *every* guild the bot\n     * is a member of. Note that DM channels will not be initially cached, and thus not be present\n     * in the Manager without their explicit fetching or use.\n     * @type {ChannelManager}\n     */\n    this.channels = new ChannelManager(this);\n\n    const ClientPresence = Structures.get('ClientPresence');\n    /**\n     * The presence of the Client\n     * @private\n     * @type {ClientPresence}\n     */\n    this.presence = new ClientPresence(this);\n\n    Object.defineProperty(this, 'token', { writable: true });\n    if (!browser && !this.token && 'DISCORD_TOKEN' in process.env) {\n      /**\n       * Authorization token for the logged in bot.\n       * If present, this defaults to `process.env.DISCORD_TOKEN` when instantiating the client\n       * <warn>This should be kept private at all times.</warn>\n       * @type {?string}\n       */\n      this.token = process.env.DISCORD_TOKEN;\n    } else {\n      this.token = null;\n    }\n\n    /**\n     * User that the client is logged in as\n     * @type {?ClientUser}\n     */\n    this.user = null;\n\n    /**\n     * Time at which the client was last regarded as being in the `READY` state\n     * (each time the client disconnects and successfully reconnects, this will be overwritten)\n     * @type {?Date}\n     */\n    this.readyAt = null;\n\n    if (this.options.messageSweepInterval > 0) {\n      this.setInterval(this.sweepMessages.bind(this), this.options.messageSweepInterval * 1000);\n    }\n  }\n\n  /**\n   * All custom emojis that the client has access to, mapped by their IDs\n   * @type {GuildEmojiManager}\n   * @readonly\n   */\n  get emojis() {\n    const emojis = new GuildEmojiManager({ client: this });\n    for (const guild of this.guilds.cache.values()) {\n      if (guild.available) for (const emoji of guild.emojis.cache.values()) emojis.cache.set(emoji.id, emoji);\n    }\n    return emojis;\n  }\n\n  /**\n   * Timestamp of the time the client was last `READY` at\n   * @type {?number}\n   * @readonly\n   */\n  get readyTimestamp() {\n    return this.readyAt ? this.readyAt.getTime() : null;\n  }\n\n  /**\n   * How long it has been since the client last entered the `READY` state in milliseconds\n   * @type {?number}\n   * @readonly\n   */\n  get uptime() {\n    return this.readyAt ? Date.now() - this.readyAt : null;\n  }\n\n  /**\n   * Logs the client in, establishing a websocket connection to Discord.\n   * @param {string} [token=this.token] Token of the account to log in with\n   * @returns {Promise<string>} Token of the account used\n   * @example\n   * client.login('my token');\n   */\n  async login(token = this.token) {\n    if (!token || typeof token !== 'string') throw new Error('TOKEN_INVALID');\n    this.token = token = token.replace(/^(Bot|Bearer)\\s*/i, '');\n    this.emit(\n      Events.DEBUG,\n      `Provided token: ${token\n        .split('.')\n        .map((val, i) => (i > 1 ? val.replace(/./g, '*') : val))\n        .join('.')}`,\n    );\n\n    if (this.options.presence) {\n      this.options.ws.presence = await this.presence._parse(this.options.presence);\n    }\n\n    this.emit(Events.DEBUG, 'Preparing to connect to the gateway...');\n\n    try {\n      await this.ws.connect();\n      return this.token;\n    } catch (error) {\n      this.destroy();\n      throw error;\n    }\n  }\n\n  /**\n   * Logs out, terminates the connection to Discord, and destroys the client.\n   * @returns {void}\n   */\n  destroy() {\n    super.destroy();\n    this.ws.destroy();\n    this.token = null;\n  }\n\n  /**\n   * Obtains an invite from Discord.\n   * @param {InviteResolvable} invite Invite code or URL\n   * @returns {Promise<Invite>}\n   * @example\n   * client.fetchInvite('https://discord.gg/bRCvFy9')\n   *   .then(invite => console.log(`Obtained invite with code: ${invite.code}`))\n   *   .catch(console.error);\n   */\n  fetchInvite(invite) {\n    const code = DataResolver.resolveInviteCode(invite);\n    return this.api\n      .invites(code)\n      .get({ query: { with_counts: true } })\n      .then(data => new Invite(this, data));\n  }\n\n  /**\n   * Obtains a template from Discord.\n   * @param {GuildTemplateResolvable} template Template code or URL\n   * @returns {Promise<GuildTemplate>}\n   * @example\n   * client.fetchGuildTemplate('https://discord.new/FKvmczH2HyUf')\n   *   .then(template => console.log(`Obtained template with code: ${template.code}`))\n   *   .catch(console.error);\n   */\n  fetchGuildTemplate(template) {\n    const code = DataResolver.resolveGuildTemplateCode(template);\n    return this.api.guilds\n      .templates(code)\n      .get()\n      .then(data => new GuildTemplate(this, data));\n  }\n\n  /**\n   * Obtains a webhook from Discord.\n   * @param {Snowflake} id ID of the webhook\n   * @param {string} [token] Token for the webhook\n   * @returns {Promise<Webhook>}\n   * @example\n   * client.fetchWebhook('id', 'token')\n   *   .then(webhook => console.log(`Obtained webhook with name: ${webhook.name}`))\n   *   .catch(console.error);\n   */\n  fetchWebhook(id, token) {\n    return this.api\n      .webhooks(id, token)\n      .get()\n      .then(data => new Webhook(this, data));\n  }\n\n  /**\n   * Obtains the available voice regions from Discord.\n   * @returns {Promise<Collection<string, VoiceRegion>>}\n   * @example\n   * client.fetchVoiceRegions()\n   *   .then(regions => console.log(`Available regions are: ${regions.map(region => region.name).join(', ')}`))\n   *   .catch(console.error);\n   */\n  fetchVoiceRegions() {\n    return this.api.voice.regions.get().then(res => {\n      const regions = new Collection();\n      for (const region of res) regions.set(region.id, new VoiceRegion(region));\n      return regions;\n    });\n  }\n\n  /**\n   * Sweeps all text-based channels' messages and removes the ones older than the max message lifetime.\n   * If the message has been edited, the time of the edit is used rather than the time of the original message.\n   * @param {number} [lifetime=this.options.messageCacheLifetime] Messages that are older than this (in seconds)\n   * will be removed from the caches. The default is based on {@link ClientOptions#messageCacheLifetime}\n   * @returns {number} Amount of messages that were removed from the caches,\n   * or -1 if the message cache lifetime is unlimited\n   * @example\n   * // Remove all messages older than 1800 seconds from the messages cache\n   * const amount = client.sweepMessages(1800);\n   * console.log(`Successfully removed ${amount} messages from the cache.`);\n   */\n  sweepMessages(lifetime = this.options.messageCacheLifetime) {\n    if (typeof lifetime !== 'number' || isNaN(lifetime)) {\n      throw new TypeError('INVALID_TYPE', 'lifetime', 'number');\n    }\n    if (lifetime <= 0) {\n      this.emit(Events.DEBUG, \"Didn't sweep messages - lifetime is unlimited\");\n      return -1;\n    }\n\n    const lifetimeMs = lifetime * 1000;\n    const now = Date.now();\n    let channels = 0;\n    let messages = 0;\n\n    for (const channel of this.channels.cache.values()) {\n      if (!channel.messages) continue;\n      channels++;\n\n      messages += channel.messages.cache.sweep(\n        message => now - (message.editedTimestamp || message.createdTimestamp) > lifetimeMs,\n      );\n    }\n\n    this.emit(\n      Events.DEBUG,\n      `Swept ${messages} messages older than ${lifetime} seconds in ${channels} text-based channels`,\n    );\n    return messages;\n  }\n\n  /**\n   * Obtains the OAuth Application of this bot from Discord.\n   * @returns {Promise<ClientApplication>}\n   */\n  fetchApplication() {\n    return this.api.oauth2\n      .applications('@me')\n      .get()\n      .then(app => new ClientApplication(this, app));\n  }\n\n  /**\n   * Obtains a guild preview from Discord, available for all guilds the bot is in and all Discoverable guilds.\n   * @param {GuildResolvable} guild The guild to fetch the preview for\n   * @returns {Promise<GuildPreview>}\n   */\n  fetchGuildPreview(guild) {\n    const id = this.guilds.resolveID(guild);\n    if (!id) throw new TypeError('INVALID_TYPE', 'guild', 'GuildResolvable');\n    return this.api\n      .guilds(id)\n      .preview.get()\n      .then(data => new GuildPreview(this, data));\n  }\n\n  /**\n   * Generates a link that can be used to invite the bot to a guild.\n   * @param {InviteGenerationOptions|PermissionResolvable} [options] Permissions to request\n   * @returns {Promise<string>}\n   * @example\n   * client.generateInvite({\n   *   permissions: ['SEND_MESSAGES', 'MANAGE_GUILD', 'MENTION_EVERYONE'],\n   * })\n   *   .then(link => console.log(`Generated bot invite link: ${link}`))\n   *   .catch(console.error);\n   */\n  async generateInvite(options = {}) {\n    if (Array.isArray(options) || ['string', 'number'].includes(typeof options) || options instanceof Permissions) {\n      process.emitWarning(\n        'Client#generateInvite: Generate invite with an options object instead of a PermissionResolvable',\n        'DeprecationWarning',\n      );\n      options = { permissions: options };\n    }\n    const application = await this.fetchApplication();\n    const query = new URLSearchParams({\n      client_id: application.id,\n      permissions: Permissions.resolve(options.permissions),\n      scope: 'bot',\n    });\n    if (typeof options.disableGuildSelect === 'boolean') {\n      query.set('disable_guild_select', options.disableGuildSelect.toString());\n    }\n    if (typeof options.guild !== 'undefined') {\n      const guildID = this.guilds.resolveID(options.guild);\n      if (!guildID) throw new TypeError('INVALID_TYPE', 'options.guild', 'GuildResolvable');\n      query.set('guild_id', guildID);\n    }\n    return `${this.options.http.api}${this.api.oauth2.authorize}?${query}`;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      readyAt: false,\n    });\n  }\n\n  /**\n   * Calls {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval} on a script\n   * with the client as `this`.\n   * @param {string} script Script to eval\n   * @returns {*}\n   * @private\n   */\n  _eval(script) {\n    return eval(script);\n  }\n\n  /**\n   * Validates the client options.\n   * @param {ClientOptions} [options=this.options] Options to validate\n   * @private\n   */\n  _validateOptions(options = this.options) {\n    if (typeof options.ws.intents !== 'undefined') {\n      options.ws.intents = Intents.resolve(options.ws.intents);\n    }\n    if (typeof options.shardCount !== 'number' || isNaN(options.shardCount) || options.shardCount < 1) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'shardCount', 'a number greater than or equal to 1');\n    }\n    if (options.shards && !(options.shards === 'auto' || Array.isArray(options.shards))) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'shards', \"'auto', a number or array of numbers\");\n    }\n    if (options.shards && !options.shards.length) throw new RangeError('CLIENT_INVALID_PROVIDED_SHARDS');\n    if (typeof options.messageCacheMaxSize !== 'number' || isNaN(options.messageCacheMaxSize)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'messageCacheMaxSize', 'a number');\n    }\n    if (typeof options.messageCacheLifetime !== 'number' || isNaN(options.messageCacheLifetime)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'The messageCacheLifetime', 'a number');\n    }\n    if (typeof options.messageSweepInterval !== 'number' || isNaN(options.messageSweepInterval)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'messageSweepInterval', 'a number');\n    }\n    if (\n      typeof options.messageEditHistoryMaxSize !== 'number' ||\n      isNaN(options.messageEditHistoryMaxSize) ||\n      options.messageEditHistoryMaxSize < -1\n    ) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'messageEditHistoryMaxSize', 'a number greater than or equal to -1');\n    }\n    if (typeof options.fetchAllMembers !== 'boolean') {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'fetchAllMembers', 'a boolean');\n    }\n    if (typeof options.disableMentions !== 'string') {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'disableMentions', 'a string');\n    }\n    if (!Array.isArray(options.partials)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'partials', 'an Array');\n    }\n    if (typeof options.restWsBridgeTimeout !== 'number' || isNaN(options.restWsBridgeTimeout)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'restWsBridgeTimeout', 'a number');\n    }\n    if (typeof options.restRequestTimeout !== 'number' || isNaN(options.restRequestTimeout)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'restRequestTimeout', 'a number');\n    }\n    if (typeof options.restSweepInterval !== 'number' || isNaN(options.restSweepInterval)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'restSweepInterval', 'a number');\n    }\n    if (typeof options.retryLimit !== 'number' || isNaN(options.retryLimit)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'retryLimit', 'a number');\n    }\n  }\n}\n\nmodule.exports = Client;\n\n/**\n * Options for {@link Client#generateInvite}.\n * @typedef {Object} InviteGenerationOptions\n * @property {PermissionResolvable} [permissions] Permissions to request\n * @property {GuildResolvable} [guild] Guild to preselect\n * @property {boolean} [disableGuildSelect] Whether to disable the guild selection\n */\n\n/**\n * Emitted for general warnings.\n * @event Client#warn\n * @param {string} info The warning\n */\n\n/**\n * Emitted for general debugging information.\n * @event Client#debug\n * @param {string} info The debug information\n */\n"]},"metadata":{},"sourceType":"script"}