{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst Collection = require('../../util/Collection');\n\nconst Util = require('../../util/Util');\n/**\n * Filter to be applied to the collector.\n * @typedef {Function} CollectorFilter\n * @param {...*} args Any arguments received by the listener\n * @param {Collection} collection The items collected by this collector\n * @returns {boolean|Promise<boolean>}\n */\n\n/**\n * Options to be applied to the collector.\n * @typedef {Object} CollectorOptions\n * @property {number} [time] How long to run the collector for in milliseconds\n * @property {number} [idle] How long to stop the collector after inactivity in milliseconds\n * @property {boolean} [dispose=false] Whether to dispose data when it's deleted\n */\n\n/**\n * Abstract class for defining a new Collector.\n * @abstract\n */\n\n\nclass Collector extends EventEmitter {\n  constructor(client, filter) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    /**\n     * The client that instantiated this Collector\n     * @name Collector#client\n     * @type {Client}\n     * @readonly\n     */\n\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n    /**\n     * The filter applied to this collector\n     * @type {CollectorFilter}\n     */\n\n    this.filter = filter;\n    /**\n     * The options of this collector\n     * @type {CollectorOptions}\n     */\n\n    this.options = options;\n    /**\n     * The items collected by this collector\n     * @type {Collection}\n     */\n\n    this.collected = new Collection();\n    /**\n     * Whether this collector has finished collecting\n     * @type {boolean}\n     */\n\n    this.ended = false;\n    /**\n     * Timeout for cleanup\n     * @type {?Timeout}\n     * @private\n     */\n\n    this._timeout = null;\n    /**\n     * Timeout for cleanup due to inactivity\n     * @type {?Timeout}\n     * @private\n     */\n\n    this._idletimeout = null;\n    this.handleCollect = this.handleCollect.bind(this);\n    this.handleDispose = this.handleDispose.bind(this);\n    if (options.time) this._timeout = this.client.setTimeout(() => this.stop('time'), options.time);\n    if (options.idle) this._idletimeout = this.client.setTimeout(() => this.stop('idle'), options.idle);\n  }\n  /**\n   * Call this to handle an event as a collectable element. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @emits Collector#collect\n   */\n\n\n  async handleCollect() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    const collect = this.collect(...args);\n\n    if (collect && (await this.filter(...args, this.collected))) {\n      this.collected.set(collect, args[0]);\n      /**\n       * Emitted whenever an element is collected.\n       * @event Collector#collect\n       * @param {...*} args The arguments emitted by the listener\n       */\n\n      this.emit('collect', ...args);\n\n      if (this._idletimeout) {\n        this.client.clearTimeout(this._idletimeout);\n        this._idletimeout = this.client.setTimeout(() => this.stop('idle'), this.options.idle);\n      }\n    }\n\n    this.checkEnd();\n  }\n  /**\n   * Call this to remove an element from the collection. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @emits Collector#dispose\n   */\n\n\n  handleDispose() {\n    if (!this.options.dispose) return;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    const dispose = this.dispose(...args);\n    if (!dispose || !this.filter(...args) || !this.collected.has(dispose)) return;\n    this.collected.delete(dispose);\n    /**\n     * Emitted whenever an element is disposed of.\n     * @event Collector#dispose\n     * @param {...*} args The arguments emitted by the listener\n     */\n\n    this.emit('dispose', ...args);\n    this.checkEnd();\n  }\n  /**\n   * Returns a promise that resolves with the next collected element;\n   * rejects with collected elements if the collector finishes without receiving a next element\n   * @type {Promise}\n   * @readonly\n   */\n\n\n  get next() {\n    return new Promise((resolve, reject) => {\n      if (this.ended) {\n        reject(this.collected);\n        return;\n      }\n\n      const cleanup = () => {\n        this.removeListener('collect', onCollect);\n        this.removeListener('end', onEnd);\n      };\n\n      const onCollect = item => {\n        cleanup();\n        resolve(item);\n      };\n\n      const onEnd = () => {\n        cleanup();\n        reject(this.collected); // eslint-disable-line prefer-promise-reject-errors\n      };\n\n      this.on('collect', onCollect);\n      this.on('end', onEnd);\n    });\n  }\n  /**\n   * Stops this collector and emits the `end` event.\n   * @param {string} [reason='user'] The reason this collector is ending\n   * @emits Collector#end\n   */\n\n\n  stop() {\n    let reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'user';\n    if (this.ended) return;\n\n    if (this._timeout) {\n      this.client.clearTimeout(this._timeout);\n      this._timeout = null;\n    }\n\n    if (this._idletimeout) {\n      this.client.clearTimeout(this._idletimeout);\n      this._idletimeout = null;\n    }\n\n    this.ended = true;\n    /**\n     * Emitted when the collector is finished collecting.\n     * @event Collector#end\n     * @param {Collection} collected The elements collected by the collector\n     * @param {string} reason The reason the collector ended\n     */\n\n    this.emit('end', this.collected, reason);\n  }\n  /**\n   * Resets the collectors timeout and idle timer.\n   * @param {Object} [options] Options\n   * @param {number} [options.time] How long to run the collector for in milliseconds\n   * @param {number} [options.idle] How long to stop the collector after inactivity in milliseconds\n   */\n\n\n  resetTimer() {\n    let {\n      time,\n      idle\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this._timeout) {\n      this.client.clearTimeout(this._timeout);\n      this._timeout = this.client.setTimeout(() => this.stop('time'), time || this.options.time);\n    }\n\n    if (this._idletimeout) {\n      this.client.clearTimeout(this._idletimeout);\n      this._idletimeout = this.client.setTimeout(() => this.stop('idle'), idle || this.options.idle);\n    }\n  }\n  /**\n   * Checks whether the collector should end, and if so, ends it.\n   */\n\n\n  checkEnd() {\n    const reason = this.endReason();\n    if (reason) this.stop(reason);\n  }\n  /**\n   * Allows collectors to be consumed with for-await-of loops\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of}\n   */\n\n\n  async *[Symbol.asyncIterator]() {\n    const queue = [];\n\n    const onCollect = item => queue.push(item);\n\n    this.on('collect', onCollect);\n\n    try {\n      while (queue.length || !this.ended) {\n        if (queue.length) {\n          yield queue.shift();\n        } else {\n          // eslint-disable-next-line no-await-in-loop\n          await new Promise(resolve => {\n            const tick = () => {\n              this.removeListener('collect', tick);\n              this.removeListener('end', tick);\n              return resolve();\n            };\n\n            this.on('collect', tick);\n            this.on('end', tick);\n          });\n        }\n      }\n    } finally {\n      this.removeListener('collect', onCollect);\n    }\n  }\n\n  toJSON() {\n    return Util.flatten(this);\n  }\n  /* eslint-disable no-empty-function, valid-jsdoc */\n\n  /**\n   * Handles incoming events from the `handleCollect` function. Returns null if the event should not\n   * be collected, or returns an object describing the data that should be stored.\n   * @see Collector#handleCollect\n   * @param {...*} args Any args the event listener emits\n   * @returns {?{key, value}} Data to insert into collection, if any\n   * @abstract\n   */\n\n\n  collect() {}\n  /**\n   * Handles incoming events from the `handleDispose`. Returns null if the event should not\n   * be disposed, or returns the key that should be removed.\n   * @see Collector#handleDispose\n   * @param {...*} args Any args the event listener emits\n   * @returns {?*} Key to remove from the collection, if any\n   * @abstract\n   */\n\n\n  dispose() {}\n  /**\n   * The reason this collector has ended or will end with.\n   * @returns {?string} Reason to end the collector, if any\n   * @abstract\n   */\n\n\n  endReason() {}\n  /* eslint-enable no-empty-function, valid-jsdoc */\n\n\n}\n\nmodule.exports = Collector;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/structures/interfaces/Collector.js"],"names":["EventEmitter","require","Collection","Util","Collector","constructor","client","filter","options","Object","defineProperty","value","collected","ended","_timeout","_idletimeout","handleCollect","bind","handleDispose","time","setTimeout","stop","idle","args","collect","set","emit","clearTimeout","checkEnd","dispose","has","delete","next","Promise","resolve","reject","cleanup","removeListener","onCollect","onEnd","item","on","reason","resetTimer","endReason","Symbol","asyncIterator","queue","push","length","shift","tick","toJSON","flatten","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst Collection = require('../../util/Collection');\nconst Util = require('../../util/Util');\n\n/**\n * Filter to be applied to the collector.\n * @typedef {Function} CollectorFilter\n * @param {...*} args Any arguments received by the listener\n * @param {Collection} collection The items collected by this collector\n * @returns {boolean|Promise<boolean>}\n */\n\n/**\n * Options to be applied to the collector.\n * @typedef {Object} CollectorOptions\n * @property {number} [time] How long to run the collector for in milliseconds\n * @property {number} [idle] How long to stop the collector after inactivity in milliseconds\n * @property {boolean} [dispose=false] Whether to dispose data when it's deleted\n */\n\n/**\n * Abstract class for defining a new Collector.\n * @abstract\n */\nclass Collector extends EventEmitter {\n  constructor(client, filter, options = {}) {\n    super();\n\n    /**\n     * The client that instantiated this Collector\n     * @name Collector#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', { value: client });\n\n    /**\n     * The filter applied to this collector\n     * @type {CollectorFilter}\n     */\n    this.filter = filter;\n\n    /**\n     * The options of this collector\n     * @type {CollectorOptions}\n     */\n    this.options = options;\n\n    /**\n     * The items collected by this collector\n     * @type {Collection}\n     */\n    this.collected = new Collection();\n\n    /**\n     * Whether this collector has finished collecting\n     * @type {boolean}\n     */\n    this.ended = false;\n\n    /**\n     * Timeout for cleanup\n     * @type {?Timeout}\n     * @private\n     */\n    this._timeout = null;\n\n    /**\n     * Timeout for cleanup due to inactivity\n     * @type {?Timeout}\n     * @private\n     */\n    this._idletimeout = null;\n\n    this.handleCollect = this.handleCollect.bind(this);\n    this.handleDispose = this.handleDispose.bind(this);\n\n    if (options.time) this._timeout = this.client.setTimeout(() => this.stop('time'), options.time);\n    if (options.idle) this._idletimeout = this.client.setTimeout(() => this.stop('idle'), options.idle);\n  }\n\n  /**\n   * Call this to handle an event as a collectable element. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @emits Collector#collect\n   */\n  async handleCollect(...args) {\n    const collect = this.collect(...args);\n\n    if (collect && (await this.filter(...args, this.collected))) {\n      this.collected.set(collect, args[0]);\n\n      /**\n       * Emitted whenever an element is collected.\n       * @event Collector#collect\n       * @param {...*} args The arguments emitted by the listener\n       */\n      this.emit('collect', ...args);\n\n      if (this._idletimeout) {\n        this.client.clearTimeout(this._idletimeout);\n        this._idletimeout = this.client.setTimeout(() => this.stop('idle'), this.options.idle);\n      }\n    }\n    this.checkEnd();\n  }\n\n  /**\n   * Call this to remove an element from the collection. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @emits Collector#dispose\n   */\n  handleDispose(...args) {\n    if (!this.options.dispose) return;\n\n    const dispose = this.dispose(...args);\n    if (!dispose || !this.filter(...args) || !this.collected.has(dispose)) return;\n    this.collected.delete(dispose);\n\n    /**\n     * Emitted whenever an element is disposed of.\n     * @event Collector#dispose\n     * @param {...*} args The arguments emitted by the listener\n     */\n    this.emit('dispose', ...args);\n    this.checkEnd();\n  }\n\n  /**\n   * Returns a promise that resolves with the next collected element;\n   * rejects with collected elements if the collector finishes without receiving a next element\n   * @type {Promise}\n   * @readonly\n   */\n  get next() {\n    return new Promise((resolve, reject) => {\n      if (this.ended) {\n        reject(this.collected);\n        return;\n      }\n\n      const cleanup = () => {\n        this.removeListener('collect', onCollect);\n        this.removeListener('end', onEnd);\n      };\n\n      const onCollect = item => {\n        cleanup();\n        resolve(item);\n      };\n\n      const onEnd = () => {\n        cleanup();\n        reject(this.collected); // eslint-disable-line prefer-promise-reject-errors\n      };\n\n      this.on('collect', onCollect);\n      this.on('end', onEnd);\n    });\n  }\n\n  /**\n   * Stops this collector and emits the `end` event.\n   * @param {string} [reason='user'] The reason this collector is ending\n   * @emits Collector#end\n   */\n  stop(reason = 'user') {\n    if (this.ended) return;\n\n    if (this._timeout) {\n      this.client.clearTimeout(this._timeout);\n      this._timeout = null;\n    }\n    if (this._idletimeout) {\n      this.client.clearTimeout(this._idletimeout);\n      this._idletimeout = null;\n    }\n    this.ended = true;\n\n    /**\n     * Emitted when the collector is finished collecting.\n     * @event Collector#end\n     * @param {Collection} collected The elements collected by the collector\n     * @param {string} reason The reason the collector ended\n     */\n    this.emit('end', this.collected, reason);\n  }\n\n  /**\n   * Resets the collectors timeout and idle timer.\n   * @param {Object} [options] Options\n   * @param {number} [options.time] How long to run the collector for in milliseconds\n   * @param {number} [options.idle] How long to stop the collector after inactivity in milliseconds\n   */\n  resetTimer({ time, idle } = {}) {\n    if (this._timeout) {\n      this.client.clearTimeout(this._timeout);\n      this._timeout = this.client.setTimeout(() => this.stop('time'), time || this.options.time);\n    }\n    if (this._idletimeout) {\n      this.client.clearTimeout(this._idletimeout);\n      this._idletimeout = this.client.setTimeout(() => this.stop('idle'), idle || this.options.idle);\n    }\n  }\n\n  /**\n   * Checks whether the collector should end, and if so, ends it.\n   */\n  checkEnd() {\n    const reason = this.endReason();\n    if (reason) this.stop(reason);\n  }\n\n  /**\n   * Allows collectors to be consumed with for-await-of loops\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of}\n   */\n  async *[Symbol.asyncIterator]() {\n    const queue = [];\n    const onCollect = item => queue.push(item);\n    this.on('collect', onCollect);\n\n    try {\n      while (queue.length || !this.ended) {\n        if (queue.length) {\n          yield queue.shift();\n        } else {\n          // eslint-disable-next-line no-await-in-loop\n          await new Promise(resolve => {\n            const tick = () => {\n              this.removeListener('collect', tick);\n              this.removeListener('end', tick);\n              return resolve();\n            };\n            this.on('collect', tick);\n            this.on('end', tick);\n          });\n        }\n      }\n    } finally {\n      this.removeListener('collect', onCollect);\n    }\n  }\n\n  toJSON() {\n    return Util.flatten(this);\n  }\n\n  /* eslint-disable no-empty-function, valid-jsdoc */\n  /**\n   * Handles incoming events from the `handleCollect` function. Returns null if the event should not\n   * be collected, or returns an object describing the data that should be stored.\n   * @see Collector#handleCollect\n   * @param {...*} args Any args the event listener emits\n   * @returns {?{key, value}} Data to insert into collection, if any\n   * @abstract\n   */\n  collect() {}\n\n  /**\n   * Handles incoming events from the `handleDispose`. Returns null if the event should not\n   * be disposed, or returns the key that should be removed.\n   * @see Collector#handleDispose\n   * @param {...*} args Any args the event listener emits\n   * @returns {?*} Key to remove from the collection, if any\n   * @abstract\n   */\n  dispose() {}\n\n  /**\n   * The reason this collector has ended or will end with.\n   * @returns {?string} Reason to end the collector, if any\n   * @abstract\n   */\n  endReason() {}\n  /* eslint-enable no-empty-function, valid-jsdoc */\n}\n\nmodule.exports = Collector;\n"]},"metadata":{},"sourceType":"script"}