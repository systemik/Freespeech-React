{"ast":null,"code":"'use strict';\n/* eslint-disable import/order */\n\nconst MessageCollector = require('../MessageCollector');\n\nconst APIMessage = require('../APIMessage');\n\nconst Snowflake = require('../../util/Snowflake');\n\nconst Collection = require('../../util/Collection');\n\nconst {\n  RangeError,\n  TypeError\n} = require('../../errors');\n/**\n * Interface for classes that have text-channel-like features.\n * @interface\n */\n\n\nclass TextBasedChannel {\n  constructor() {\n    /**\n     * A manager of the messages sent to this channel\n     * @type {MessageManager}\n     */\n    this.messages = new MessageManager(this);\n    /**\n     * The ID of the last message in the channel, if one was sent\n     * @type {?Snowflake}\n     */\n\n    this.lastMessageID = null;\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n\n    this.lastPinTimestamp = null;\n  }\n  /**\n   * The Message object of the last message in the channel, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n\n\n  get lastMessage() {\n    return this.messages.cache.get(this.lastMessageID) || null;\n  }\n  /**\n   * The date when the last pinned message was pinned, if there was one\n   * @type {?Date}\n   * @readonly\n   */\n\n\n  get lastPinAt() {\n    return this.lastPinTimestamp ? new Date(this.lastPinTimestamp) : null;\n  }\n  /**\n   * Options provided when sending or editing a message.\n   * @typedef {Object} MessageOptions\n   * @property {boolean} [tts=false] Whether or not the message should be spoken aloud\n   * @property {string} [nonce=''] The nonce for the message\n   * @property {string} [content=''] The content for the message\n   * @property {MessageEmbed|Object} [embed] An embed for the message\n   * (see [here](https://discord.com/developers/docs/resources/channel#embed-object) for more details)\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   * @property {DisableMentionType} [disableMentions=this.client.options.disableMentions] Whether or not all mentions or\n   * everyone/here mentions should be sanitized to prevent unexpected mentions\n   * @property {FileOptions[]|BufferResolvable[]} [files] Files to send with the message\n   * @property {string|boolean} [code] Language for optional codeblock formatting to apply\n   * @property {boolean|SplitOptions} [split=false] Whether or not the message should be split into multiple messages if\n   * it exceeds the character limit. If an object is provided, these are the options for splitting the message\n   * @property {UserResolvable} [reply] User to reply to (prefixes the message with a mention, except in DMs)\n   */\n\n  /**\n   * Options provided to control parsing of mentions by Discord\n   * @typedef {Object} MessageMentionOptions\n   * @property {MessageMentionTypes[]} [parse] Types of mentions to be parsed\n   * @property {Snowflake[]} [users] Snowflakes of Users to be parsed as mentions\n   * @property {Snowflake[]} [roles] Snowflakes of Roles to be parsed as mentions\n   */\n\n  /**\n   * Types of mentions to enable in MessageMentionOptions.\n   * - `roles`\n   * - `users`\n   * - `everyone`\n   * @typedef {string} MessageMentionTypes\n   */\n\n  /**\n   * The type of mentions to disable.\n   * - `none`\n   * - `all`\n   * - `everyone`\n   * @typedef {string} DisableMentionType\n   */\n\n  /**\n   * @typedef {Object} FileOptions\n   * @property {BufferResolvable} attachment File to attach\n   * @property {string} [name='file.jpg'] Filename of the attachment\n   */\n\n  /**\n   * Options for splitting a message.\n   * @typedef {Object} SplitOptions\n   * @property {number} [maxLength=2000] Maximum character length per message piece\n   * @property {string} [char='\\n'] Character to split the message with\n   * @property {string} [prepend=''] Text to prepend to every piece except the first\n   * @property {string} [append=''] Text to append to every piece except the last\n   */\n\n  /**\n   * Sends a message to this channel.\n   * @param {StringResolvable|APIMessage} [content=''] The content to send\n   * @param {MessageOptions|MessageAdditions} [options={}] The options to provide\n   * @returns {Promise<Message|Message[]>}\n   * @example\n   * // Send a basic message\n   * channel.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * channel.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * channel.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send an embed with a local image inside\n   * channel.send('This is an embed', {\n   *   embed: {\n   *     thumbnail: {\n   *          url: 'attachment://file.jpg'\n   *       }\n   *    },\n   *    files: [{\n   *       attachment: 'entire/path/to/file.jpg',\n   *       name: 'file.jpg'\n   *    }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async send(content, options) {\n    const User = require('../User');\n\n    const GuildMember = require('../GuildMember');\n\n    if (this instanceof User || this instanceof GuildMember) {\n      return this.createDM().then(dm => dm.send(content, options));\n    }\n\n    let apiMessage;\n\n    if (content instanceof APIMessage) {\n      apiMessage = content.resolveData();\n    } else {\n      apiMessage = APIMessage.create(this, content, options).resolveData();\n\n      if (Array.isArray(apiMessage.data.content)) {\n        return Promise.all(apiMessage.split().map(this.send.bind(this)));\n      }\n    }\n\n    const {\n      data,\n      files\n    } = await apiMessage.resolveFiles();\n    return this.client.api.channels[this.id].messages.post({\n      data,\n      files\n    }).then(d => this.client.actions.MessageCreate.handle(d).message);\n  }\n  /**\n   * Starts a typing indicator in the channel.\n   * @param {number} [count=1] The number of times startTyping should be considered to have been called\n   * @returns {Promise} Resolves once the bot stops typing gracefully, or rejects when an error occurs\n   * @example\n   * // Start typing in a channel, or increase the typing count by one\n   * channel.startTyping();\n   * @example\n   * // Start typing in a channel with a typing count of five, or set it to five\n   * channel.startTyping(5);\n   */\n\n\n  startTyping(count) {\n    if (typeof count !== 'undefined' && count < 1) throw new RangeError('TYPING_COUNT');\n\n    if (this.client.user._typing.has(this.id)) {\n      const entry = this.client.user._typing.get(this.id);\n\n      entry.count = count || entry.count + 1;\n      return entry.promise;\n    }\n\n    const entry = {};\n    entry.promise = new Promise((resolve, reject) => {\n      const endpoint = this.client.api.channels[this.id].typing;\n      Object.assign(entry, {\n        count: count || 1,\n        interval: this.client.setInterval(() => {\n          endpoint.post().catch(error => {\n            this.client.clearInterval(entry.interval);\n\n            this.client.user._typing.delete(this.id);\n\n            reject(error);\n          });\n        }, 9000),\n        resolve\n      });\n      endpoint.post().catch(error => {\n        this.client.clearInterval(entry.interval);\n\n        this.client.user._typing.delete(this.id);\n\n        reject(error);\n      });\n\n      this.client.user._typing.set(this.id, entry);\n    });\n    return entry.promise;\n  }\n  /**\n   * Stops the typing indicator in the channel.\n   * The indicator will only stop if this is called as many times as startTyping().\n   * <info>It can take a few seconds for the client user to stop typing.</info>\n   * @param {boolean} [force=false] Whether or not to reset the call count and force the indicator to stop\n   * @example\n   * // Reduce the typing count by one and stop typing if it reached 0\n   * channel.stopTyping();\n   * @example\n   * // Force typing to fully stop regardless of typing count\n   * channel.stopTyping(true);\n   */\n\n\n  stopTyping() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (this.client.user._typing.has(this.id)) {\n      const entry = this.client.user._typing.get(this.id);\n\n      entry.count--;\n\n      if (entry.count <= 0 || force) {\n        this.client.clearInterval(entry.interval);\n\n        this.client.user._typing.delete(this.id);\n\n        entry.resolve();\n      }\n    }\n  }\n  /**\n   * Whether or not the typing indicator is being shown in the channel\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get typing() {\n    return this.client.user._typing.has(this.id);\n  }\n  /**\n   * Number of times `startTyping` has been called\n   * @type {number}\n   * @readonly\n   */\n\n\n  get typingCount() {\n    if (this.client.user._typing.has(this.id)) return this.client.user._typing.get(this.id).count;\n    return 0;\n  }\n  /**\n   * Creates a Message Collector.\n   * @param {CollectorFilter} filter The filter to create the collector with\n   * @param {MessageCollectorOptions} [options={}] The options to pass to the collector\n   * @returns {MessageCollector}\n   * @example\n   * // Create a message collector\n   * const filter = m => m.content.includes('discord');\n   * const collector = channel.createMessageCollector(filter, { time: 15000 });\n   * collector.on('collect', m => console.log(`Collected ${m.content}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n\n\n  createMessageCollector(filter) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new MessageCollector(this, filter, options);\n  }\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {MessageCollectorOptions} AwaitMessagesOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createMessageCollector but in promise form.\n   * Resolves with a collection of messages that pass the specified filter.\n   * @param {CollectorFilter} filter The filter function to use\n   * @param {AwaitMessagesOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Await !vote messages\n   * const filter = m => m.content.startsWith('!vote');\n   * // Errors: ['time'] treats ending because of the time limit as an error\n   * channel.awaitMessages(filter, { max: 4, time: 60000, errors: ['time'] })\n   *   .then(collected => console.log(collected.size))\n   *   .catch(collected => console.log(`After a minute, only ${collected.size} out of 4 voted.`));\n   */\n\n\n  awaitMessages(filter) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageCollector(filter, options);\n      collector.once('end', (collection, reason) => {\n        if (options.errors && options.errors.includes(reason)) {\n          reject(collection);\n        } else {\n          resolve(collection);\n        }\n      });\n    });\n  }\n  /**\n   * Bulk deletes given messages that are newer than two weeks.\n   * @param {Collection<Snowflake, Message>|MessageResolvable[]|number} messages\n   * Messages or number of messages to delete\n   * @param {boolean} [filterOld=false] Filter messages to remove those which are older than two weeks automatically\n   * @returns {Promise<Collection<Snowflake, Message>>} Deleted messages\n   * @example\n   * // Bulk delete messages\n   * channel.bulkDelete(5)\n   *   .then(messages => console.log(`Bulk deleted ${messages.size} messages`))\n   *   .catch(console.error);\n   */\n\n\n  async bulkDelete(messages) {\n    let filterOld = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (Array.isArray(messages) || messages instanceof Collection) {\n      let messageIDs = messages instanceof Collection ? messages.keyArray() : messages.map(m => m.id || m);\n\n      if (filterOld) {\n        messageIDs = messageIDs.filter(id => Date.now() - Snowflake.deconstruct(id).date.getTime() < 1209600000);\n      }\n\n      if (messageIDs.length === 0) return new Collection();\n\n      if (messageIDs.length === 1) {\n        await this.client.api.channels(this.id).messages(messageIDs[0]).delete();\n        const message = this.client.actions.MessageDelete.getMessage({\n          message_id: messageIDs[0]\n        }, this);\n        return message ? new Collection([[message.id, message]]) : new Collection();\n      }\n\n      await this.client.api.channels[this.id].messages['bulk-delete'].post({\n        data: {\n          messages: messageIDs\n        }\n      });\n      return messageIDs.reduce((col, id) => col.set(id, this.client.actions.MessageDeleteBulk.getMessage({\n        message_id: id\n      }, this)), new Collection());\n    }\n\n    if (!isNaN(messages)) {\n      const msgs = await this.messages.fetch({\n        limit: messages\n      });\n      return this.bulkDelete(msgs, filterOld);\n    }\n\n    throw new TypeError('MESSAGE_BULK_DELETE_TYPE');\n  }\n\n  static applyToClass(structure) {\n    let full = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let ignore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    const props = ['send'];\n\n    if (full) {\n      props.push('lastMessage', 'lastPinAt', 'bulkDelete', 'startTyping', 'stopTyping', 'typing', 'typingCount', 'createMessageCollector', 'awaitMessages');\n    }\n\n    for (const prop of props) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop));\n    }\n  }\n\n}\n\nmodule.exports = TextBasedChannel; // Fixes Circular\n\nconst MessageManager = require('../../managers/MessageManager');","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js"],"names":["MessageCollector","require","APIMessage","Snowflake","Collection","RangeError","TypeError","TextBasedChannel","constructor","messages","MessageManager","lastMessageID","lastPinTimestamp","lastMessage","cache","get","lastPinAt","Date","send","content","options","User","GuildMember","createDM","then","dm","apiMessage","resolveData","create","Array","isArray","data","Promise","all","split","map","bind","files","resolveFiles","client","api","channels","id","post","d","actions","MessageCreate","handle","message","startTyping","count","user","_typing","has","entry","promise","resolve","reject","endpoint","typing","Object","assign","interval","setInterval","catch","error","clearInterval","delete","set","stopTyping","force","typingCount","createMessageCollector","filter","awaitMessages","collector","once","collection","reason","errors","includes","bulkDelete","filterOld","messageIDs","keyArray","m","now","deconstruct","date","getTime","length","MessageDelete","getMessage","message_id","reduce","col","MessageDeleteBulk","isNaN","msgs","fetch","limit","applyToClass","structure","full","ignore","props","push","prop","defineProperty","prototype","getOwnPropertyDescriptor","module","exports"],"mappings":"AAAA;AAEA;;AACA,MAAMA,gBAAgB,GAAGC,OAAO,CAAC,qBAAD,CAAhC;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,sBAAD,CAAzB;;AACA,MAAMG,UAAU,GAAGH,OAAO,CAAC,uBAAD,CAA1B;;AACA,MAAM;AAAEI,EAAAA,UAAF;AAAcC,EAAAA;AAAd,IAA4BL,OAAO,CAAC,cAAD,CAAzC;AAEA;AACA;AACA;AACA;;;AACA,MAAMM,gBAAN,CAAuB;AACrBC,EAAAA,WAAW,GAAG;AACZ;AACJ;AACA;AACA;AACI,SAAKC,QAAL,GAAgB,IAAIC,cAAJ,CAAmB,IAAnB,CAAhB;AAEA;AACJ;AACA;AACA;;AACI,SAAKC,aAAL,GAAqB,IAArB;AAEA;AACJ;AACA;AACA;;AACI,SAAKC,gBAAL,GAAwB,IAAxB;AACD;AAED;AACF;AACA;AACA;AACA;;;AACiB,MAAXC,WAAW,GAAG;AAChB,WAAO,KAAKJ,QAAL,CAAcK,KAAd,CAAoBC,GAApB,CAAwB,KAAKJ,aAA7B,KAA+C,IAAtD;AACD;AAED;AACF;AACA;AACA;AACA;;;AACe,MAATK,SAAS,GAAG;AACd,WAAO,KAAKJ,gBAAL,GAAwB,IAAIK,IAAJ,CAAS,KAAKL,gBAAd,CAAxB,GAA0D,IAAjE;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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","sourcesContent":["'use strict';\n\n/* eslint-disable import/order */\nconst MessageCollector = require('../MessageCollector');\nconst APIMessage = require('../APIMessage');\nconst Snowflake = require('../../util/Snowflake');\nconst Collection = require('../../util/Collection');\nconst { RangeError, TypeError } = require('../../errors');\n\n/**\n * Interface for classes that have text-channel-like features.\n * @interface\n */\nclass TextBasedChannel {\n  constructor() {\n    /**\n     * A manager of the messages sent to this channel\n     * @type {MessageManager}\n     */\n    this.messages = new MessageManager(this);\n\n    /**\n     * The ID of the last message in the channel, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageID = null;\n\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n    this.lastPinTimestamp = null;\n  }\n\n  /**\n   * The Message object of the last message in the channel, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n  get lastMessage() {\n    return this.messages.cache.get(this.lastMessageID) || null;\n  }\n\n  /**\n   * The date when the last pinned message was pinned, if there was one\n   * @type {?Date}\n   * @readonly\n   */\n  get lastPinAt() {\n    return this.lastPinTimestamp ? new Date(this.lastPinTimestamp) : null;\n  }\n\n  /**\n   * Options provided when sending or editing a message.\n   * @typedef {Object} MessageOptions\n   * @property {boolean} [tts=false] Whether or not the message should be spoken aloud\n   * @property {string} [nonce=''] The nonce for the message\n   * @property {string} [content=''] The content for the message\n   * @property {MessageEmbed|Object} [embed] An embed for the message\n   * (see [here](https://discord.com/developers/docs/resources/channel#embed-object) for more details)\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   * @property {DisableMentionType} [disableMentions=this.client.options.disableMentions] Whether or not all mentions or\n   * everyone/here mentions should be sanitized to prevent unexpected mentions\n   * @property {FileOptions[]|BufferResolvable[]} [files] Files to send with the message\n   * @property {string|boolean} [code] Language for optional codeblock formatting to apply\n   * @property {boolean|SplitOptions} [split=false] Whether or not the message should be split into multiple messages if\n   * it exceeds the character limit. If an object is provided, these are the options for splitting the message\n   * @property {UserResolvable} [reply] User to reply to (prefixes the message with a mention, except in DMs)\n   */\n\n  /**\n   * Options provided to control parsing of mentions by Discord\n   * @typedef {Object} MessageMentionOptions\n   * @property {MessageMentionTypes[]} [parse] Types of mentions to be parsed\n   * @property {Snowflake[]} [users] Snowflakes of Users to be parsed as mentions\n   * @property {Snowflake[]} [roles] Snowflakes of Roles to be parsed as mentions\n   */\n\n  /**\n   * Types of mentions to enable in MessageMentionOptions.\n   * - `roles`\n   * - `users`\n   * - `everyone`\n   * @typedef {string} MessageMentionTypes\n   */\n\n  /**\n   * The type of mentions to disable.\n   * - `none`\n   * - `all`\n   * - `everyone`\n   * @typedef {string} DisableMentionType\n   */\n\n  /**\n   * @typedef {Object} FileOptions\n   * @property {BufferResolvable} attachment File to attach\n   * @property {string} [name='file.jpg'] Filename of the attachment\n   */\n\n  /**\n   * Options for splitting a message.\n   * @typedef {Object} SplitOptions\n   * @property {number} [maxLength=2000] Maximum character length per message piece\n   * @property {string} [char='\\n'] Character to split the message with\n   * @property {string} [prepend=''] Text to prepend to every piece except the first\n   * @property {string} [append=''] Text to append to every piece except the last\n   */\n\n  /**\n   * Sends a message to this channel.\n   * @param {StringResolvable|APIMessage} [content=''] The content to send\n   * @param {MessageOptions|MessageAdditions} [options={}] The options to provide\n   * @returns {Promise<Message|Message[]>}\n   * @example\n   * // Send a basic message\n   * channel.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * channel.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * channel.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send an embed with a local image inside\n   * channel.send('This is an embed', {\n   *   embed: {\n   *     thumbnail: {\n   *          url: 'attachment://file.jpg'\n   *       }\n   *    },\n   *    files: [{\n   *       attachment: 'entire/path/to/file.jpg',\n   *       name: 'file.jpg'\n   *    }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async send(content, options) {\n    const User = require('../User');\n    const GuildMember = require('../GuildMember');\n\n    if (this instanceof User || this instanceof GuildMember) {\n      return this.createDM().then(dm => dm.send(content, options));\n    }\n\n    let apiMessage;\n\n    if (content instanceof APIMessage) {\n      apiMessage = content.resolveData();\n    } else {\n      apiMessage = APIMessage.create(this, content, options).resolveData();\n      if (Array.isArray(apiMessage.data.content)) {\n        return Promise.all(apiMessage.split().map(this.send.bind(this)));\n      }\n    }\n\n    const { data, files } = await apiMessage.resolveFiles();\n    return this.client.api.channels[this.id].messages\n      .post({ data, files })\n      .then(d => this.client.actions.MessageCreate.handle(d).message);\n  }\n\n  /**\n   * Starts a typing indicator in the channel.\n   * @param {number} [count=1] The number of times startTyping should be considered to have been called\n   * @returns {Promise} Resolves once the bot stops typing gracefully, or rejects when an error occurs\n   * @example\n   * // Start typing in a channel, or increase the typing count by one\n   * channel.startTyping();\n   * @example\n   * // Start typing in a channel with a typing count of five, or set it to five\n   * channel.startTyping(5);\n   */\n  startTyping(count) {\n    if (typeof count !== 'undefined' && count < 1) throw new RangeError('TYPING_COUNT');\n    if (this.client.user._typing.has(this.id)) {\n      const entry = this.client.user._typing.get(this.id);\n      entry.count = count || entry.count + 1;\n      return entry.promise;\n    }\n\n    const entry = {};\n    entry.promise = new Promise((resolve, reject) => {\n      const endpoint = this.client.api.channels[this.id].typing;\n      Object.assign(entry, {\n        count: count || 1,\n        interval: this.client.setInterval(() => {\n          endpoint.post().catch(error => {\n            this.client.clearInterval(entry.interval);\n            this.client.user._typing.delete(this.id);\n            reject(error);\n          });\n        }, 9000),\n        resolve,\n      });\n      endpoint.post().catch(error => {\n        this.client.clearInterval(entry.interval);\n        this.client.user._typing.delete(this.id);\n        reject(error);\n      });\n      this.client.user._typing.set(this.id, entry);\n    });\n    return entry.promise;\n  }\n\n  /**\n   * Stops the typing indicator in the channel.\n   * The indicator will only stop if this is called as many times as startTyping().\n   * <info>It can take a few seconds for the client user to stop typing.</info>\n   * @param {boolean} [force=false] Whether or not to reset the call count and force the indicator to stop\n   * @example\n   * // Reduce the typing count by one and stop typing if it reached 0\n   * channel.stopTyping();\n   * @example\n   * // Force typing to fully stop regardless of typing count\n   * channel.stopTyping(true);\n   */\n  stopTyping(force = false) {\n    if (this.client.user._typing.has(this.id)) {\n      const entry = this.client.user._typing.get(this.id);\n      entry.count--;\n      if (entry.count <= 0 || force) {\n        this.client.clearInterval(entry.interval);\n        this.client.user._typing.delete(this.id);\n        entry.resolve();\n      }\n    }\n  }\n\n  /**\n   * Whether or not the typing indicator is being shown in the channel\n   * @type {boolean}\n   * @readonly\n   */\n  get typing() {\n    return this.client.user._typing.has(this.id);\n  }\n\n  /**\n   * Number of times `startTyping` has been called\n   * @type {number}\n   * @readonly\n   */\n  get typingCount() {\n    if (this.client.user._typing.has(this.id)) return this.client.user._typing.get(this.id).count;\n    return 0;\n  }\n\n  /**\n   * Creates a Message Collector.\n   * @param {CollectorFilter} filter The filter to create the collector with\n   * @param {MessageCollectorOptions} [options={}] The options to pass to the collector\n   * @returns {MessageCollector}\n   * @example\n   * // Create a message collector\n   * const filter = m => m.content.includes('discord');\n   * const collector = channel.createMessageCollector(filter, { time: 15000 });\n   * collector.on('collect', m => console.log(`Collected ${m.content}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createMessageCollector(filter, options = {}) {\n    return new MessageCollector(this, filter, options);\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {MessageCollectorOptions} AwaitMessagesOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createMessageCollector but in promise form.\n   * Resolves with a collection of messages that pass the specified filter.\n   * @param {CollectorFilter} filter The filter function to use\n   * @param {AwaitMessagesOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Await !vote messages\n   * const filter = m => m.content.startsWith('!vote');\n   * // Errors: ['time'] treats ending because of the time limit as an error\n   * channel.awaitMessages(filter, { max: 4, time: 60000, errors: ['time'] })\n   *   .then(collected => console.log(collected.size))\n   *   .catch(collected => console.log(`After a minute, only ${collected.size} out of 4 voted.`));\n   */\n  awaitMessages(filter, options = {}) {\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageCollector(filter, options);\n      collector.once('end', (collection, reason) => {\n        if (options.errors && options.errors.includes(reason)) {\n          reject(collection);\n        } else {\n          resolve(collection);\n        }\n      });\n    });\n  }\n\n  /**\n   * Bulk deletes given messages that are newer than two weeks.\n   * @param {Collection<Snowflake, Message>|MessageResolvable[]|number} messages\n   * Messages or number of messages to delete\n   * @param {boolean} [filterOld=false] Filter messages to remove those which are older than two weeks automatically\n   * @returns {Promise<Collection<Snowflake, Message>>} Deleted messages\n   * @example\n   * // Bulk delete messages\n   * channel.bulkDelete(5)\n   *   .then(messages => console.log(`Bulk deleted ${messages.size} messages`))\n   *   .catch(console.error);\n   */\n  async bulkDelete(messages, filterOld = false) {\n    if (Array.isArray(messages) || messages instanceof Collection) {\n      let messageIDs = messages instanceof Collection ? messages.keyArray() : messages.map(m => m.id || m);\n      if (filterOld) {\n        messageIDs = messageIDs.filter(id => Date.now() - Snowflake.deconstruct(id).date.getTime() < 1209600000);\n      }\n      if (messageIDs.length === 0) return new Collection();\n      if (messageIDs.length === 1) {\n        await this.client.api.channels(this.id).messages(messageIDs[0]).delete();\n        const message = this.client.actions.MessageDelete.getMessage(\n          {\n            message_id: messageIDs[0],\n          },\n          this,\n        );\n        return message ? new Collection([[message.id, message]]) : new Collection();\n      }\n      await this.client.api.channels[this.id].messages['bulk-delete'].post({ data: { messages: messageIDs } });\n      return messageIDs.reduce(\n        (col, id) =>\n          col.set(\n            id,\n            this.client.actions.MessageDeleteBulk.getMessage(\n              {\n                message_id: id,\n              },\n              this,\n            ),\n          ),\n        new Collection(),\n      );\n    }\n    if (!isNaN(messages)) {\n      const msgs = await this.messages.fetch({ limit: messages });\n      return this.bulkDelete(msgs, filterOld);\n    }\n    throw new TypeError('MESSAGE_BULK_DELETE_TYPE');\n  }\n\n  static applyToClass(structure, full = false, ignore = []) {\n    const props = ['send'];\n    if (full) {\n      props.push(\n        'lastMessage',\n        'lastPinAt',\n        'bulkDelete',\n        'startTyping',\n        'stopTyping',\n        'typing',\n        'typingCount',\n        'createMessageCollector',\n        'awaitMessages',\n      );\n    }\n    for (const prop of props) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(\n        structure.prototype,\n        prop,\n        Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop),\n      );\n    }\n  }\n}\n\nmodule.exports = TextBasedChannel;\n\n// Fixes Circular\nconst MessageManager = require('../../managers/MessageManager');\n"]},"metadata":{},"sourceType":"script"}