{"ast":null,"code":"'use strict';\n\nconst Base = require('./Base');\n\nconst {\n  Error,\n  TypeError\n} = require('../errors');\n\nconst Permissions = require('../util/Permissions');\n\nconst Snowflake = require('../util/Snowflake');\n\nconst Util = require('../util/Util');\n/**\n * Represents a role on Discord.\n * @extends {Base}\n */\n\n\nclass Role extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the role\n   * @param {Guild} guild The guild the role is part of\n   */\n  constructor(client, data, guild) {\n    super(client);\n    /**\n     * The guild that the role belongs to\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The ID of the role (unique to the guild it is part of)\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n    /**\n     * The name of the role\n     * @type {string}\n     */\n\n    this.name = data.name;\n    /**\n     * The base 10 color of the role\n     * @type {number}\n     */\n\n    this.color = data.color;\n    /**\n     * If true, users that are part of this role will appear in a separate category in the users list\n     * @type {boolean}\n     */\n\n    this.hoist = data.hoist;\n    /**\n     * The raw position of the role from the API\n     * @type {number}\n     */\n\n    this.rawPosition = data.position;\n    /**\n     * The permissions of the role\n     * @type {Readonly<Permissions>}\n     */\n\n    this.permissions = new Permissions(data.permissions).freeze();\n    /**\n     * Whether or not the role is managed by an external service\n     * @type {boolean}\n     */\n\n    this.managed = data.managed;\n    /**\n     * Whether or not the role can be mentioned by anyone\n     * @type {boolean}\n     */\n\n    this.mentionable = data.mentionable;\n    /**\n     * Whether the role has been deleted\n     * @type {boolean}\n     */\n\n    this.deleted = false;\n  }\n  /**\n   * The timestamp the role was created at\n   * @type {number}\n   * @readonly\n   */\n\n\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n  /**\n   * The time the role was created at\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * The hexadecimal version of the role color, with a leading hashtag\n   * @type {string}\n   * @readonly\n   */\n\n\n  get hexColor() {\n    return `#${this.color.toString(16).padStart(6, '0')}`;\n  }\n  /**\n   * The cached guild members that have this role\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n\n\n  get members() {\n    return this.guild.members.cache.filter(m => m.roles.cache.has(this.id));\n  }\n  /**\n   * Whether the role is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get editable() {\n    if (this.managed) return false;\n    const clientMember = this.guild.member(this.client.user);\n    if (!clientMember.permissions.has(Permissions.FLAGS.MANAGE_ROLES)) return false;\n    return clientMember.roles.highest.comparePositionTo(this) > 0;\n  }\n  /**\n   * The position of the role in the role manager\n   * @type {number}\n   * @readonly\n   */\n\n\n  get position() {\n    const sorted = this.guild._sortedRoles();\n\n    return sorted.array().indexOf(sorted.get(this.id));\n  }\n  /**\n   * Compares this role's position to another role's.\n   * @param {RoleResolvable} role Role to compare to this one\n   * @returns {number} Negative number if this role's position is lower (other role's is higher),\n   * positive number if this one is higher (other's is lower), 0 if equal\n   */\n\n\n  comparePositionTo(role) {\n    role = this.guild.roles.resolve(role);\n    if (!role) throw new TypeError('INVALID_TYPE', 'role', 'Role nor a Snowflake');\n    return this.constructor.comparePositions(this, role);\n  }\n  /**\n   * The data for a role.\n   * @typedef {Object} RoleData\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   */\n\n  /**\n   * Edits the role.\n   * @param {RoleData} data The new data for the role\n   * @param {string} [reason] Reason for editing this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * role.edit({ name: 'new role' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n\n\n  async edit(data, reason) {\n    if (typeof data.permissions !== 'undefined') data.permissions = Permissions.resolve(data.permissions);else data.permissions = this.permissions.bitfield;\n\n    if (typeof data.position !== 'undefined') {\n      await Util.setPosition(this, data.position, false, this.guild._sortedRoles(), this.client.api.guilds(this.guild.id).roles, reason).then(updatedRoles => {\n        this.client.actions.GuildRolesPositionUpdate.handle({\n          guild_id: this.guild.id,\n          roles: updatedRoles\n        });\n      });\n    }\n\n    return this.client.api.guilds[this.guild.id].roles[this.id].patch({\n      data: {\n        name: data.name || this.name,\n        color: data.color !== null ? Util.resolveColor(data.color || this.color) : null,\n        hoist: typeof data.hoist !== 'undefined' ? data.hoist : this.hoist,\n        permissions: data.permissions,\n        mentionable: typeof data.mentionable !== 'undefined' ? data.mentionable : this.mentionable\n      },\n      reason\n    }).then(role => {\n      const clone = this._clone();\n\n      clone._patch(role);\n\n      return clone;\n    });\n  }\n  /**\n   * Returns `channel.permissionsFor(role)`. Returns permissions for a role in a guild channel,\n   * taking into account permission overwrites.\n   * @param {ChannelResolvable} channel The guild channel to use as context\n   * @returns {Readonly<Permissions>}\n   */\n\n\n  permissionsIn(channel) {\n    channel = this.guild.channels.resolve(channel);\n    if (!channel) throw new Error('GUILD_CHANNEL_RESOLVE');\n    return channel.rolePermissions(this);\n  }\n  /**\n   * Sets a new name for the role.\n   * @param {string} name The new name of the role\n   * @param {string} [reason] Reason for changing the role's name\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the name of the role\n   * role.setName('new role')\n   *   .then(updated => console.log(`Updated role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setName(name, reason) {\n    return this.edit({\n      name\n    }, reason);\n  }\n  /**\n   * Sets a new color for the role.\n   * @param {ColorResolvable} color The color of the role\n   * @param {string} [reason] Reason for changing the role's color\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the color of a role\n   * role.setColor('#FF0000')\n   *   .then(updated => console.log(`Set color of role to ${updated.color}`))\n   *   .catch(console.error);\n   */\n\n\n  setColor(color, reason) {\n    return this.edit({\n      color\n    }, reason);\n  }\n  /**\n   * Sets whether or not the role should be hoisted.\n   * @param {boolean} hoist Whether or not to hoist the role\n   * @param {string} [reason] Reason for setting whether or not the role should be hoisted\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the hoist of the role\n   * role.setHoist(true)\n   *   .then(updated => console.log(`Role hoisted: ${updated.hoist}`))\n   *   .catch(console.error);\n   */\n\n\n  setHoist(hoist, reason) {\n    return this.edit({\n      hoist\n    }, reason);\n  }\n  /**\n   * Sets the permissions of the role.\n   * @param {PermissionResolvable} permissions The permissions of the role\n   * @param {string} [reason] Reason for changing the role's permissions\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the permissions of the role\n   * role.setPermissions(['KICK_MEMBERS', 'BAN_MEMBERS'])\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   * @example\n   * // Remove all permissions from a role\n   * role.setPermissions(0)\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   */\n\n\n  setPermissions(permissions, reason) {\n    return this.edit({\n      permissions\n    }, reason);\n  }\n  /**\n   * Sets whether this role is mentionable.\n   * @param {boolean} mentionable Whether this role should be mentionable\n   * @param {string} [reason] Reason for setting whether or not this role should be mentionable\n   * @returns {Promise<Role>}\n   * @example\n   * // Make the role mentionable\n   * role.setMentionable(true)\n   *   .then(updated => console.log(`Role updated ${updated.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setMentionable(mentionable, reason) {\n    return this.edit({\n      mentionable\n    }, reason);\n  }\n  /**\n   * Sets the position of the role.\n   * @param {number} position The position of the role\n   * @param {Object} [options] Options for setting position\n   * @param {boolean} [options.relative=false] Change the position relative to its current value\n   * @param {string} [options.reason] Reason for changing the position\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the position of the role\n   * role.setPosition(1)\n   *   .then(updated => console.log(`Role position: ${updated.position}`))\n   *   .catch(console.error);\n   */\n\n\n  setPosition(position) {\n    let {\n      relative,\n      reason\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Util.setPosition(this, position, relative, this.guild._sortedRoles(), this.client.api.guilds(this.guild.id).roles, reason).then(updatedRoles => {\n      this.client.actions.GuildRolesPositionUpdate.handle({\n        guild_id: this.guild.id,\n        roles: updatedRoles\n      });\n      return this;\n    });\n  }\n  /**\n   * Deletes the role.\n   * @param {string} [reason] Reason for deleting this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Delete a role\n   * role.delete('The role needed to go')\n   *   .then(deleted => console.log(`Deleted role ${deleted.name}`))\n   *   .catch(console.error);\n   */\n\n\n  delete(reason) {\n    return this.client.api.guilds[this.guild.id].roles[this.id].delete({\n      reason\n    }).then(() => {\n      this.client.actions.GuildRoleDelete.handle({\n        guild_id: this.guild.id,\n        role_id: this.id\n      });\n      return this;\n    });\n  }\n  /**\n   * Whether this role equals another role. It compares all properties, so for most operations\n   * it is advisable to just compare `role.id === role2.id` as it is much faster and is often\n   * what most users need.\n   * @param {Role} role Role to compare with\n   * @returns {boolean}\n   */\n\n\n  equals(role) {\n    return role && this.id === role.id && this.name === role.name && this.color === role.color && this.hoist === role.hoist && this.position === role.position && this.permissions.bitfield === role.permissions.bitfield && this.managed === role.managed;\n  }\n  /**\n   * When concatenated with a string, this automatically returns the role's mention instead of the Role object.\n   * @returns {string}\n   * @example\n   * // Logs: Role: <@&123456789012345678>\n   * console.log(`Role: ${role}`);\n   */\n\n\n  toString() {\n    if (this.id === this.guild.id) return '@everyone';\n    return `<@&${this.id}>`;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      createdTimestamp: true\n    });\n  }\n  /**\n   * Compares the positions of two roles.\n   * @param {Role} role1 First role to compare\n   * @param {Role} role2 Second role to compare\n   * @returns {number} Negative number if the first role's position is lower (second role's is higher),\n   * positive number if the first's is higher (second's is lower), 0 if equal\n   */\n\n\n  static comparePositions(role1, role2) {\n    if (role1.position === role2.position) return role2.id - role1.id;\n    return role1.position - role2.position;\n  }\n\n}\n\nmodule.exports = Role;","map":{"version":3,"sources":["/Users/macbookpro/node_modules/discord.js/src/structures/Role.js"],"names":["Base","require","Error","TypeError","Permissions","Snowflake","Util","Role","constructor","client","data","guild","_patch","id","name","color","hoist","rawPosition","position","permissions","freeze","managed","mentionable","deleted","createdTimestamp","deconstruct","timestamp","createdAt","Date","hexColor","toString","padStart","members","cache","filter","m","roles","has","editable","clientMember","member","user","FLAGS","MANAGE_ROLES","highest","comparePositionTo","sorted","_sortedRoles","array","indexOf","get","role","resolve","comparePositions","edit","reason","bitfield","setPosition","api","guilds","then","updatedRoles","actions","GuildRolesPositionUpdate","handle","guild_id","patch","resolveColor","clone","_clone","permissionsIn","channel","channels","rolePermissions","setName","setColor","setHoist","setPermissions","setMentionable","relative","delete","GuildRoleDelete","role_id","equals","toJSON","role1","role2","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Base = require('./Base');\nconst { Error, TypeError } = require('../errors');\nconst Permissions = require('../util/Permissions');\nconst Snowflake = require('../util/Snowflake');\nconst Util = require('../util/Util');\n\n/**\n * Represents a role on Discord.\n * @extends {Base}\n */\nclass Role extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the role\n   * @param {Guild} guild The guild the role is part of\n   */\n  constructor(client, data, guild) {\n    super(client);\n\n    /**\n     * The guild that the role belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The ID of the role (unique to the guild it is part of)\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    /**\n     * The name of the role\n     * @type {string}\n     */\n    this.name = data.name;\n\n    /**\n     * The base 10 color of the role\n     * @type {number}\n     */\n    this.color = data.color;\n\n    /**\n     * If true, users that are part of this role will appear in a separate category in the users list\n     * @type {boolean}\n     */\n    this.hoist = data.hoist;\n\n    /**\n     * The raw position of the role from the API\n     * @type {number}\n     */\n    this.rawPosition = data.position;\n\n    /**\n     * The permissions of the role\n     * @type {Readonly<Permissions>}\n     */\n    this.permissions = new Permissions(data.permissions).freeze();\n\n    /**\n     * Whether or not the role is managed by an external service\n     * @type {boolean}\n     */\n    this.managed = data.managed;\n\n    /**\n     * Whether or not the role can be mentioned by anyone\n     * @type {boolean}\n     */\n    this.mentionable = data.mentionable;\n\n    /**\n     * Whether the role has been deleted\n     * @type {boolean}\n     */\n    this.deleted = false;\n  }\n\n  /**\n   * The timestamp the role was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n\n  /**\n   * The time the role was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The hexadecimal version of the role color, with a leading hashtag\n   * @type {string}\n   * @readonly\n   */\n  get hexColor() {\n    return `#${this.color.toString(16).padStart(6, '0')}`;\n  }\n\n  /**\n   * The cached guild members that have this role\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    return this.guild.members.cache.filter(m => m.roles.cache.has(this.id));\n  }\n\n  /**\n   * Whether the role is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    if (this.managed) return false;\n    const clientMember = this.guild.member(this.client.user);\n    if (!clientMember.permissions.has(Permissions.FLAGS.MANAGE_ROLES)) return false;\n    return clientMember.roles.highest.comparePositionTo(this) > 0;\n  }\n\n  /**\n   * The position of the role in the role manager\n   * @type {number}\n   * @readonly\n   */\n  get position() {\n    const sorted = this.guild._sortedRoles();\n    return sorted.array().indexOf(sorted.get(this.id));\n  }\n\n  /**\n   * Compares this role's position to another role's.\n   * @param {RoleResolvable} role Role to compare to this one\n   * @returns {number} Negative number if this role's position is lower (other role's is higher),\n   * positive number if this one is higher (other's is lower), 0 if equal\n   */\n  comparePositionTo(role) {\n    role = this.guild.roles.resolve(role);\n    if (!role) throw new TypeError('INVALID_TYPE', 'role', 'Role nor a Snowflake');\n    return this.constructor.comparePositions(this, role);\n  }\n\n  /**\n   * The data for a role.\n   * @typedef {Object} RoleData\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   */\n\n  /**\n   * Edits the role.\n   * @param {RoleData} data The new data for the role\n   * @param {string} [reason] Reason for editing this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * role.edit({ name: 'new role' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  async edit(data, reason) {\n    if (typeof data.permissions !== 'undefined') data.permissions = Permissions.resolve(data.permissions);\n    else data.permissions = this.permissions.bitfield;\n    if (typeof data.position !== 'undefined') {\n      await Util.setPosition(\n        this,\n        data.position,\n        false,\n        this.guild._sortedRoles(),\n        this.client.api.guilds(this.guild.id).roles,\n        reason,\n      ).then(updatedRoles => {\n        this.client.actions.GuildRolesPositionUpdate.handle({\n          guild_id: this.guild.id,\n          roles: updatedRoles,\n        });\n      });\n    }\n    return this.client.api.guilds[this.guild.id].roles[this.id]\n      .patch({\n        data: {\n          name: data.name || this.name,\n          color: data.color !== null ? Util.resolveColor(data.color || this.color) : null,\n          hoist: typeof data.hoist !== 'undefined' ? data.hoist : this.hoist,\n          permissions: data.permissions,\n          mentionable: typeof data.mentionable !== 'undefined' ? data.mentionable : this.mentionable,\n        },\n        reason,\n      })\n      .then(role => {\n        const clone = this._clone();\n        clone._patch(role);\n        return clone;\n      });\n  }\n\n  /**\n   * Returns `channel.permissionsFor(role)`. Returns permissions for a role in a guild channel,\n   * taking into account permission overwrites.\n   * @param {ChannelResolvable} channel The guild channel to use as context\n   * @returns {Readonly<Permissions>}\n   */\n  permissionsIn(channel) {\n    channel = this.guild.channels.resolve(channel);\n    if (!channel) throw new Error('GUILD_CHANNEL_RESOLVE');\n    return channel.rolePermissions(this);\n  }\n\n  /**\n   * Sets a new name for the role.\n   * @param {string} name The new name of the role\n   * @param {string} [reason] Reason for changing the role's name\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the name of the role\n   * role.setName('new role')\n   *   .then(updated => console.log(`Updated role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({ name }, reason);\n  }\n\n  /**\n   * Sets a new color for the role.\n   * @param {ColorResolvable} color The color of the role\n   * @param {string} [reason] Reason for changing the role's color\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the color of a role\n   * role.setColor('#FF0000')\n   *   .then(updated => console.log(`Set color of role to ${updated.color}`))\n   *   .catch(console.error);\n   */\n  setColor(color, reason) {\n    return this.edit({ color }, reason);\n  }\n\n  /**\n   * Sets whether or not the role should be hoisted.\n   * @param {boolean} hoist Whether or not to hoist the role\n   * @param {string} [reason] Reason for setting whether or not the role should be hoisted\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the hoist of the role\n   * role.setHoist(true)\n   *   .then(updated => console.log(`Role hoisted: ${updated.hoist}`))\n   *   .catch(console.error);\n   */\n  setHoist(hoist, reason) {\n    return this.edit({ hoist }, reason);\n  }\n\n  /**\n   * Sets the permissions of the role.\n   * @param {PermissionResolvable} permissions The permissions of the role\n   * @param {string} [reason] Reason for changing the role's permissions\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the permissions of the role\n   * role.setPermissions(['KICK_MEMBERS', 'BAN_MEMBERS'])\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   * @example\n   * // Remove all permissions from a role\n   * role.setPermissions(0)\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   */\n  setPermissions(permissions, reason) {\n    return this.edit({ permissions }, reason);\n  }\n\n  /**\n   * Sets whether this role is mentionable.\n   * @param {boolean} mentionable Whether this role should be mentionable\n   * @param {string} [reason] Reason for setting whether or not this role should be mentionable\n   * @returns {Promise<Role>}\n   * @example\n   * // Make the role mentionable\n   * role.setMentionable(true)\n   *   .then(updated => console.log(`Role updated ${updated.name}`))\n   *   .catch(console.error);\n   */\n  setMentionable(mentionable, reason) {\n    return this.edit({ mentionable }, reason);\n  }\n\n  /**\n   * Sets the position of the role.\n   * @param {number} position The position of the role\n   * @param {Object} [options] Options for setting position\n   * @param {boolean} [options.relative=false] Change the position relative to its current value\n   * @param {string} [options.reason] Reason for changing the position\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the position of the role\n   * role.setPosition(1)\n   *   .then(updated => console.log(`Role position: ${updated.position}`))\n   *   .catch(console.error);\n   */\n  setPosition(position, { relative, reason } = {}) {\n    return Util.setPosition(\n      this,\n      position,\n      relative,\n      this.guild._sortedRoles(),\n      this.client.api.guilds(this.guild.id).roles,\n      reason,\n    ).then(updatedRoles => {\n      this.client.actions.GuildRolesPositionUpdate.handle({\n        guild_id: this.guild.id,\n        roles: updatedRoles,\n      });\n      return this;\n    });\n  }\n\n  /**\n   * Deletes the role.\n   * @param {string} [reason] Reason for deleting this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Delete a role\n   * role.delete('The role needed to go')\n   *   .then(deleted => console.log(`Deleted role ${deleted.name}`))\n   *   .catch(console.error);\n   */\n  delete(reason) {\n    return this.client.api.guilds[this.guild.id].roles[this.id].delete({ reason }).then(() => {\n      this.client.actions.GuildRoleDelete.handle({ guild_id: this.guild.id, role_id: this.id });\n      return this;\n    });\n  }\n\n  /**\n   * Whether this role equals another role. It compares all properties, so for most operations\n   * it is advisable to just compare `role.id === role2.id` as it is much faster and is often\n   * what most users need.\n   * @param {Role} role Role to compare with\n   * @returns {boolean}\n   */\n  equals(role) {\n    return (\n      role &&\n      this.id === role.id &&\n      this.name === role.name &&\n      this.color === role.color &&\n      this.hoist === role.hoist &&\n      this.position === role.position &&\n      this.permissions.bitfield === role.permissions.bitfield &&\n      this.managed === role.managed\n    );\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the role's mention instead of the Role object.\n   * @returns {string}\n   * @example\n   * // Logs: Role: <@&123456789012345678>\n   * console.log(`Role: ${role}`);\n   */\n  toString() {\n    if (this.id === this.guild.id) return '@everyone';\n    return `<@&${this.id}>`;\n  }\n\n  toJSON() {\n    return super.toJSON({ createdTimestamp: true });\n  }\n\n  /**\n   * Compares the positions of two roles.\n   * @param {Role} role1 First role to compare\n   * @param {Role} role2 Second role to compare\n   * @returns {number} Negative number if the first role's position is lower (second role's is higher),\n   * positive number if the first's is higher (second's is lower), 0 if equal\n   */\n  static comparePositions(role1, role2) {\n    if (role1.position === role2.position) return role2.id - role1.id;\n    return role1.position - role2.position;\n  }\n}\n\nmodule.exports = Role;\n"]},"metadata":{},"sourceType":"script"}